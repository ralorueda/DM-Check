***(
Copyright 2021-2025 Universitat Politècnica de València, Spain

This program is free software: you can redistribute it and/or modify it under the terms 
of the GNU General Public License as published by the Free Software Foundation, either 
version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
)***

--------------------------------------------------------------------------------
---                                                       To be run on Maude 3.5
---                                                     http://maude.cs.uiuc.edu
---
---                                                       Based on the theory of
---
---                                Inductive Reasoning with Equality Predicates,
---                        Contextual Rewriting and Variant-Based Simplification
---                                                             by José Meseguer
---
---                                                            Implementation by
---                                                Julia Sapiña <jsapina@upv.es>
---
--------------------------------------------------------------------------------

load file.maude
load time.maude

set include BOOL off .

fmod NuITP-BOOL is
    sort NuITP-Bool .

    op true : -> NuITP-Bool [ ctor ] .
    op false : -> NuITP-Bool [ ctor ] .
endfm

fmod NuITP-CLAUSE is
    pr NuITP-BOOL .

    sorts NuITP-Rl NuITP-Eq NuITP-EqConj NuITP-EqDisj NuITP-ConjEqDisj NuITP-Clause .
    subsorts NuITP-Bool < NuITP-Rl < NuITP-Eq < NuITP-EqConj NuITP-EqDisj < NuITP-ConjEqDisj .
    subsorts NuITP-Bool < NuITP-Clause .
    
    var E : NuITP-Eq .
    var EC EC' EC'' : NuITP-EqConj .
    vars ED ED' : NuITP-EqDisj .
    vars CED CED' CED'' : NuITP-ConjEqDisj .
    var CLA : NuITP-Clause .

    op _=_ : Universal Universal -> NuITP-Eq [ ctor comm poly (1 2) ] .
    op _=>_ : Universal Universal -> NuITP-Rl [ ctor poly (1 2) ] .

    op _\/_ : NuITP-EqDisj NuITP-EqDisj -> NuITP-EqDisj [ assoc comm ] .
    eq true \/ ED = true .
    eq false \/ ED = ED .
    eq ED \/ ED = ED .
    eq ED \/ not(ED) = true .

    op _/\_ : NuITP-ConjEqDisj NuITP-ConjEqDisj -> NuITP-ConjEqDisj [ assoc comm ] .
    op _/\_ : NuITP-EqConj NuITP-EqConj -> NuITP-EqConj [ ditto ] .
    eq true /\ CED = CED .
    eq false /\ CED = false .
    eq CED /\ CED = CED .
    eq CED /\ not(CED) = false .

    eq CED \/ (CED' /\ CED'') = (CED \/ CED') /\ (CED \/ CED'') .

    op _->_ : NuITP-ConjEqDisj NuITP-ConjEqDisj -> NuITP-Clause .
    op _->_ : NuITP-EqConj NuITP-EqDisj -> NuITP-Clause .
    eq CED -> CED = true .
    eq CED -> true = true .
    eq true -> false = false .
    eq false -> CED = true .
    eq (EC -> EC) = true .
    eq ((EC /\ EC') -> EC) = true .
    eq ((EC /\ EC') -> EC /\ EC'') = ((EC /\ EC') -> EC'') .

    eq (E /\ EC) -> ((E \/ ED) /\ CED) = ((E /\ EC) -> CED) [ owise ] .
    eq (((E \/ ED) /\ EC) -> CED) = ((E /\ EC) -> CED) /\ ((ED /\ EC) -> CED) [ owise ] .
    eq EC -> ((E /\ EC) \/ ED) /\ CED = EC -> (E \/ ED) /\ (EC /\ ED) /\ EC [ owise ] .
    eq EC -> ED /\ (ED \/ ED') /\ CED = EC -> ED /\ CED [ owise ] .
    eq ED /\ (ED \/ ED') = ED [ owise ] .

    op not_ : NuITP-Clause -> NuITP-Bool .
    op not_ : NuITP-ConjEqDisj -> NuITP-Bool .
    eq not(true) = false .
    eq not(false) = true .
    eq not(not(CED)) = CED .
    eq not(not(CLA)) = CLA .
endfm

fmod NuITP-DNF is
    pr NuITP-CLAUSE .

    vars CED CED' CED'' : NuITP-ConjEqDisj .

    eq CED -> CED' = not(CED) \/ CED' .
    eq not(CED /\ CED') = not(CED) \/ not(CED') .
    eq not(CED \/ CED') = not(CED) /\ not(CED') .
    eq CED /\ (CED' \/ CED'') = (CED /\ CED') \/ (CED /\ CED'') .
endfm

fmod NuITP-CNF is
    pr NuITP-CLAUSE .

    vars CED CED' CED'' : NuITP-ConjEqDisj .

    eq not(CED /\ CED') = not(CED) \/ not(CED') .
    eq not(CED \/ CED') = not(CED) /\ not(CED') .
    eq CED \/ (CED' /\ CED'') = (CED \/ CED') /\ (CED \/ CED'') .
endfm

set include BOOL on .

fmod NuITP-BASIC is
    pr META-LEVEL .
    pr CONVERSION .
    pr LEXICAL .
    pr STRING-OPS .

    ops RED GREEN BLUE YELLOW CYAN WHITE BW : -> String .
    eq RED = "\033[1;31m" .
    eq GREEN = "\033[1;32m" .
    eq BLUE = "\033[1;34m" .
    eq YELLOW = "\033[1;33m" .
    eq CYAN = "\033[1;36m" .
    eq WHITE = "\033[1;37m" .
    eq BW = "\033[0m" .

    op NuITP-VERSION : -> String .
    eq NuITP-VERSION = "alpha 33" .

    op NuITP-BUILT : -> String .
    eq NuITP-BUILT = "Jun 12th 2025" .

    op NuITP-UPV : -> String .
    eq NuITP-UPV = "" .
    
    op NuITP-BANNER : -> String .
    eq NuITP-BANNER = WHITE + "\n" +
        "\n    ===================================" + 
        "\n                   " + RED + "Nu" + WHITE + "ITP" +
        "\n          Inductive Theorem Prover" + 
        "\n       for Maude Equational Theories" + BW +
        "\n       (" + NuITP-VERSION + " built " + NuITP-BUILT + ")" + WHITE +
        "\n    ===================================" + WHITE +
        "\n            Copyright 2021-2025" +
        "\n    Universitat Politècnica de València" +
        "\n    ===================================" +
        "\n\n\n" + BW .

    sorts NeTermSet TermSet .
    subsort Term < NeTermSet < TermSet .

    op mt : -> TermSet [ ctor ] .
    op _;;_ : TermSet TermSet -> TermSet [ assoc comm id: mt ] .
    op _;;_ : NeTermSet TermSet -> NeTermSet [ assoc comm id: mt ] .
    eq T:Term ;; T:Term = T:Term .

    sorts NeSubstitutionSet SubstitutionSet .
    subsort Substitution < NeSubstitutionSet < SubstitutionSet .

    op mt : -> SubstitutionSet [ ctor ] .
    op _|_ : SubstitutionSet SubstitutionSet -> SubstitutionSet [ assoc comm id: mt ] .
    op _|_ : SubstitutionSet NeSubstitutionSet -> NeSubstitutionSet [ assoc comm id: mt ] .
    op _|_ : NeSubstitutionSet NeSubstitutionSet -> NeSubstitutionSet [ assoc comm id: mt ] .
    eq SB:Substitution | SB:Substitution = SB:Substitution .
endfm

fmod NuITP-GOAL is
    pr NuITP-BASIC .

    sorts Goal GoalSet State ProofState .
    subsort Bool < Goal < GoalSet .

    ops sat unsat open : -> ProofState [ ctor ] .
    
    op {_,_,_,_,_,_,_,_,_} : QidList Qid Bool Bool Bool Nat TermSet TermSet Term -> Goal [ ctor ] .
    op mt : -> GoalSet [ ctor ] .
    op __ : GoalSet GoalSet -> GoalSet [ assoc comm id: mt ] .
    eq G:Goal G:Goal = G:Goal .

    var M : Module .
    vars GID GID' QL : QidList .
    vars RID RID' Q : Qid .
    vars FRO SFRO SFRO' INTER INTER' : Bool .
    vars SKO HPS : TermSet .
    var CLA : Term .
    vars GS GS1 GS2 : GoalSet .
    vars VC N : Nat .
    var GOAL : Goal .

    op join : QidList -> String .
    eq join(nil) = "" .
    eq join(Q QL) = string(Q) + join(QL) .

    op size : GoalSet -> Nat .
    eq size((mt).GoalSet) = 0 .
    eq size(GOAL GS) = 1 + size(GS) .

    op getProofState : GoalSet -> [ProofState] .
    eq getProofState(mt) = sat .
    eq getProofState({ GID, RID, INTER, false, SFRO, VC, SKO, HPS, CLA } GS) = if (CLA == 'false.NuITP-Bool) then unsat else getProofState(GS) fi .
    eq getProofState({ GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS) = open [ owise ] .
    
    --- Proved and disproved goals are automatically removed from the frontier
    eq { GID, RID, INTER, true, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } = { GID, RID, INTER, false, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } .
    eq { GID, RID, INTER, true, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } = { GID, RID, INTER, false, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } .
    eq { GID, RID, INTER, true, SFRO, VC, SKO, HPS ;; 'false.NuITP-Bool, 'false.NuITP-Bool } = { GID, RID, INTER, false, SFRO, VC, SKO, 'false.NuITP-Bool, 'false.NuITP-Bool } .

    op getGID : Goal -> QidList .
    eq getGID({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = GID .

    op getRID : Goal -> QidList .
    eq getRID({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = RID .

    op isFrontier : Goal -> Bool .
    eq isFrontier({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = FRO .

    op getSKO : Goal -> TermSet .
    eq getSKO({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = SKO .

    op getHPS : Goal -> TermSet .
    eq getHPS({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = HPS .

    op getCLA : Goal -> Term .
    eq getCLA({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = CLA .

    op getGoal : GoalSet QidList -> GoalSet .
    eq getGoal({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } .
    eq getGoal(GS, GID) = mt [ owise ] .

    op getFreeClauses : GoalSet -> TermSet .
    eq getFreeClauses({ GID, RID, INTER, FRO, SFRO, VC, mt, HPS, CLA } GS) =
        if ((CLA =/= 'true.NuITP-Bool) and-then (CLA =/= 'false.NuITP-Bool))
        then (CLA ;; getFreeClauses(GS))
        else getFreeClauses(GS)
        fi .
    eq getFreeClauses(GS) = mt [ owise ] .

    op getProved : GoalSet -> GoalSet .
    eq getProved({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } GS) = { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } getProved(GS) .
    eq getProved(GS) = mt [ owise ] .

    op getDisproved : GoalSet -> GoalSet .
    eq getDisproved({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } GS) = { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } getDisproved(GS) .
    eq getDisproved(GS) = mt [ owise ] .

    op getFrontier : GoalSet -> GoalSet .
    eq getFrontier({ GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS) = { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } getFrontier(GS) .
    eq getFrontier(GS) = mt [ owise ] .

    op getClosed : GoalSet -> GoalSet .
    eq getClosed({ GID, RID, INTER, false, SFRO, VC, SKO, HPS, CLA } GS) = { GID, RID, INTER, false, SFRO, VC, SKO, HPS, CLA } getClosed(GS) .
    eq getClosed(GS) = mt [ owise ] .

    op areProven : GoalSet -> Bool .
    eq areProven({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } GS) = false .
    eq areProven({ GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS) = false .
    eq areProven(GS) = true [ owise ] .
    
    op isProved : Goal -> Bool .
    eq isProved({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = (CLA == 'true.NuITP-Bool) .

    op isDisproved : Goal -> Bool .
    eq isDisproved({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = (CLA == 'false.NuITP-Bool) .

    op getChildren : GoalSet QidList -> GoalSet .
    eq getChildren({ GID Q QL, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID Q QL, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } getChildren(GS, GID) .
    eq getChildren(GS, GID) = mt [ owise ] .

    op getFrontierChildren : GoalSet QidList -> GoalSet .
    eq getFrontierChildren({ GID Q QL, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID Q QL, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } getFrontierChildren(GS, GID) .
    eq getFrontierChildren(GS, GID) = mt [ owise ] .

    op getClosedChildren : GoalSet QidList -> GoalSet .
    eq getClosedChildren({ GID Q QL, RID, INTER, false, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID Q QL, RID, INTER, false, SFRO, VC, SKO, HPS, CLA } getClosedChildren(GS, GID) .
    eq getClosedChildren(GS, GID) = mt [ owise ] .

    op removeGoals : GoalSet GoalSet -> GoalSet .
    eq removeGoals({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS1, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS2) = removeGoals(GS1, GS2) .
    eq removeGoals(GS1, GS2) = GS2 [ owise ] .

    op closeGoal : GoalSet QidList -> GoalSet .
    eq closeGoal({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID, RID, INTER, false, false, VC, SKO, HPS, CLA } GS .

    op undoGoal : GoalSet QidList -> GoalSet .
    eq undoGoal(mt, GID) = mt .
    eq undoGoal({ GID, RID, INTER, false, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } GS, GID) = { GID, RID, INTER, false, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } GS .
    eq undoGoal({ GID, RID, INTER, false, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } GS, GID) = { GID, RID, INTER, false, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } GS .
    eq undoGoal({ GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS .
    eq undoGoal({ GID, RID, INTER, false, SFRO, VC, SKO, HPS, CLA } GS, GID) = { GID, RID, INTER, true, true, VC, SKO, HPS, CLA } undoGoal'(GS, GID) [ owise ] .

    op undoGoal' : GoalSet QidList -> GoalSet .
    eq undoGoal'({ GID Q QL, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, GID) = undoGoal'(GS, GID) .
    eq undoGoal'(GS, GID) = GS [ owise ] .

    op indexGoals : GoalSet QidList Nat -> GoalSet .
    eq indexGoals(mt, GID, N) = mt .
    eq indexGoals({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, GID', N) = { GID' tokenize(". " + string(N,10)), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } indexGoals(GS, GID', N + 1) .
endfm

fmod NuITP-LOG is
    pr NuITP-BASIC .

    sorts Line Log .
    subsort Line < Log .

    op [_:_] : QidList String -> Line [ ctor ] .

    op nil : -> Log [ ctor ] .
    op __ : Log Log -> Log [ ctor assoc id: nil ] .

    var GID : QidList .
    var STR : String .
    var B : Bool .
    vars LOG LOG1 LOG2 : Log .
    vars T1 T2 T3 T4 T5 : Term .

    op getLogLine : Log QidList -> Log .
    eq getLogLine(LOG1 [ GID : STR ] LOG2, GID) = [ GID : STR ] .
    eq getLogLine(LOG, GID) = nil [ owise ] .

    op toString : Log Bool -> String .
    eq toString(nil, B) = "" .
    eq toString([ GID : STR] LOG, true) = "  " + STR + toString(LOG, true) .
    eq toString([ GID : STR] LOG, false) = STR + toString(LOG, false) .

    op toStringMin : Log -> String .
    eq toStringMin(LOG) = toString(cleanLog(LOG, nil), false) .

    op cleanLog : Log Log -> Log .
    eq cleanLog(LOG1, LOG2) = LOG1 .
endfm

fmod NuITP-GENSET is
    pr NuITP-BASIC .
    
    sorts GenSet GenSetList .
    subsort GenSet < GenSetList .

    op [_:_] : String TermSet -> GenSet [ ctor ] .
    op [_::_] : Type TermSet -> GenSet [ ctor ] .

    op nil : -> GenSetList [ ctor ] .
    op __ : GenSetList GenSetList -> GenSetList [ ctor assoc id: nil ] .

    sorts GenSetCollection GenSetCollectionSet .
    subsort GenSetCollection < GenSetCollectionSet .

    op [_|_|_] : Type String GenSetList -> GenSetCollection [ ctor ] .

    op mt : -> GenSetCollectionSet [ ctor ] .
    op __ : GenSetCollectionSet GenSetCollectionSet -> GenSetCollectionSet [ assoc comm id: mt ] .
    eq GC:GenSetCollection GC:GenSetCollection = GC:GenSetCollection .

    vars STR STR' DEF : String .
    vars TY TY' : Type .
    var TS : TermSet .
    vars NTS NTS' : NeTermSet .
    vars GSL GSL1 GSL2 : GenSetList .
    var GCS : GenSetCollectionSet .
    var V : Variable .
    var NTL : NeTermList .
    var TL : TermList .

    op getAllGenSets : GenSetCollectionSet TermList -> GenSetList .
    eq getAllGenSets(GCS, empty) = nil .
    eq getAllGenSets(GCS, V) = [ getType(V) :: getDefaultGenSet(GCS, getType(V)) ] .
    eq getAllGenSets(GCS, (V,NTL)) = [ getType(V) :: getDefaultGenSet(GCS, getType(V)) ] getAllGenSets(GCS, NTL) .

    op getGenSets : GenSetCollectionSet Type -> GenSetCollectionSet .
    eq getGenSets([ TY | DEF | GSL ] GCS, TY) = [ TY | DEF | GSL ] .
    eq getGenSets(GCS, TY) = mt [ owise ] .

    op getDefaultGenSet : GenSetCollectionSet Type -> TermSet .
    eq getDefaultGenSet([ TY | DEF | GSL1 [ DEF : NTS ] GSL2 ] GCS, TY) = NTS .
    eq getDefaultGenSet(GCS, TY) = mt [ owise ] .

    op getGenSet : GenSetCollectionSet Type String -> [TermSet] .
    eq getGenSet([ TY | DEF | GSL1 [ STR : NTS ] GSL2 ] GCS, TY, STR) = NTS .

    op getGenSet : GenSetCollectionSet String -> GenSetCollectionSet .
    eq getGenSet([ TY | DEF | GSL1 [ STR : NTS ] GSL2 ] GCS, STR) = [ TY | DEF | [ STR : NTS ] ] .
    eq getGenSet(GCS, STR) = mt [ owise ] .

    op addGenSet : GenSetCollectionSet String Type NeTermSet -> GenSetCollectionSet .
    eq addGenSet([ TY | DEF | nil ] GCS, STR, TY, NTS) = [ TY | STR | [ STR : NTS ] ] GCS .
    eq addGenSet([ TY | DEF | GSL1 [ STR' : NTS' ] GSL2 ] GCS, STR, TY, NTS) = addGenSet'([ TY | DEF | GSL1 [ STR' : NTS' ] GSL2 ] GCS, STR, TY, NTS) .
    eq addGenSet(GCS, STR, TY, NTS) = [ TY | STR | [ STR : NTS ] ] GCS [ owise ] .

    op addGenSet' : GenSetCollectionSet String Type NeTermSet -> GenSetCollectionSet .
    eq addGenSet'([ TY | DEF | GSL1 [ STR : NTS' ] GSL2 ] GCS, STR, TY, NTS) = [ TY | DEF | GSL1 [ STR : NTS ] GSL2 ] GCS .
    eq addGenSet'([ TY | DEF | GSL ] GCS, STR, TY, NTS) = [ TY | DEF | GSL [ STR : NTS ] ] GCS [ owise ] .

    op setDefault : GenSetCollectionSet String -> GenSetCollectionSet .
    eq setDefault([ TY | DEF | GSL1 [ STR : TS ] GSL2 ] GCS, STR) = [ TY | STR | GSL1 [ STR : TS ] GSL2 ] GCS .

    op checkGenSetId : GenSetCollectionSet Type String -> Bool .
    ceq checkGenSetId([ TY | DEF | GSL1 [ STR : NTS ] GSL2 ] GCS, TY', STR) = false
        if (TY =/= TY') .
    eq checkGenSetId(GCS, TY, STR) = true [ owise ] .

    op hasGeneratorSet? : TermSet GenSetCollectionSet -> Bool .
    eq hasGeneratorSet?(mt, GCS) = true .
    eq hasGeneratorSet?(V ;; TS, GCS) = (getDefaultGenSet(GCS, getType(V)) :: NeTermSet) and-then hasGeneratorSet?(TS, GCS) .

    op hasGeneratorSet? : TermList GenSetCollectionSet -> Bool .
    eq hasGeneratorSet?(empty, GCS) = true .
    eq hasGeneratorSet?((V,TL), GCS) = (getDefaultGenSet(GCS, getType(V)) :: NeTermSet) and-then hasGeneratorSet?(TL, GCS) .
endfm

fmod NuITP-UTILS is
    pr NuITP-LOG .
    pr NuITP-GOAL .
    pr NuITP-GENSET .

    var M : Module .
    vars Q Q' F : Qid .
    var H : Header .
    var IL : ImportList .
    vars SS SS' : SortSet .
    vars SSDS SSDS' : SubsortDeclSet .
    vars OPDS OPDS' : OpDeclSet .
    var MAS : MembAxSet .
    vars EQS EQS' : EquationSet .
    vars RLS RLS' : RuleSet .
    var STDS : StratDeclSet .
    var STDFS : StratDefSet .

    var QL : QidList .
    vars STR STR1 STR2 DEF : String .
    var TY : Type .
    var TYL : TypeList .
    var K : Kind .
    var N : Nat .
    var EQ : Equation .
    var RL : Rule .
    var AT : Attr .
    var ATS : AttrSet .
    var C : Constant .
    var V : Variable .
    vars T T' T1 T2 T3 T4 LHS RHS GAMMA LAMBDA : Term .
    vars SB SB' : Substitution .
    var SBS : SubstitutionSet .
    vars NTL NTL' : NeTermList .
    vars COND COND' : Condition .
    var GT : GroundTerm .
    var S : Sort .
    vars TL TL' TL'' : TermList .
    vars TS TS' SKO : TermSet .
    var NTS : NeTermSet .
    var COL : NeCTermList .
    var CO : Context .
    var NTYL : NeTypeList .
    vars GSL GSL1 GSL2 : GenSetList .
    var GCS : GenSetCollectionSet .
    var GTL : GroundTermList .
    
    sort TermListPair .
    op {_::_} : TermList TermList -> TermListPair [ ctor ] .

    sort TermSetPair .
    op {_:::_} : TermSet TermSet -> TermSetPair [ ctor ] .

    op _|_|_|_ : Module GenSetCollectionSet TermSet GoalSet -> State [ ctor ] .

    op {_,_,_} :  SortSet SubsortDeclSet OpDeclSet -> ResultTriple [ ctor ] .
    op getSorts : ResultTriple -> SortSet .
    eq getSorts({ SS , SSDS , OPDS }) = SS .
    op getSubsorts : ResultTriple -> SubsortDeclSet .
    eq getSubsorts({ SS , SSDS , OPDS }) = SSDS .
    op getOps : ResultTriple -> OpDeclSet .
    eq getOps({ SS , SSDS , OPDS }) = OPDS .

    op getGID : Term -> QidList .
    eq getGID(T) = split(printTokens(downTerm(T, (nil).QidList))) .

    op split : String -> QidList .
    eq split("") = nil .
    eq split(STR) =
        if (find(STR, ".", 0) == notFound)
        then tokenize(STR)
        else tokenize(substr(STR, 0, find(STR, ".", 0))) '. split(substr(STR, find(STR, ".", 0) + 1, length(STR)))
        fi [ owise ] .

    op getFileName : String String -> String .
    eq getFileName(STR1, "") = STR1 .
    eq getFileName(STR1, STR2) =
        if (length(STR1) > length(STR2)) and-then (substr(STR1, sd(length(STR1), s(length(STR2))), s(length(STR2))) == "." + STR2)
        then STR1
        else STR1 + "." + STR2
        fi .

    op getEquation : Module Qid -> EquationSet .
    eq getEquation(M, F) = getEquation(getEqs(M), F) .

    op getEquation : EquationSet Qid -> EquationSet .
    eq getEquation(EQS (eq LHS = RHS [ ATS label(Q) ] .), Q) = (eq LHS = RHS [ ATS label(Q) ] .) .
    eq getEquation(EQS (ceq LHS = RHS if COND [ ATS label(Q) ] .), Q) = (ceq LHS = RHS if COND [ ATS label(Q) ] .) .
    eq getEquation(EQS, Q) = none [ owise ] .
    
    op getRule : Module Qid -> RuleSet .
    eq getRule(M, F) = getRule(getRls(M), F) .

    op getRule : RuleSet Qid -> RuleSet .
    eq getRule((rl LHS => RHS [ label(F) ATS ] .) RLS, F) =
        if (getRule(RLS, F) == none)
        then (rl LHS => RHS [ label(F) ATS ] .)
        else getRule(RLS, F)
        fi .
    eq getRule((crl LHS => RHS if COND [ label(F) ATS ] .) RLS, F) = (crl LHS => RHS if COND [ label(F) ATS ] .) .
    eq getRule(RLS, F) = none [ owise ] .

    op removeNonExec : EquationSet -> EquationSet .
    eq removeNonExec(EQS (eq LHS = RHS [ ATS nonexec ] .)) = removeNonExec(EQS) .
    eq removeNonExec(EQS (ceq LHS = RHS if COND [ ATS nonexec ] .)) = removeNonExec(EQS) .
    eq removeNonExec(EQS) = EQS [ owise ] .

    op removeNonExec : RuleSet -> RuleSet .
    eq removeNonExec(RLS (rl LHS => RHS [ ATS nonexec ] .)) = removeNonExec(RLS) .
    eq removeNonExec(RLS (crl LHS => RHS if COND [ ATS nonexec ] .)) = removeNonExec(RLS) .
    eq removeNonExec(RLS) = RLS [ owise ] .

    op extModule : Qid -> Module .
    eq extModule(Q) = extModule(upModule(Q, true)) .

    op extModule : Module -> Module .
    eq extModule(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = fmod H is IL (protecting 'NuITP-CLAUSE .) sorts SS . SSDS OPDS MAS EQS endfm .
    eq extModule(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = fmod H is IL (protecting 'NuITP-CLAUSE .) sorts SS . SSDS OPDS MAS EQS endfm .
    eq extModule(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm) = fmod H is IL (protecting 'NuITP-CLAUSE .) sorts SS . SSDS OPDS MAS EQS endfm .
    eq extModule(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) = fmod Q is IL (protecting 'NuITP-CLAUSE .) sorts SS . SSDS OPDS MAS EQS endfm .
    eq extModule(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) = fmod Q is IL (protecting 'NuITP-CLAUSE .) sorts SS . SSDS OPDS MAS EQS endfm .
    eq extModule(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth) = fmod H is IL (protecting 'NuITP-CLAUSE .) sorts SS . SSDS OPDS MAS EQS endfm .
    
    op redModule : Module TermSet -> Module .
    eq redModule(M, SKO) = addOps(setEqs(M, none), SKO) .

    op addImport : Module Qid -> Module .
    eq addImport(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, Q') = fmod H is IL (protecting Q' .) sorts SS . SSDS OPDS MAS EQS endfm .
    eq addImport(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, Q') = mod H is IL (protecting Q' .) sorts SS . SSDS OPDS MAS EQS RLS endm .
    eq addImport(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, Q') = smod H is IL (protecting Q' .) sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm .
    eq addImport(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, Q') = fth Q is IL (protecting Q' .) sorts SS . SSDS OPDS MAS EQS endfth .
    eq addImport(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, Q') = th Q is IL (protecting Q' .) sorts SS . SSDS OPDS MAS EQS RLS endth .
    eq addImport(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, Q') = sth H is IL (protecting Q' .) sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth .
    eq addImport(M, Q') = M [ owise ] .

    op addSorts : Module SortSet -> Module .
    eq addSorts(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, SS') = fmod H is IL sorts SS ; SS' . SSDS OPDS MAS EQS endfm .
    eq addSorts(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, SS') = mod H is IL sorts SS ; SS' . SSDS OPDS MAS EQS RLS endm .
    eq addSorts(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, SS') = smod H is IL sorts SS ; SS' . SSDS OPDS MAS EQS RLS STDS STDFS endsm .
    eq addSorts(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, SS') = fth Q is IL sorts SS ; SS' . SSDS OPDS MAS EQS endfth .
    eq addSorts(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, SS') = th Q is IL sorts SS ; SS' . SSDS OPDS MAS EQS RLS endth .
    eq addSorts(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, SS') = sth H is IL sorts SS ; SS' . SSDS OPDS MAS EQS RLS STDS STDFS endsth .
    eq addSorts(M, SS) = M [ owise ] .

    op addSubSorts : Module SubsortDeclSet -> Module .
    eq addSubSorts(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, SSDS') = fmod H is IL sorts SS . SSDS SSDS' OPDS MAS EQS endfm .
    eq addSubSorts(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, SSDS') = mod H is IL sorts SS . SSDS SSDS' OPDS MAS EQS RLS endm .
    eq addSubSorts(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, SSDS') = smod H is IL sorts SS . SSDS SSDS' OPDS MAS EQS RLS STDS STDFS endsm .
    eq addSubSorts(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, SSDS') = fth Q is IL sorts SS . SSDS SSDS' OPDS MAS EQS endfth .
    eq addSubSorts(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, SSDS') = th Q is IL sorts SS . SSDS SSDS' OPDS MAS EQS RLS endth .
    eq addSubSorts(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, SSDS') = sth H is IL sorts SS . SSDS SSDS' OPDS MAS EQS RLS STDS STDFS endsth .
    eq addSubSorts(M, SSDS) = M [ owise ] .

    op addOps : Module TermSet -> Module .
    eq addOps(M, TS) = addOps(M, toOps(TS)) .

    op addOps : Module OpDeclSet -> Module .
    eq addOps(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, OPDS') = fmod H is IL sorts SS . SSDS OPDS OPDS' MAS EQS endfm .
    eq addOps(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, OPDS') = mod H is IL sorts SS . SSDS OPDS OPDS' MAS EQS RLS endm .
    eq addOps(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, OPDS') = smod H is IL sorts SS . SSDS OPDS OPDS' MAS EQS RLS STDS STDFS endsm .
    eq addOps(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, OPDS') = fth Q is IL sorts SS . SSDS OPDS OPDS' MAS EQS endfth .
    eq addOps(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, OPDS') = th Q is IL sorts SS . SSDS OPDS OPDS' MAS EQS RLS endth .
    eq addOps(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, OPDS') = sth H is IL sorts SS . SSDS OPDS OPDS' MAS EQS RLS STDS STDFS endsth .
    eq addOps(M, OPDS) = M [ owise ] .

    op setOps : Module OpDeclSet -> Module .
    eq setOps(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, OPDS') = fmod H is IL sorts SS . SSDS OPDS' MAS EQS endfm .
    eq setOps(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, OPDS') = mod H is IL sorts SS . SSDS OPDS' MAS EQS RLS endm .
    eq setOps(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, OPDS') = smod H is IL sorts SS . SSDS OPDS' MAS EQS RLS STDS STDFS endsm .
    eq setOps(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, OPDS') = fth Q is IL sorts SS . SSDS OPDS' MAS EQS endfth .
    eq setOps(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, OPDS') = th Q is IL sorts SS . SSDS OPDS' MAS EQS RLS endth .
    eq setOps(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, OPDS') = sth H is IL sorts SS . SSDS OPDS' MAS EQS RLS STDS STDFS endsth .
    eq setOps(M, OPDS) = M [ owise ] .

    op addEqs : Module TermSet -> Module .
    eq addEqs(M, TS) = addEqs(M, toEqs(TS)) .

    op addEqs : Module EquationSet -> Module .
    eq addEqs(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, EQS') = fmod H is IL sorts SS . SSDS OPDS MAS EQS EQS' endfm .
    eq addEqs(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, EQS') = mod H is IL sorts SS . SSDS OPDS MAS EQS EQS' RLS endm .
    eq addEqs(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, EQS') = smod H is IL sorts SS . SSDS OPDS MAS EQS EQS' RLS STDS STDFS endsm .
    eq addEqs(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, EQS') = fth Q is IL sorts SS . SSDS OPDS MAS EQS EQS' endfth .
    eq addEqs(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, EQS') = th Q is IL sorts SS . SSDS OPDS MAS EQS EQS' RLS endth .
    eq addEqs(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, EQS') = sth H is IL sorts SS . SSDS OPDS MAS EQS EQS' RLS STDS STDFS endsth .
    eq addEqs(M, EQS) = M [ owise ] .

    op setEqs : Module EquationSet -> Module .
    eq setEqs(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, EQS') = fmod H is IL sorts SS . SSDS OPDS MAS EQS' endfm .
    eq setEqs(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, EQS') = mod H is IL sorts SS . SSDS OPDS MAS EQS' RLS endm .
    eq setEqs(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, EQS') = smod H is IL sorts SS . SSDS OPDS MAS EQS' RLS STDS STDFS endsm .
    eq setEqs(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, EQS') = fth Q is IL sorts SS . SSDS OPDS MAS EQS' endfth .
    eq setEqs(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, EQS') = th Q is IL sorts SS . SSDS OPDS MAS EQS' RLS endth .
    eq setEqs(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, EQS') = sth H is IL sorts SS . SSDS OPDS MAS EQS' RLS STDS STDFS endsth .
    eq setEqs(M, EQS) = M [ owise ] .

    op addRls : Module TermSet -> Module .
    eq addRls(M, TS) = addRls(M, toRls(TS)) .

    op addRls : Module RuleSet -> Module .
    eq addRls(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, RLS) = mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm .
    eq addRls(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, RLS') = mod H is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' endm .
    eq addRls(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, RLS') = smod H is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' STDS STDFS endsm .
    eq addRls(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, RLS) = th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth .
    eq addRls(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, RLS') = th Q is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' endth .
    eq addRls(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, RLS') = sth H is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' STDS STDFS endsth .
    eq addRls(M, RLS) = M [ owise ] .

    op setRls : Module RuleSet -> Module .
    eq setRls(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, RLS) = mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm .
    eq setRls(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, RLS') = mod H is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' endm .
    eq setRls(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, RLS') = smod H is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' STDS STDFS endsm .
    eq setRls(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, RLS) = th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth .
    eq setRls(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, RLS') = th Q is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' endth .
    eq setRls(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, RLS') = sth H is IL sorts SS . SSDS OPDS MAS EQS RLS RLS' STDS STDFS endsth .
    eq setRls(M, RLS) = M [ owise ] .

    op toOps : TermList -> OpDeclSet .
    op toOps : TermSet -> OpDeclSet .
    eq toOps(empty) = none .
    eq toOps(mt) = none .
    eq toOps(C) = (op getName(C) : nil -> getType(C) [ metadata("skolem") ] .) .
    eq toOps((C, NTL)) = (op getName(C) : nil -> getType(C) [ metadata("skolem") ] .) toOps(NTL) .
    eq toOps((C ;; NTS)) = (op getName(C) : nil -> getType(C) [ metadata("skolem") ] .) toOps(NTS) .

    op toCondition : NeTermList -> Condition .
    eq toCondition('true.NuITP-Bool) = nil .
    eq toCondition('_=_[LHS,RHS]) = (LHS = RHS) .
    eq toCondition('_=>_[LHS,RHS]) = (LHS = RHS) .
    eq toCondition('_/\_[T,NTL]) = toCondition(T) /\ toCondition(NTL) .
    eq toCondition((T,NTL)) = toCondition(T) /\ toCondition(NTL) .

    op toEqs : TermList -> EquationSet .
    op toEqs : TermSet -> EquationSet .
    eq toEqs(TL) = toEqs(TL, "") .
    eq toEqs(TS) = toEqs(TS, "") .

    op toEqs : TermList String -> EquationSet .
    op toEqs : TermSet String -> EquationSet .
    eq toEqs(empty, STR) = none .
    eq toEqs(mt, STR) = none .
    eq toEqs('_/\_[NTL], STR) = toEqs(NTL, STR) .
    eq toEqs('_\/_[NTL], STR) = toEqs(NTL, STR) .
    eq toEqs('_->_[GAMMA, '_=_[LHS, RHS]], STR) =
        if (LHS == RHS)
        then none
        else
            if (GAMMA == 'true.NuITP-Bool)
            then (eq LHS = RHS [ if (STR == "") then none else metadata(STR) fi ] .)
            else (ceq LHS = RHS if toCondition(GAMMA) [ if (STR == "") then none else metadata(STR) fi ] .)
            fi
        fi .
    eq toEqs('_->_[GAMMA, '_=>_[LHS, RHS]], STR) =
        if (LHS == RHS)
        then none
        else
            if (GAMMA == 'true.NuITP-Bool)
            then (eq LHS = RHS [ if (STR == "") then none else metadata(STR) fi ] .)
            else (ceq LHS = RHS if toCondition(GAMMA) [ if (STR == "") then none else metadata(STR) fi ] .)
            fi
        fi .
    eq toEqs('_=_[LHS, RHS], STR) =
        if (LHS == RHS)
        then none
        else (eq LHS = RHS [ if (STR == "") then none else metadata(STR) fi ] .)
        fi .
    eq toEqs('_=>_[LHS, RHS], STR) =
        if (LHS == RHS)
        then none
        else (eq LHS = RHS [ if (STR == "") then none else metadata(STR) fi ] .)
        fi .
    eq toEqs(T, STR) = none [ owise ] .
    eq toEqs((T, NTL), STR) = toEqs(T, STR) toEqs(NTL, STR) .
    eq toEqs((T ;; NTS), STR) = toEqs(T, STR) toEqs(NTS, STR) .

    op toRls : EquationSet -> RuleSet .
    eq toRls((none).EquationSet) = none .
    eq toRls((eq LHS = RHS [ variant ATS ] .) EQS) = (rl LHS => RHS [ narrowing ATS ] .) toRls(EQS) .
    eq toRls((eq LHS = RHS [ owise ATS ] .) EQS) = (rl LHS => RHS [ ATS ] .) toRls(EQS) .
    eq toRls((eq LHS = RHS [ ATS ] .) EQS) = (rl LHS => RHS [ narrowing ATS ] .) toRls(EQS) [ owise ] .
    eq toRls((ceq LHS = RHS if COND [ ATS ] .) EQS) = (crl LHS => RHS if COND [ ATS ] .) toRls(EQS) .

    op toRls : EquationSet Term Nat -> RuleSet .
    eq toRls((none).EquationSet, T, N) = none .
    eq toRls((eq LHS = RHS [ owise ATS ] .) EQS, T, N) = (rl LHS => RHS [ label(qid("NuITP-RL#" + string(N,10)))] .) toRls(EQS, T, N + 1) .
    eq toRls((eq F[NTL] = RHS [ variant ATS ] .) EQS, F[NTL'], N) = (rl F[NTL] => RHS [ narrowing label(qid("NuITP-RL#" + string(N,10))) ] .) toRls(EQS, F[NTL'], N + 1) .
    eq toRls((eq F[NTL] = RHS [ ATS ] .) EQS, F[NTL'], N) = (rl F[NTL] => RHS [ narrowing label(qid("NuITP-RL#" + string(N,10))) ] .) toRls(EQS, F[NTL'], N + 1) [ owise ] .
    eq toRls((ceq F[NTL] = RHS if COND [ ATS ] .) EQS, F[NTL'], N) = (rl F[NTL] => RHS [ narrowing ATS label(qid("NuITP-RL#" + string(N,10)))] .) (crl F[NTL] => RHS if COND [ ATS label(qid("NuITP-RL#" + string(N,10)))] .) toRls(EQS, F[NTL'], N + 1) .
    eq toRls(EQS, T, N) = none [ owise ] .

    op toClauses : Module -> TermSet .
    eq toClauses(M) = toClauses(getEqs(M)) .
    
    op toClauses : EquationSet -> TermSet .
    eq toClauses(none) = mt .
    eq toClauses((eq LHS = RHS [ ATS ] .) EQS) = ('_->_['true.NuITP-Bool,'_=_[LHS,RHS]]) ;; toClauses(EQS) .
    eq toClauses((ceq LHS = RHS if COND [ ATS ] .) EQS) = ('_->_[toClauses(COND),'_=_[LHS,RHS]]) ;; toClauses(EQS) .

    op toOrientedClauses : EquationSet -> TermSet .
    eq toOrientedClauses(none) = mt .
    eq toOrientedClauses((eq LHS = RHS [ ATS ] .) EQS) = ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]]) ;; toOrientedClauses(EQS) .
    eq toOrientedClauses((ceq LHS = RHS if COND [ ATS ] .) EQS) = ('_->_[toClauses(COND),'_=>_[LHS,RHS]]) ;; toOrientedClauses(EQS) .

    op toClauses : Condition -> Term .
    eq toClauses(nil) = 'true.NuITP-Bool .
    eq toClauses(COND) = toClauses(COND, empty) [ owise ] .

    op toClauses : Condition TermList -> Term .
    eq toClauses(nil, TL) = wrapAnd(TL) .
    eq toClauses((T = T') /\ COND, TL) = toClauses(COND, (TL,'_=_[T,T'])) .
    eq toClauses(COND /\ COND', TL) = toClauses(COND', TL) [ owise ] .

    op disorient : TermSet -> TermSet .
    op disorient : TermList -> TermList .
    op disorient : Term -> Term .
    eq disorient(mt) = mt .
    eq disorient(empty) = empty .
    eq disorient('_=_[NTL]) = '_=_[NTL] .
    eq disorient('_/\_[NTL]) = '_/\_[disorient(NTL)] .
    eq disorient('_\/_[NTL]) = '_\/_[disorient(NTL)] .
    eq disorient('_=>_[NTL]) = '_=_[NTL] .
    eq disorient('_->_[LHS,RHS]) = '_->_[LHS,disorient(RHS)] .
    eq disorient(T ;; NTS) = disorient(T) ;; disorient(NTS) .
    eq disorient((T,NTL)) = disorient(T) , disorient(NTL) .
    eq disorient(T) = T [ owise ] .

    op toRls : TermList -> RuleSet .
    op toRls : TermSet -> RuleSet .
    eq toRls(empty) = none .
    eq toRls(mt) = none .
    eq toRls('_->_[GAMMA, '_=>_[LHS, RHS]]) =
        if (GAMMA == 'true.NuITP-Bool)
        then (rl LHS => RHS [ narrowing ] .)
        else
            if getVars(GAMMA) in getVars(LHS)
            then (crl LHS => RHS if toCondition(GAMMA) [ none ] .)
            else none
            fi
        fi .
    eq toRls('_->_[GAMMA, '_=_[LHS, RHS]]) = toRls('_->_[GAMMA, '_=_[LHS, RHS]], (getVars(RHS) in getVars(LHS)), (getVars(LHS) in getVars(RHS))) .
    eq toRls('_->_[GAMMA, '_\/_[NTL]]) = if getVars(GAMMA) in getVars(NTL) then (crl disorient('_\/_[NTL]) => 'true.NuITP-Bool if GAMMA => 'true.NuITP-Bool [ none ] .) else none fi .
    eq toRls(T) = none [ owise ] .
    eq toRls((T, NTL)) = toRls(T) toRls(NTL) .
    eq toRls((T ;; NTS)) = toRls(T) toRls(NTS) .

    op toRls : Term Bool Bool -> RuleSet .
    eq toRls('_->_['true.NuITP-Bool, '_=_[LHS, RHS]], true, true) = (crl LHS => RHS if '_>=E_['`[`[_`]`][LHS],'`[`[_`]`][RHS]] = 'true.OBool [ metadata("ordered") ] .) (crl RHS => LHS if '_>=E_['`[`[_`]`][RHS],'`[`[_`]`][LHS]] = 'true.OBool [ metadata("ordered") ] .) .
    eq toRls('_->_['true.NuITP-Bool, '_=_[LHS, RHS]], true, false) = (crl LHS => RHS if '_>=E_['`[`[_`]`][LHS],'`[`[_`]`][RHS]] = 'true.OBool [ metadata("ordered") ] .) .
    eq toRls('_->_['true.NuITP-Bool, '_=_[LHS, RHS]], false, true) = (crl RHS => LHS if '_>=E_['`[`[_`]`][RHS],'`[`[_`]`][LHS]] = 'true.OBool [ metadata("ordered") ] .) .
    eq toRls('_->_[GAMMA, '_=_[LHS, RHS]], true, true) =
        if getVars(GAMMA) in getVars(LHS)
        then (crl LHS => RHS if '_>=E_['`[`[_`]`][LHS],'`[`[_`]`][RHS]] = 'true.OBool /\ toCondition(GAMMA) [ metadata("ordered") ] .)
        else none
        fi
        if getVars(GAMMA) in getVars(RHS)
        then (crl RHS => LHS if '_>=E_['`[`[_`]`][RHS],'`[`[_`]`][LHS]] = 'true.OBool /\ toCondition(GAMMA) [ metadata("ordered") ] .)
        else none
        fi [ owise ] .
    eq toRls('_->_[GAMMA, '_=_[LHS, RHS]], true, false) = if getVars(GAMMA) in getVars(LHS) then (crl LHS => RHS if '_>=E_['`[`[_`]`][LHS],'`[`[_`]`][RHS]] = 'true.OBool /\ toCondition(GAMMA) [ metadata("ordered") ] .) else none fi [ owise ] .
    eq toRls('_->_[GAMMA, '_=_[LHS, RHS]], false, true) = if getVars(GAMMA) in getVars(RHS) then (crl RHS => LHS if '_>=E_['`[`[_`]`][RHS],'`[`[_`]`][LHS]] = 'true.OBool /\ toCondition(GAMMA) [ metadata("ordered") ] .) else none fi [ owise ] .
    eq toRls(T, false, false) = none [ owise ] .

    --- For Equality Rule
    op toRls : Term Substitution -> RuleSet .
    eq toRls('_->_[GAMMA,'_=>_[LHS,RHS]], SB) = toRls(LHS, RHS, GAMMA, SB) .

    op toRls : Term Term Term Substitution -> RuleSet .
    eq toRls(LHS, RHS, 'true.NuITP-Bool, SB) = (rl applySub(LHS, SB) => applySub(RHS, SB) [ nonexec label('NuITP-EQRL) ] .) .
    eq toRls(LHS, RHS, GAMMA, SB) = (crl applySub(LHS, SB) => applySub(RHS, SB) if toCondition(applySub(GAMMA, SB)) [ nonexec label('NuITP-EQRL) ] .) [ owise ] .

    op wrapEQ : Rule Qid -> Rule .
    eq wrapEQ((rl LHS => RHS [ ATS ] .), F) = (rl LHS => F[RHS] [ ATS ] .) .
    eq wrapEQ((crl LHS => RHS if COND [ ATS ] .), F) = (crl LHS => F[RHS] if COND [ ATS ] .) .

    op unwrapEQ : TermList -> TermList .
    op unwrapEQ : Term -> Term .
    eq unwrapEQ(empty) = empty .
    eq unwrapEQ(C) = C .
    eq unwrapEQ(V) = V .
    eq unwrapEQ(F[NTL]) = if (F == 'NuITP-EQ) then unwrapEQ(NTL) else F[unwrapEQ(NTL)] fi .
    eq unwrapEQ((T,NTL)) = unwrapEQ(T) , unwrapEQ(NTL) .
    
    --- For Narrowing Simplification, Narrowing Induction and Split
    op addGamma : Term TermList -> Term .
    eq addGamma('_->_[GAMMA,LAMBDA], empty) = '_->_[GAMMA,LAMBDA] .
    eq addGamma('_->_[GAMMA,LAMBDA], 'true.NuITP-Bool) = '_->_[GAMMA,LAMBDA] .
    eq addGamma('_->_[GAMMA,LAMBDA], T) =
        if (GAMMA == 'true-NuITP-Bool)
        then '_->_[T,LAMBDA]
        else '_->_['_/\_[GAMMA,T],LAMBDA]
        fi [ owise ] .
    eq addGamma('_->_[GAMMA,LAMBDA], (T,NTL)) =
        if (GAMMA == 'true-NuITP-Bool)
        then '_->_['_/\_[T,NTL],LAMBDA]
        else '_->_['_/\_[GAMMA,T,NTL],LAMBDA]
        fi [ owise ] .

    op getCondition : RuleSet Qid -> Condition .
    eq getCondition((crl LHS => RHS if COND [ label(F) ATS ] .) RLS, F) = COND .
    eq getCondition(RLS, F) = nil [ owise ] .

    op getVars : Condition -> TermSet .
    op getVars : TermList -> TermSet .
    op getVars : TermSet -> TermSet .
    eq getVars((nil).Condition) = mt .
    eq getVars(empty) = mt .
    eq getVars(mt) = mt .
    eq getVars(C) = mt .
    eq getVars(V) = V .
    eq getVars(F[NTL]) = getVars(NTL) .
    eq getVars((T, NTL)) = getVars(T) ;; getVars(NTL) .
    eq getVars((T ;; NTS)) = getVars(T) ;; getVars(NTS) .
    eq getVars((T : S) /\ COND) = getVars(T) ;; getVars(COND) .
    eq getVars((T = T') /\ COND) = getVars(T) ;; getVars(T') ;; getVars(COND) .
    eq getVars((T => T') /\ COND) = getVars(T) ;; getVars(T') ;; getVars(COND) .
    eq getVars((T' := T) /\ COND) = getVars(T) ;; getVars(T') ;; getVars(COND) .

    op getRanVars : Substitution -> TermSet .
    eq getRanVars(none) = mt .
    eq getRanVars(V <- T ; SB) = getVars(T) ;; getRanVars(SB) .

    op cleanString : Type -> String .
    eq cleanString(TY) = removeEsc(string(TY)) .

    op cleanString : Kind -> String .
    eq cleanString(K) = removeEsc(string(K)) .

    op removeEsc : String -> String .
    eq removeEsc(STR) = STR [ owise ] .
    ceq removeEsc(STR) = removeEsc(substr(STR,0,rfind(STR, "`", length(STR) + 1)) + substr(STR,rfind(STR, "`", length(STR)) + 1,length(STR)))
        if rfind(STR, "`", length(STR) + 1) =/= notFound .

    op safeString : Qid -> String .
    eq safeString(Q) = safeString(string(Q)) .

    op safeString : String -> String .
   ceq safeString(STR) = safeString(substr(STR, 0, N) + "uscore-" + substr(STR, s(N), length(STR)))
     if N := find(STR, "_", 0) .
   ceq safeString(STR) = safeString(substr(STR, 0, N) + "comma-" + substr(STR, s(s(N)), length(STR)))
        if N := find(STR, "`,", 0) .
    eq safeString(STR) = STR [ owise ] .

    op renameVars : RuleSet String -> RuleSet .
    op renameVars : EquationSet String -> EquationSet .
    eq renameVars((none).EquationSet, STR) = none .
    eq renameVars((eq LHS = RHS [ ATS ] .) EQS, STR) = (eq applySub(LHS, renameVars'(getVars(LHS ;; RHS), STR, 0)) = applySub(RHS, renameVars'(getVars(LHS ;; RHS), STR, 0)) [ ATS ] .) renameVars(EQS, STR) .
    eq renameVars((ceq LHS = RHS if COND [ ATS ] .) EQS, STR) = 
        (
            ceq applySub(LHS, renameVars'(getVars(LHS ;; RHS) ;; getVars(COND), STR, 0)) = 
            applySub(RHS, renameVars'(getVars(LHS ;; RHS) ;; getVars(COND), STR, 0)) 
            if applySub2Cond(COND, renameVars'(getVars(LHS ;; RHS) ;; getVars(COND), STR, 0)) [ ATS ] .
        )
        renameVars(EQS, STR) .
    eq renameVars((none).RuleSet, STR) = none .
    eq renameVars((rl LHS => RHS [ ATS ] .) RLS, STR) = (rl applySub(LHS, renameVars'(getVars(LHS ;; RHS), STR, 0)) => applySub(RHS, renameVars'(getVars(LHS ;; RHS), STR, 0)) [ ATS ] .) renameVars(RLS, STR) .
    eq renameVars((crl LHS => RHS if COND [ ATS ] .) RLS, STR) = 
        (
            crl applySub(LHS, renameVars'(getVars(LHS ;; RHS) ;; getVars(COND), STR, 0)) => 
            applySub(RHS, renameVars'(getVars(LHS ;; RHS) ;; getVars(COND), STR, 0)) 
            if applySub2Cond(COND, renameVars'(getVars(LHS ;; RHS) ;; getVars(COND), STR, 0)) [ ATS ] .
        )
        renameVars(RLS, STR) .
    
    op renameVars : TermList String -> TermList .
    eq renameVars(GTL, STR) = GTL .
    eq renameVars((T,NTL), STR) = renameVars(T, STR) , renameVars(NTL, STR) .
    eq renameVars(T, STR) = applySub(T, renameVars'(getVars(T), STR, 0)) [ owise ] .

    op renameVars' : TermSet String Nat -> Substitution .
    eq renameVars'(mt, STR, N) = none .
    eq renameVars'(V, STR, N) = V <- fresh(STR, getType(V), N) .
    eq renameVars'((V ;; NTS), STR, N) = renameVars'(V, STR, N) ; renameVars'(NTS, STR, N + 1) .
    
    op safeVars : TermList QidList -> TermList .
    op safeVars : Term QidList -> Term .
    op safeVars : Rule QidList -> Rule .
    op safeVars : Equation QidList -> Equation .
    op safeVars : Condition QidList -> Condition .
    eq safeVars(TL, QL) = safeVars(TL, join(QL)) .
    eq safeVars(RL, QL) = safeVars(RL, join(QL)) .
    eq safeVars(EQ, QL) = safeVars(EQ, join(QL)) .
    eq safeVars(COND, QL) = safeVars(COND, join(QL)) .

    op safeVars : TermList String -> TermList .
    op safeVars : Term String -> Term .
    eq safeVars(empty, STR) = empty .
    eq safeVars(GT, STR) = GT .
    eq safeVars(V, STR) =
        if (startsWith(string(V), "#") or-else startsWith(string(V), "%") or-else startsWith(string(V), "@"))
        then qid(STR + (string(V)))
        else V
        fi .
    eq safeVars(F[NTL], STR) = F[safeVars(NTL, STR)] .
    eq safeVars((T, NTL), STR) = (safeVars(T, STR), safeVars(NTL, STR)) .

    op safeVars : Equation String -> Equation .
    eq safeVars((eq LHS = RHS [ ATS ] .), STR) = (eq safeVars(LHS, STR) = safeVars(RHS, STR) [ ATS ] .) .
    eq safeVars((ceq LHS = RHS if COND [ ATS ] .), STR) = (ceq safeVars(LHS, STR) = safeVars(RHS, STR) if safeVars(COND, STR) [ ATS ] .) .

    op safeVars : Rule String -> Rule .
    eq safeVars((rl LHS => RHS [ ATS ] .), STR) = (rl safeVars(LHS, STR) => safeVars(RHS, STR) [ ATS ] .) .
    eq safeVars((crl LHS => RHS if COND [ ATS ] .), STR) = (crl safeVars(LHS, STR) => safeVars(RHS, STR) if safeVars(COND, STR) [ ATS ] .) .

    op safeVars : Condition String -> Condition .
    eq safeVars((nil).Condition, STR) = nil .
    eq safeVars((T : S) /\ COND, STR) = (safeVars(T, STR) : S) /\ safeVars(COND, STR) .
    eq safeVars((T = T') /\ COND, STR) = (safeVars(T, STR) = safeVars(T', STR)) /\ safeVars(COND, STR) .
    eq safeVars((T => T') /\ COND, STR) = (safeVars(T, STR) => safeVars(T', STR)) /\ safeVars(COND, STR) .
    eq safeVars((T' := T) /\ COND, STR) = (safeVars(T', STR) := safeVars(T, STR)) /\ safeVars(COND, STR) .

    op fresh : String Type -> Variable .
    eq fresh(STR, TY) = qid(STR + ":" + substr(string(TY), 0, length(string(TY)))) .

    op fresh : String TypeList Nat -> TermList .
    eq fresh(STR, nil, N) = empty .
    eq fresh(STR, TY TYL, N) = qid(STR + string(N, 10) + ":" + substr(string(TY), 0, length(string(TY)))) , fresh(STR, TYL, s(N)) .

    op _inS_ : Sort SortSet -> Bool .
    eq S inS (S ; SS) = true .
    eq S inS SS = false [ owise ] .

    op _in_ : AttrSet AttrSet -> Bool .
    eq AT in AT ATS = true .
    eq AT in ATS = false [ owise ] .

    op _in_ : Term TermList -> Bool .
    eq T in T = true .
    eq T in F[NTL] = T in NTL .
    eq T in (T',NTL) = T in T' or-else T in NTL .
    eq T in TL = false [ owise ] .

    op _in_ : TermSet TermSet -> Bool .
    eq TS in (TS ;; TS') = true .
    eq TS in TS' = false [ owise ] .

    op _in_ : TermList TermSet -> Bool .
    eq empty in (TS) = true .
    eq (T,NTL) in TS = (T in TS) and-then (NTL in TS) .

    op applySub : TermSet Substitution -> TermSet .
    op applySub : TermList Substitution -> TermList .
    op applySub : Term Substitution -> Term .
    eq applySub((mt).TermSet, SB) = mt .
    eq applySub(empty, SB) = empty .
    eq applySub(V, (V <- T ; SB)) = T .
    eq applySub(F[NTL], SB) = F[applySub(NTL, SB)] .
    eq applySub((T, NTL), SB) = applySub(T, SB), applySub(NTL, SB) .
    eq applySub((T ;; NTS), SB) = applySub(T,SB) ;; applySub(NTS,SB) .
    eq applySub(T, SB) = T [ owise ] .

    op applySub2Cond : Condition Substitution -> Condition .
    eq applySub2Cond((nil).Condition, SB) = nil .
    eq applySub2Cond((T = T' /\ COND), SB) = (applySub(T, SB) = applySub(T', SB)) /\ applySub2Cond(COND, SB) .
    eq applySub2Cond((T : S) /\ COND, SB) = (applySub(T, SB) : S) /\ applySub2Cond(COND, SB) .
    eq applySub2Cond((T => T') /\ COND, SB) = (applySub(T, SB) => applySub(T', SB)) /\ applySub2Cond(COND, SB) .
    eq applySub2Cond((T' := T) /\ COND, SB) = (applySub(T', SB) := applySub(T, SB)) /\ applySub2Cond(COND, SB) .

    op applySub : Condition Substitution -> TermList .
    eq applySub((nil).Condition, SB) = empty .
    eq applySub((T = T' /\ COND), SB) = applySub('_=_[T,T'], SB) , applySub(COND, SB) .
    eq applySub((T : S) /\ COND, SB) = applySub(COND, SB) .
    eq applySub((T => T') /\ COND, SB) = applySub(COND, SB) .
    eq applySub((T' := T) /\ COND, SB) = applySub(COND, SB) .

    op applySub : NeCTermList Substitution -> Context .
    eq applySub([], SB) = [] .
    eq applySub(F[COL], SB) = F[applySub(COL, SB)] .
    eq applySub((CO, NTL), SB) = applySub(CO, SB) , applySub(NTL, SB) .
    eq applySub((T, COL), SB) = applySub(T, SB) , applySub(COL, SB) .

    op applySub : Substitution Substitution -> Substitution .
    eq applySub((none).Substitution, SB) = none .
    eq applySub(V <- T ; SB, SB') = V <- applySub(T, SB') ; applySub(SB, SB') .

    op replaceHole : Context Term -> Term .
    eq replaceHole([],T) = T .
    eq replaceHole(F[COL],T) = F[replaceHole(COL,T)] .
    eq replaceHole((CO,TL),T) = (replaceHole(CO,T),TL) [ owise ] .
    eq replaceHole((T,COL),T') = (T,replaceHole(COL,T')) [ owise ] .

    op getTerms : Condition -> TermSet .
    eq getTerms(nil) = mt .
    eq getTerms((T : S)) = T .
    eq getTerms((T = T')) = T ;; T' .
    eq getTerms((T' := T)) = T ;; T' .
    eq getTerms((T => T')) = T ;; T' .
    eq getTerms(COND /\ COND') = getTerms(COND) ;; getTerms(COND') .

    op toPattern : Module Term String -> Term .
    eq toPattern(M, C, STR) = C .
    eq toPattern(M, F[NTL], STR) = F[fresh(STR, getTypeList(M, NTL), 0)] .

    op getTypeList : Module TermList -> TypeList .
    eq getTypeList(M, empty) = nil .
    eq getTypeList(M, T) = leastSort(M, T) .
    eq getTypeList(M, (T, NTL)) = leastSort(M, T) getTypeList(M, NTL) .

    op ssc : Module Rule -> TermSet .
    eq ssc(M, rl LHS => RHS [ ATS ] .) = ssc(M, toPattern(M, LHS, "NuITP-SSC#"), RHS) .
    eq ssc(M, crl LHS => RHS if COND [ ATS ] .) = ssc(M, toPattern(M, LHS, "NuITP-SSC#"), RHS ;; getTerms(COND)) .

    op ssc : Module Term TermSet -> TermSet .
    eq ssc(M, LHS, mt) = mt .
    eq ssc(M, LHS, T) = ssc(M, LHS, T, 0) .
    eq ssc(M, LHS, T ;; NTS) = ssc(M, LHS, T) ;; ssc(M, LHS, NTS) .

    op ssc : Module Term Term Nat -> TermSet .
    ceq ssc(M, F[NTL], T, N) =
        if isOmega?(M, applySub(NTL, SB))
        then applySub(F[NTL], SB)
        else mt
        fi ;; ssc(M, F[NTL], T, N + 1)
        if { SB , CO } := metaXmatch(M, F[NTL], T, nil, 0, unbounded, N) .
    eq ssc(M, LHS, T, N) = mt [ owise ] .

    op subTerms : NeTermList -> TermSet .
    eq subTerms(F[NTL]) = (F[NTL]) ;; subTerms(NTL) .
    eq subTerms((T,NTL)) = subTerms(T) ;; subTerms(NTL) .
    eq subTerms(T) = T [ owise ] .

    op subTerms : Condition -> TermSet .
    eq subTerms((nil).Condition) = mt .
    eq subTerms(T : S) = subTerms(T) .
    eq subTerms(T = T') = subTerms(T) ;; subTerms(T') .
    eq subTerms(T' := T) = subTerms(T) ;; subTerms(T') .
    eq subTerms(T => T') = subTerms(T) ;; subTerms(T') .
    eq subTerms(COND /\ COND') = subTerms(COND) ;; subTerms(COND') [ owise ] .

    op subTerms : EquationSet -> TermSet .
    eq subTerms((eq LHS = RHS [ ATS ] .) EQS) = subTerms(LHS) ;; subTerms(RHS) ;; subTerms(EQS) .
    eq subTerms((ceq LHS = RHS if COND [ ATS ] .) EQS) = subTerms(LHS) ;; subTerms(RHS) ;; subTerms(COND) ;; subTerms(EQS) .
    eq subTerms(EQS) = mt [ owise ] .

    op omega : Module -> Module .
    eq omega(M) = setOps(setEqs(M, none), omega(getOps(M))) .

    op omega : OpDeclSet -> OpDeclSet .
    eq omega((op F : TYL -> TY [ ctor ATS ] .) OPDS) = (op F : TYL -> TY [ ctor ATS ] .) omega(OPDS) .
    eq omega(OPDS) = none [ owise ] .

    op isOmega? : Module TermSet -> Bool .
    op isOmega? : Module TermList -> Bool .
    op isOmega? : Module Term -> Bool .
    eq isOmega?(M, mt) = true .
    eq isOmega?(M, empty) = true .
    eq isOmega?(M, T ;; NTS) = isOmega?(M, T) and-then isOmega?(M, NTS) .
    eq isOmega?(M, (T,NTL)) = isOmega?(M, T) and-then isOmega?(M, NTL) .
    ceq isOmega?(M, '_->_[T,T']) = isOmega?(M, T) and-then isOmega?(M, T') if sameKind(M, getType(metaNormalize(M, '_->_[T,T'])), 'NuITP-Bool) .
    ceq isOmega?(M, '_\/_[T,NTL]) = isOmega?(M, T) and-then isOmega?(M, NTL) if sameKind(M, getType(metaNormalize(M, '_\/_[T,NTL])), 'NuITP-Bool) .
    ceq isOmega?(M, '_/\_[T,NTL]) = isOmega?(M, T) and-then isOmega?(M, NTL) if sameKind(M, getType(metaNormalize(M, '_/\_[T,NTL])), 'NuITP-Bool) .
    ceq isOmega?(M, '_=_[LHS,RHS]) = isOmega?(M, LHS) and-then isOmega?(M, RHS) if sameKind(M, getType(metaNormalize(M, '_=_[LHS,RHS])), 'NuITP-Bool) .
    ceq isOmega?(M, '_=>_[LHS,RHS]) = isOmega?(M, LHS) and-then isOmega?(M, RHS) if sameKind(M, getType(metaNormalize(M, '_=>_[LHS,RHS])), 'NuITP-Bool) .
    eq isOmega?(M, T) = isOmega?'(M, getOps(omega(M)) getOps(upModule('NuITP-CLAUSE,true)), T) [ owise ] .

    op isOmega?' : Module OpDeclSet TermList -> Bool .
    eq isOmega?'(M, OPDS, empty) = true .
    eq isOmega?'(M, OPDS, V) = true .
    ceq isOmega?'(M, (op F : nil -> TY [ ATS ] .) OPDS, C) = true
        if (getName(C) == F) and-then (getType(C) == TY) .
    eq isOmega?'(M, OPDS, C) = false [ owise ] .
    ceq isOmega?'(M, (op F : NTYL -> TY [ ATS ] .) OPDS, F[NTL]) = isOmega?'(M, (op F : NTYL -> TY [ ATS ] .) OPDS, NTL)
        if sameKind(M, TY, getType(metaNormalize(M, F[NTL])))
        /\ SB := metaMatch(M, F[fresh("NuITP-OM",NTYL, 0)], F[NTL], nil, 0) .
    eq isOmega?'(M, OPDS, F[NTL]) = false [ owise ] .
    eq isOmega?'(M, OPDS, (T, NTL)) = isOmega?'(M, OPDS, T) and-then isOmega?'(M, OPDS, NTL) .

    op sigma1 : Module -> Module .
    eq sigma1(M) = setOps(setEqs(M, sigma1(getEqs(M))), sigma1(M, getOps(M), subTerms(sigma1(getEqs(M))))) .

    op sigma1 : EquationSet -> EquationSet .
    eq sigma1((eq LHS = RHS [ variant ATS ] .) EQS) = (eq LHS = RHS [ variant ATS ] .) sigma1(EQS) .
    eq sigma1(EQS) = none [ owise ] .

    op sigma1 : Module OpDeclSet TermSet -> OpDeclSet .
    eq sigma1(M, (op F : TYL -> TY [ ctor ATS ] .) OPDS, TS) = (op F : TYL -> TY [ ctor ATS ] .) sigma1(M, OPDS, TS) .
    eq sigma1(M, (op F : nil -> TY [ ATS metadata("skolem") ] .) OPDS, TS) = (op F : nil -> TY [ ATS metadata("skolem") ] .) sigma1(M, OPDS, TS) .
    ceq sigma1(M, (op F : nil -> TY [ ATS ] .) OPDS, (C ;; TS)) = (op F : nil -> TY [ ATS ] .) sigma1(M, OPDS, (C ;; TS))
        if getName(C) == F and-then getType(C) == TY .
    ceq sigma1(M, (op F : NTYL -> TY [ ATS ] .) OPDS, ((F[NTL]) ;; TS)) = (op F : NTYL -> TY [ ATS ] .) sigma1(M, OPDS, ((F[NTL]) ;; TS))
        if sameKind(M, TY, getType(metaNormalize(M, F[NTL])))
        /\ SB := metaMatch(M, F[fresh("NuITP-S1",NTYL, 0)], F[NTL], nil, 0) .
    eq sigma1(M, OPDS, TS) = none [ owise ] .

    op isSigma1? : Module TermList -> Bool .
    eq isSigma1?(M, empty) = false .
    eq isSigma1?(M, (T,NTL)) = isSigma1?(M, T) and-then isSigma1?(M, NTL) .
    eq isSigma1?(M, '_->_[T,T']) = isSigma1?(M, T) and-then isSigma1?(M, T') .
    eq isSigma1?(M, '_\/_[T,NTL]) = isSigma1?(M, T) and-then isSigma1?(M, NTL) .
    eq isSigma1?(M, '_/\_[T,NTL]) = isSigma1?(M, T) and-then isSigma1?(M, NTL) .
    eq isSigma1?(M, '_=_[LHS,RHS]) = isSigma1?(M, LHS) and-then isSigma1?(M, RHS) .
    eq isSigma1?(M, '_=>_[LHS,RHS]) = isSigma1?(M, LHS) and-then isSigma1?(M, RHS) .
    eq isSigma1?(M, T) = isSigma1?'(M, getOps(sigma1(M)) getOps(upModule('NuITP-CLAUSE,true)), T) [ owise ] .

    op isSigma1?' : Module OpDeclSet TermList -> Bool .
    eq isSigma1?'(M, OPDS, empty) = true .
    eq isSigma1?'(M, OPDS, V) = true .
    ceq isSigma1?'(M, (op F : nil -> TY [ ATS ] .) OPDS, C) = true
        if (getName(C) == F) and-then (getType(C) == TY) .
    eq isSigma1?'(M, OPDS, C) = false [ owise ] .
    ceq isSigma1?'(M, (op F : NTYL -> TY [ ATS ] .) OPDS, F[NTL]) = isSigma1?'(M, (op F : NTYL -> TY [ ATS ] .) OPDS, NTL)
        if sameKind(M, TY, getType(metaNormalize(M, F[NTL])))
        /\ SB := metaMatch(M, F[fresh("NuITP-S1",NTYL, 0)], F[NTL], nil, 0) .
    eq isSigma1?'(M, OPDS, F[NTL]) = false [ owise ] .
    eq isSigma1?'(M, OPDS, (T, NTL)) = isSigma1?'(M, OPDS, T) and-then isSigma1?'(M, OPDS, NTL) .

    op sigma1Top? : Module Term -> Bool .
    eq sigma1Top?(M, T) = sigma1Top?'(M, getOps(sigma1(M)), T) .

    op sigma1Top?' : Module OpDeclSet Term -> Bool .
    eq sigma1Top?'(M, OPDS, V) = true .
    ceq sigma1Top?'(M, (op F : nil -> TY [ ATS ] .) OPDS, C) = true
        if getName(C) == F and-then getType(C) == TY .
    eq sigma1Top?'(M, OPDS, C) = false [ owise ] .
    ceq sigma1Top?'(M, (op F : NTYL -> TY [ ATS ] .) OPDS, F[NTL]) = true
        if sameKind(M, TY, getType(metaNormalize(M, F[NTL])))
        /\ SB := metaMatch(M, F[fresh("NuITP-S1",NTYL, 0)], F[NTL], nil, 0) .
    eq sigma1Top?'(M, OPDS, F[NTL]) = false [ owise ] .

    op getMaxNotSigma1 : Module Term -> TermSet .
    eq getMaxNotSigma1(M, V) = mt .
    eq getMaxNotSigma1(M, C) = if sigma1Top?(M, C) then mt else C fi .
    eq getMaxNotSigma1(M, F[NTL]) = if sigma1Top?(M, F[NTL]) then getMaxNotSigma1(M, NTL) else F[NTL] fi .
    eq getMaxNotSigma1(M, (T,NTL)) = getMaxNotSigma1(M, T) ;; getMaxNotSigma1(M, NTL) .

    op splitBySigma : Module Term -> TermListPair .
    eq splitBySigma(M, T) = splitBySigma(M, T, empty, empty) .

    op splitBySigma : Module TermList TermList TermList -> TermListPair .
    eq splitBySigma(M, empty, TL, TL') = { TL :: TL' } .
    eq splitBySigma(M, '_/\_[NTL], TL, TL') = splitBySigma(M, NTL, TL, TL') .
    eq splitBySigma(M, ('_=_[LHS,RHS],TL''), TL, TL') =
        if (isSigma1?(M, '_=_[LHS,RHS]))
        then splitBySigma(M, TL'', (TL,'_=_[LHS,RHS]), TL')
        else splitBySigma(M, TL'', TL, (TL','_=_[LHS,RHS]))
        fi [ owise ] .

    op replaceMaxNotSigma1 : Term Substitution -> Term .
    eq replaceMaxNotSigma1(T, none) = T .
    eq replaceMaxNotSigma1(C, V <- C ; SB) = V .
    eq replaceMaxNotSigma1(C, SB) = C [ owise ] .
    eq replaceMaxNotSigma1(V, SB) = V .
    eq replaceMaxNotSigma1(F[NTL], V <- F[NTL] ; SB) = V .
    eq replaceMaxNotSigma1(F[NTL], SB) = F[replaceMaxNotSigma1(NTL, SB)] [ owise ] .
    eq replaceMaxNotSigma1((T,NTL), SB) = (replaceMaxNotSigma1(T, SB) , replaceMaxNotSigma1(NTL, SB)) .

    op isTrivial : TermSet -> Bool .
    eq isTrivial(('_->_[GAMMA,LAMBDA]) ;; TS) = ((GAMMA == 'false.NuITP-Bool) or-else (LAMBDA == 'true.NuITP-Bool)) and-then isTrivial(TS) .
    eq isTrivial(TS) = true [ owise ] .

    op reduceSet : Module TermSet -> TermSet .
    eq reduceSet(M, mt) = mt .
    eq reduceSet(M, T) = getTerm(metaReduce(M, T)) .
    eq reduceSet(M, T ;; NTS) = getTerm(metaReduce(M, T)) ;; reduceSet(M, NTS) .

    op split : TermSet -> TermSet .
    eq split(mt) = mt .
    eq split('_->_[GAMMA,'_/\_[NTL]]) = split'(GAMMA, NTL) .
    eq split(T) = T [ owise ] .
    eq split(T ;; NTS) = split(T) ;; split(NTS) .

    op split' : Term TermList -> TermSet .
    eq split'(GAMMA, empty) = mt .
    eq split'(GAMMA, T) = '_->_[GAMMA, T] .
    eq split'(GAMMA, (T,NTL)) = ('_->_[GAMMA, T]) ;; split'(GAMMA, NTL) .

    op wrapAndCC : TermSet -> Term .
    eq wrapAndCC(mt) = mt .
    eq wrapAndCC('true.NuITP-Bool ;; TS) = wrapAndCC(TS) .
    eq wrapAndCC('false.NuITP-Bool ;; TS) = 'false.NuITP-Bool .
    eq wrapAndCC(NTS) = wrapAndCC'(NTS,empty) [ owise ] .

    op wrapAndCC' : TermSet TermList -> Term .
    eq wrapAndCC'(('_->_['true.NuITP-Bool,GAMMA]), empty) = GAMMA .
    eq wrapAndCC'(('_->_['true.NuITP-Bool,GAMMA]), NTL) = '_/\_[NTL,GAMMA] [ owise ] .
    eq wrapAndCC'((('_->_['true.NuITP-Bool,GAMMA]) ;; NTS), TL) = wrapAndCC'(NTS, (TL,GAMMA)) .

    op wrapAnd : TermList -> Term .
    eq wrapAnd(empty) = 'true.NuITP-Bool .
    eq wrapAnd(T) = T .
    eq wrapAnd((T,T',TL)) = '_/\_[T,T',TL] .

    op wrapCond : Term -> Term .
    eq wrapCond('_=_[LHS,RHS]) = '_->_['true.NuITP-Bool,'_=_[LHS,RHS]] .
    eq wrapCond('_=>_[LHS,RHS]) = '_->_['true.NuITP-Bool,'_=>_[LHS,RHS]] .
    eq wrapCond(T) = T [ owise ] .

    op toDNF : Module Term -> Term .
    eq toDNF(M, T) = getTerm(metaReduce(setEqs(M, getEqs(upModule('NuITP-DNF,false))), T)) .

    op toCNF : Module Term -> Term .
    eq toCNF(M, T) = getTerm(metaReduce(setEqs(M, getEqs(upModule('NuITP-CNF,false))), T)) .

    op getEqualities : TermSet -> TermSet .
    op getEqualities : TermList -> TermSet .
    eq getEqualities(mt) = mt .
    eq getEqualities(empty) = mt .
    eq getEqualities('true.NuITP-Bool) = mt .
    eq getEqualities('false.NuITP-Bool) = mt .
    eq getEqualities('_=_[LHS,RHS]) = '_=_[LHS,RHS] .
    eq getEqualities('_=>_[LHS,RHS]) = '_=>_[LHS,RHS] .
    eq getEqualities('not_[T]) = getEqualities(T) .
    eq getEqualities('_/\_[NTL]) = getEqualities(NTL) .
    eq getEqualities('_\/_[NTL]) = getEqualities(NTL) .
    eq getEqualities('_->_[GAMMA,LAMBDA]) = getEqualities(GAMMA) ;; getEqualities(LAMBDA) .
    eq getEqualities(T ;; NTS) = getEqualities(T) ;; getEqualities(NTS) .
    eq getEqualities((T, NTL)) = getEqualities(T) ;; getEqualities(NTL) .

    op getEqPreds : Module -> EquationSet .
    eq getEqPreds(M) = getEqPreds(getEqs(M)) .
    
    op getEqPreds : EquationSet -> EquationSet .
    eq getEqPreds((eq '_=_[T1,T2] = RHS [ ATS metadata("eqpred")] .) (eq '_=>_[T1,T2] = RHS [ ATS metadata("eqpred")] .) EQS) = (eq '_=_[T1,T2] = RHS [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((eq '_=_[T2,T1] = RHS [ ATS metadata("eqpred")] .) (eq '_=>_[T1,T2] = RHS [ ATS metadata("eqpred")] .) EQS) = (eq '_=_[T2,T1] = RHS [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((eq '_=_[T1,T2] = '_=_[T3,T4] [ ATS metadata("eqpred")] .) (eq '_=>_[T1,T2] = '_=>_[T3,T4] [ ATS metadata("eqpred")] .) EQS) = (eq '_=_[T1,T2] = '_=_[T3,T4] [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((eq '_=_[T2,T1] = '_=_[T4,T3] [ ATS metadata("eqpred")] .) (eq '_=>_[T1,T2] = '_=>_[T3,T4] [ ATS metadata("eqpred")] .) EQS) = (eq '_=_[T2,T1] = '_=_[T4,T3] [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((ceq '_=_[T1,T2] = RHS if COND [ ATS metadata("eqpred")] .) (ceq '_=>_[T1,T2] = RHS if COND [ ATS metadata("eqpred")] .) EQS) = (ceq '_=_[T1,T2] = RHS if COND [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((ceq '_=_[T2,T1] = RHS if COND [ ATS metadata("eqpred")] .) (ceq '_=>_[T1,T2] = RHS if COND [ ATS metadata("eqpred")] .) EQS) = (ceq '_=_[T2,T1] = RHS if COND [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((ceq '_=_[T1,T2] = '_=_[T3,T4] if COND [ ATS metadata("eqpred")] .) (ceq '_=>_[T1,T2] = '_=>_[T3,T4] if COND [ ATS metadata("eqpred")] .) EQS) = (ceq '_=_[T1,T2] = '_=_[T3,T4] if COND [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds((ceq '_=_[T2,T1] = '_=_[T4,T3] if COND [ ATS metadata("eqpred")] .) (ceq '_=>_[T1,T2] = '_=>_[T3,T4] if COND [ ATS metadata("eqpred")] .) EQS) = (ceq '_=_[T2,T1] = '_=_[T4,T3] if COND [ ATS ] .) getEqPreds(EQS) .
    eq getEqPreds(EQS) = none [ owise ] .
    
    op hasGroundGS? : GenSetCollectionSet Type -> Bool .
    eq hasGroundGS?([ TY | DEF | GSL1 [ DEF : NTS ] GSL2 ] GCS, TY) = (getVars(NTS) == mt) .
    eq hasGroundGS?(GCS, TY) = false [ owise ] .

    op filterGround : GenSetCollectionSet TermSet -> TermSet .
    eq filterGround(GCS, mt) = mt .
    eq filterGround(mt, TS) = mt .
    eq filterGround(GCS, C ;; TS) = (if hasGroundGS?(GCS, getType(C)) then C else mt fi) ;; filterGround(GCS, TS) .
    eq filterGround(GCS, V ;; TS) = (if hasGroundGS?(GCS, getType(V)) then V else mt fi) ;; filterGround(GCS, TS) .

    op replaceAll : String String String -> String .
    eq replaceAll(STR, STR1, STR2) = replaceAll(STR, STR1, STR2, find(STR, STR1, 0)) .

    op replaceAll : String String String FindResult -> String .
    eq replaceAll(STR, STR1, STR2, notFound) = STR .
    eq replaceAll(STR, STR1, STR2, N) = substr(STR, 0, N) + STR2 + replaceAll(substr(STR, N + length(STR1), length(STR)), STR1, STR2) .

    op list2set : TermList -> TermSet .
    op list2set : NeTermList -> NeTermSet .
    eq list2set(empty) = mt .
    eq list2set(T) = T .
    eq list2set((T,NTL)) = T ;; list2set(NTL) .

    op set2list : TermSet -> TermList .
    op set2list : NeTermSet -> NeTermList .
    eq set2list(mt) = empty .
    eq set2list(T) = T .
    eq set2list((T ;; NTS)) = (T , set2list(NTS)) .
endfm

fmod NuITP-FREECTOR is
    pr NuITP-UTILS .

    var M : Module .
    var F : Qid .
    vars TY TY' TY1 TY1' TY2 TY2' : Type .
    vars TYL TYL' : TypeList .
    vars ATS ATS' : AttrSet .
    var OPDS : OpDeclSet .
    var EQS : EquationSet .
    vars NTL NTL1 NTL2 : NeTermList .
    var C : Constant .
    vars T T1 T2 LHS RHS : Term .
    var COND : Condition .
    var SB : Substitution .
    var FT : FreeTriple .
    var FTS : FreeTripleSet .
    var V : Variable .
    var TS : TermSet .

    sort FreeTriple FreeTripleSet .
    subsort FreeTriple < FreeTripleSet .

    op {_,_,_} : Type Type Term -> FreeTriple [ ctor ] .
    op mt : -> FreeTripleSet [ ctor ] .
    op __ : FreeTripleSet FreeTripleSet -> FreeTripleSet [ assoc comm id: mt ] .
    eq FT FT = FT .
    
    op simplify : Module FreeTripleSet -> FreeTripleSet .
    ceq simplify(M, { TY1, TY2, T } { TY1', TY2', T } FTS) = simplify(M, { TY1, TY2, T } FTS)
        if sortLeq(M, TY2', TY2) .
    eq simplify(M, FTS) = FTS [ owise ] .

    op makeFreeGenerators : Module -> GenSetCollectionSet .
    eq makeFreeGenerators(M) = makeFreeGenerators(getNonFreeUTriples(M)) .

    op makeFreeGenerators : FreeTripleSet -> GenSetCollectionSet .
    eq makeFreeGenerators({ TY, TY', T } FTS) = [ TY | "ufree" | [ "ufree" : (T ;; qid("V:" + substr(string(TY'), 0, length(string(TY'))))) ]] makeFreeGenerators(FTS) .
    eq makeFreeGenerators(mt) = mt [ owise ] .

    op getNonFreeUVars : Module Term -> TermSet .
    eq getNonFreeUVars(M, T) = getNonFreeUVars(getVars(T), getNonFreeUTriples(M)) .

    op getNonFreeUVars : TermSet FreeTripleSet -> TermSet .
    ceq getNonFreeUVars((V ;; TS), ({ TY, TY', T } FTS)) = V ;; getNonFreeUVars(TS, ({ TY, TY', T } FTS))
        if (getType(V) == TY) .
    eq getNonFreeUVars(TS, FTS) = mt [ owise ] .

    op getNonFreeUTriples : Module -> FreeTripleSet .
    eq getNonFreeUTriples(M) = simplify(M, getNonFreeUTriples(M, getOps(M))) .
    
    op getNonFreeUTriples : Module OpDeclSet -> FreeTripleSet .
    ceq getNonFreeUTriples(M, (op F : TYL -> TY [ assoc id(T) ATS ] .) (op F : TYL' -> TY' [ ctor assoc id(T) ATS' ] .) OPDS) = { TY, TY', T } getNonFreeUTriples(M, (op F : TYL' -> TY' [ ctor assoc id(T) ATS' ] .) OPDS)
        if not(ctor in ATS) 
        /\ sortLeq(M, TY', TY) .
    eq getNonFreeUTriples(M, OPDS) = mt [ owise ] .

    op isFreeCtor? : Module -> Bool .
    eq isFreeCtor?(M) = isFreeCtor?(M, getEqs(M), getOps(M)) .

    op isFreeCtor? : Module EquationSet OpDeclSet -> Bool .
    --- Idempotency
    eq isFreeCtor?(M, EQS, (op F : TY1 TY2 -> TY [ ctor idem ATS ] .) OPDS) = false .
    --- Unity
    ceq isFreeCtor?(M, EQS, (op F : TY1 TY2 -> TY [ ctor id(T) ATS ] .) OPDS) = false
        if sortLeq(M, getType(metaNormalize(M, T)), TY) or-else sortLeq(M, getType(metaNormalize(M, T)), TY1) or-else sortLeq(M, getType(metaNormalize(M, T)), TY2) .
    ceq isFreeCtor?(M, EQS, (op F : TY1 TY2 -> TY [ ctor left-id(T) ATS ] .) OPDS) = false
        if sortLeq(M, getType(metaNormalize(M, T)), TY) or-else sortLeq(M, getType(metaNormalize(M, T)), TY1) or-else sortLeq(M, getType(metaNormalize(M, T)), TY2) .
    ceq isFreeCtor?(M, EQS, (op F : TY1 TY2 -> TY [ ctor right-id(T) ATS ] .) OPDS) = false
        if sortLeq(M, getType(metaNormalize(M, T)), TY) or-else sortLeq(M, getType(metaNormalize(M, T)), TY1) or-else sortLeq(M, getType(metaNormalize(M, T)), TY2) .
    --- Explicit Equations
    ceq isFreeCtor?(M, (eq C = RHS [ ATS' ] .) EQS, (op F : nil -> TY [ ctor ATS ] .) OPDS) = false
        if (getName(C) == F) and-then sameKind(M, getType(C), TY) .
    ceq isFreeCtor?(M, (ceq C = RHS if COND [ ATS' ] .) EQS, (op F : nil -> TY [ ctor ATS ] .) OPDS) = false
        if (getName(C) == F) and-then sameKind(M, getType(C), TY) .
    ceq isFreeCtor?(M, (eq F[NTL1] = RHS [ ATS' ] .) EQS, (op F : TYL -> TY [ ctor ATS ] .) OPDS) = false
        if F[NTL2] := F[fresh("NuITP-FCC#", TYL, 0)]
        /\ sameKind(M, getType(metaNormalize(M, F[NTL1])), getType(metaNormalize(M, F[NTL2])))
        /\ SB := metaMatch(M, F[fresh("NuITP-FCC#", TYL, 0)], F[NTL1], nil, 0) .
    ceq isFreeCtor?(M, (ceq F[NTL1] = RHS if COND [ ATS' ] .) EQS, (op F : TYL -> TY [ ctor ATS ] .) OPDS) = false
        if F[NTL2] := F[fresh("NuITP-FCC#", TYL, 0)]
        /\ sameKind(M, getType(metaNormalize(M, F[NTL1])), getType(metaNormalize(M, F[NTL2])))
        /\ SB := metaMatch(M, F[fresh("NuITP-FCC#", TYL, 0)], F[NTL1], nil, 0) .
    --- None of the above
    eq isFreeCtor?(M, EQS, OPDS) = true [ owise ] .
endfm

fmod NuITP-REMOVE-U is
    pr NuITP-UTILS .

    vars Q F : Qid .
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    vars EQS EQS' EQS'' : EquationSet .
    vars RLS RLS' RLS'' : RuleSet .
    var STDS : StratDeclSet .
    var STDFS : StratDefSet .

    vars TY TY' TY'' : Type .
    var ATS : AttrSet .
    vars T GAMMA GAMMA' LHS RHS LHS' RHS' : Term .
    var TS : TermSet .
    var NTS : NeTermSet .
    var TL : TermList .
    var NTL : NeTermList .
    var TYL : TypeList .
    var M : Module .
    vars EQ EQ' : Equation .
    vars RL RL' : Rule .
    var N : Nat .
    var SB : Substitution .
    var PA : Parent .
    var B : Bool .
    var COND : Condition .

    op {_,_} : OpDeclSet EquationSet -> ResultPair [ ctor ] .
    op getOps : ResultPair -> OpDeclSet .
    eq getOps({ OPDS , EQS }) = OPDS .
    op getEqs : ResultPair -> EquationSet .
    eq getEqs({ OPDS , EQS }) = EQS .

    op removeVariant : EquationSet -> EquationSet .
    eq removeVariant((eq LHS = RHS [ variant ATS ] .) EQS) = removeVariant((eq LHS = RHS [ ATS ] .) EQS) .
    eq removeVariant(EQS) = EQS [ owise ] .

    --- Only for flat modules
    op removeU : Module -> Module [ memo ] .
    eq removeU(fmod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfm) = removeU'(fmod H is IL sorts SS . SSDS getOps(removeU(fmod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(fmod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) endfm, EQS) .
    eq removeU(fth Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfth) = removeU'(fth Q is IL sorts SS . SSDS getOps(removeU(fth Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(fth Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) endfth, EQS) .
    eq removeU(mod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endm) = removeU'(mod H is IL sorts SS . SSDS getOps(removeU(mod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(mod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS endm, EQS) .
    eq removeU(th Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endth) = removeU'(th Q is IL sorts SS . SSDS getOps(removeU(th Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(th Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS endth, EQS) .
    eq removeU(smod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsm) = removeU'(smod H is IL sorts SS . SSDS getOps(removeU(smod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(smod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS STDS STDFS endsm, EQS) .
    eq removeU(sth H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsth) = removeU'(sth H is IL sorts SS . SSDS getOps(removeU(sth H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(sth H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS STDS STDFS endsth, EQS) .
    eq removeU(M) = M [ owise ] .

    op removeU : Module OpDeclSet -> ResultPair .
    eq removeU(M, OPDS) = removeU(M, { OPDS , none }) .

    op removeU : Module ResultPair -> ResultPair .
    eq removeU(M, { (op F : TY TY' -> TY'' [ id(T) ATS ] .) OPDS , EQS }) = removeU(M, { (op F : TY TY' -> TY'' [ ATS ] .) OPDS, EQS (eq F[T,qid("NuITP-RU:" + string(getKind(M,TY)))] = qid("NuITP-RU:" + string(getKind(M,TY))) [ variant metadata("rem-u") ] .)
        if (not comm in ATS)
            then (eq F[qid("NuITP-RU-:" + string(getKind(M,TY))),T] = qid("NuITP-RU-:" + string(getKind(M,TY))) [ variant metadata("rem-u") ] .)
            else none
        fi
        if (assoc in ATS)
            then (eq F[qid("NuITP-RU1:" + string(getKind(M,TY))), T, qid("NuITP-RU2:" + string(getKind(M,TY')))] = F[qid("NuITP-RU1:" + string(getKind(M,TY))), qid("NuITP-RU2:" + string(getKind(M,TY')))] [ variant metadata("rem-u") ] .)
            else none
        fi
    }) .
    eq removeU(M, { (op F : TY TY' -> TY'' [ left-id(T) ATS ] .) OPDS , EQS }) = removeU(M, { (op F : TY TY' -> TY'' [ ATS ] .) OPDS, EQS (eq F[T,qid("NuITP-RU:" + string(getKind(M,TY)))] = qid("NuITP-RU:" + string(getKind(M,TY))) [ variant metadata("rem-u") ] .)
        if (assoc in ATS)
            then (eq F[qid("NuITP-RU1:" + string(getKind(M,TY))), T, qid("NuITP-RU2:" + string(getKind(M,TY')))] = F[qid("NuITP-RU1:" + string(getKind(M,TY))), qid("NuITP-RU2:" + string(getKind(M,TY')))] [ variant metadata("rem-u") ] .)
            else none
        fi
    }) .
    eq removeU(M, { (op F : TY TY' -> TY'' [ right-id(T) ATS ] .) OPDS , EQS }) = removeU(M, { (op F : TY TY' -> TY'' [ ATS ] .) OPDS, EQS (eq F[qid("NuITP-RU:" + string(getKind(M,TY))),T] = qid("NuITP-RU:" + string(getKind(M,TY))) [ variant metadata("rem-u") ] .)
        if (assoc in ATS)
            then (eq F[qid("NuITP-RU1:" + string(getKind(M,TY))), T, qid("NuITP-RU2:" + string(getKind(M,TY')))] = F[qid("NuITP-RU1:" + string(getKind(M,TY))), qid("NuITP-RU2:" + string(getKind(M,TY')))] [ variant metadata("rem-u") ] .)
            else none
        fi
    }) .
    eq removeU(M, { OPDS , EQS }) = { OPDS , EQS } [ owise ] .

    op removeU' : Module EquationSet -> Module .
    eq removeU'(M, none) = M .
    eq removeU'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, EQ EQS') = fmod H is IL sorts SS . SSDS OPDS MAS removeVariant(EQS) removeU'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, EQ, EQS', 0, none) endfm .
    eq removeU'(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, EQ EQS') = fth Q is IL sorts SS . SSDS OPDS MAS removeVariant(EQS) removeU'(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth, EQ, EQS', 0, none) endfth .
    eq removeU'(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, EQ EQS') = mod H is IL sorts SS . SSDS OPDS MAS removeVariant(EQS) removeU'(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, EQ, EQS', 0, none) RLS endm .
    eq removeU'(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, EQ EQS') = th Q is IL sorts SS . SSDS OPDS MAS removeVariant(EQS) removeU'(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth, EQ, EQS', 0, none) RLS endth .
    eq removeU'(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, EQ EQS') = smod H is IL sorts SS . SSDS OPDS MAS removeVariant(EQS) removeU'(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, EQ, EQS', 0, none) RLS STDS STDFS endsm .
    eq removeU'(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, EQ EQS') = sth H is IL sorts SS . SSDS OPDS MAS removeVariant(EQS) removeU'(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth, EQ, EQS', 0, none) RLS STDS STDFS endsth .

    op removeU' : Module Equation EquationSet Nat EquationSet -> EquationSet .
    ceq removeU'(M, (eq LHS = RHS [ ATS ] .), EQS, N, EQS') = removeU'(M, (eq LHS = RHS [ ATS ] .), EQS, N + 1, EQS' if (LHS' =/= RHS') then renameVars((eq LHS' = RHS' [ ATS ] .),"RU") else none fi)
        if { T , OPDS } := termify(nil, LHS, RHS, empty, getType(metaNormalize(M, LHS)) getType(metaNormalize(M, RHS)))
        /\ { 'auxWrapper[LHS',RHS'], SB, F, PA, B } := metaGetVariant(addOps(M, OPDS), T, empty, '#, N) .
    ceq removeU'(M, (ceq LHS = RHS if COND [ ATS ] .), EQS, N, EQS') = removeU'(M, (ceq LHS = RHS if COND [ ATS ] .), EQS, N + 1, EQS' if (LHS' =/= RHS') then renameVars((ceq LHS' = RHS' if toCondition(NTL) [ ATS ] .),"RU") else none fi)
        if { T , OPDS } := termify(COND, LHS, RHS, empty, getType(metaNormalize(M, LHS)) getType(metaNormalize(M, RHS)))
        /\ { 'auxWrapper[LHS',RHS',NTL], SB, F, PA, B } := metaGetVariant(addOps(M, OPDS), T, empty, '#, N) .
    eq removeU'(M, EQ, EQ' EQS', N, EQS'') = removeU'(M, EQ', EQS', 0, EQS'') [ owise ] .
    eq removeU'(M, EQ, none, N, EQS) = EQS [ owise ] .

    sort TermOpDeclSet .
    op {_,_} : Term OpDeclSet -> TermOpDeclSet [ ctor ] .

    op termify : Condition Term Term TermList TypeList -> TermOpDeclSet [ memo ] .
    eq termify(nil, LHS, RHS, empty, TYL) = { 'auxWrapper[LHS,RHS], (op 'auxWrapper : TYL -> 'NuITP-Bool [ ctor ] .) } .
    eq termify(nil, LHS, RHS, NTL, TYL) = { 'auxWrapper[LHS,RHS,NTL], (op 'auxWrapper : TYL -> 'NuITP-Bool [ ctor ] .) } .
    eq termify(LHS' = RHS', LHS, RHS, TL, TYL) = { 'auxWrapper[LHS,RHS,TL,'_=_[LHS',RHS']], op 'auxWrapper : TYL 'NuITP-Eq -> 'NuITP-Bool [ ctor ] . } .
    eq termify(LHS' = RHS' /\ COND, LHS, RHS, TL, TYL) = termify(COND, LHS, RHS, (TL,'_=_[LHS',RHS']), TYL 'NuITP-Eq) [ owise ] .
endfm

fmod NuITP-EQPREDS is
    pr NuITP-UTILS .

    var M : Module .
    var N : Nat .
    var K : Kind .
    var KS : KindSet .
    vars B B' : Bool .
    vars S S' : Sort .
    vars SS SS' : SortSet .
    var NeSS : NeSortSet .
    var SSDS : SubsortDeclSet .
    vars TY TY' TY'' : Type .
    vars TYL TYL' : TypeList .
    vars NeTYL NeTYL' : NeTypeList .
    vars ATS ATS' : AttrSet .
    vars F F' Q : Qid .
    var OP : OpDecl .
    vars OPDS OPDS' : OpDeclSet .
    var EQS : EquationSet .
    vars T T' T'' T1 T2 T3 T4 : Term .
    vars TL TL' TL'' TL1 TL2 : TermList .
    var NeHL : NeHookList .
    var SB : Substitution .
    var PA : Parent .
    
    op filterFree : Module OpDeclSet -> Module [ memo ] .
    ceq filterFree(M, (op F : TYL -> TY [ ctor ATS ] .) OPDS) = filterFree(M, (op F : TYL -> TY [ ATS ] .) OPDS)
        if { T', SB, F', PA, B } := metaGetVariant(M, F[fresh("NuITP#", TYL, 0)], empty, '#, 1) .
    eq filterFree(M, OPDS) = setOps(M, OPDS) [ owise ] .

    --- Requires module with NuITP-BOOL/CLAUSE extension
    op eqPreds : Module -> Module [ memo ] .
    eq eqPreds(M) = eqPreds-step2(eqPreds-step1(filterFree(M, getOps(M)), getKinds(filterFree(M, getOps(M))), 0, none, none, none), maximalOps(filterFree(M, getOps(M)), getOps(filterFree(M, getOps(M)))), none) .

    op eqPreds-step1 : Module KindSet Nat SortSet SubsortDeclSet OpDeclSet -> Module .
    eq eqPreds-step1(M, none, N, SS, SSDS, OPDS) = addOps(addOps(addSubSorts(addSorts(M, SS), SSDS), OPDS), eqPreds-step1''(addSubSorts(addSorts(M, SS), SSDS), getOps(M), none)) .
    eq eqPreds-step1(M, K ; KS, N, SS, SSDS, OPDS) = eqPreds-step1(M, KS, s(N), SS ; getSorts(eqPreds-step1'(M, maximalSorts(M, K), N, none, none)), SSDS getSubsorts(eqPreds-step1'(M, maximalSorts(M, K), N, none, none)), OPDS getOps(eqPreds-step1'(M, maximalSorts(M, K), N, none, none))) .

    op eqPreds-step1' : Module SortSet Nat SortSet SubsortDeclSet -> ResultTriple .
    eq eqPreds-step1'(M, S, N, none, none) = { none, none, (op '_=_ : S S -> 'NuITP-Eq [ comm ] .) (op '_=>_ : S S -> 'NuITP-Rl [ none ] .) } .
    eq eqPreds-step1'(M, S, N, SS, SSDS) = 
        if true
        then { SS ; qid("eq-top-" + string(N, 10)), SSDS (subsort S < qid("eq-top-" + string(N, 10)) .), (op '_=_ : qid("eq-top-" + string(N, 10)) qid("eq-top-" + string(N, 10)) -> 'NuITP-Eq [ comm ] .) (op '_=>_ : qid("eq-top-" + string(N, 10)) qid("eq-top-" + string(N, 10)) -> 'NuITP-Rl [ none ] .) }
        else { SS ; qid("eq-top-" + string(N, 10)), SSDS (subsort S < qid("eq-top-" + string(N, 10)) .), (op '_=_ : qid("eq-top-" + string(N, 10)) qid("eq-top-" + string(N, 10)) -> 'NuITP-Eq [ comm ] .) (op '_=>_ : qid("eq-top-" + string(N, 10)) qid("eq-top-" + string(N, 10)) -> 'NuITP-Rl [ none ] .) }
        fi [ owise ] .
    eq eqPreds-step1'(M, S ; NeSS, N, SS, SSDS) = eqPreds-step1'(M, NeSS, N, SS ; qid("eq-top-" + string(N, 10)), SSDS (subsort S < qid("eq-top-" + string(N, 10)) .)) .

    op eqPreds-step1'' : Module OpDeclSet OpDeclSet -> OpDeclSet .
    eq eqPreds-step1''(M, (op F : TY TY' -> TY'' [ assoc ATS ] .) OPDS, OPDS') = eqPreds-step1''(M, OPDS, OPDS' (op qid("eq-root-" + safeString(F)) : maximalSorts(M, getKind(M, TY'')) -> 'NuITP-Bool [ none ] .) (op qid("eq-in-" + safeString(F)) : maximalSorts(M, getKind(M, TY'')) maximalSorts(M, getKind(M, TY'')) -> 'NuITP-Bool [ none ] .)) .
    eq eqPreds-step1''(M, OPDS, OPDS') = OPDS' [ owise ] .

    op isMaximal : Module TypeList TypeList -> Bool .
    eq isMaximal(M, TY TYL, TY' TYL') = not(TY in TY' lesserSorts(M, TY')) or-else isMaximal(M, TYL, TYL') .
    eq isMaximal(M, TYL, TYL') = false [ owise ] .

    op maximalOps : Module OpDeclSet -> OpDeclSet .
   ceq maximalOps(M, (op F : TYL -> TY [ ATS ] .) OPDS) = maximalOps(M, OPDS)
        if not(ctor in ATS) .
   ceq maximalOps(M, (op F : TYL -> TY [ ctor ATS ] .) (op F : TYL' -> TY' [ ctor ATS' ] .) OPDS) = maximalOps(M, (op F : TYL' -> TY' [ ctor ATS' ] .) OPDS)
        if isMaximal(M, TYL TY, TYL' TY) .
    eq maximalOps(M, OPDS) = OPDS [ owise ] .

    op eqPreds-step2 : Module OpDeclSet EquationSet -> Module .
    eq eqPreds-step2(M, none, EQS) = addEqs(M, EQS eqPreds-step2'(M, getKinds(M), none)) .
    eq eqPreds-step2(M, (op '_=_ : 'Universal 'Universal -> 'NuITP-Eq [ ATS ] .) OPDS, EQS) = eqPreds-step2(M, OPDS, EQS) .
    eq eqPreds-step2(M, (op '_=>_ : 'Universal 'Universal -> 'NuITP-Rl [ ATS ] .) OPDS, EQS) = eqPreds-step2(M, OPDS, EQS) .
    eq eqPreds-step2(M, (op F : TYL -> TY [ ATS ] .) OPDS, EQS) = eqPreds-step2(M, OPDS, EQS eqPreds-step2'(M, (op F : TYL -> TY [ ATS ] .), OPDS, assoc in ATS, comm in ATS)) [ owise ] .

    op eqPreds-step2' : Module KindSet EquationSet -> EquationSet .
    eq eqPreds-step2'(M, none, EQS) = EQS .
    eq eqPreds-step2'(M, '`[NuITP-Bool`] ; KS, EQS) = eqPreds-step2'(M, KS, EQS) .
    eq eqPreds-step2'(M, K ; KS, EQS) = eqPreds-step2'(M, KS, EQS 
        renameVars((eq '_=_[fresh("NuITP-AUX0-", maximalSorts(M, K)), fresh("NuITP-AUX0-", maximalSorts(M, K))] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[fresh("NuITP-AUX0-", maximalSorts(M, K)), fresh("NuITP-AUX0-", maximalSorts(M, K))] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[fresh("NuITP-AUX0-", maximalSorts(M, K)), fresh("NuITP-AUX0-", maximalSorts(M, K))] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
    ) [ owise ] .

    op eqPreds-step2' : Module OpDecl OpDeclSet Bool Bool -> EquationSet .
    eq eqPreds-step2'(M, (op F : nil -> TY [ ATS ] .), OPDS, false, false) = eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), OPDS, false, none) . --- Free, arity = 0
    eq eqPreds-step2'(M, (op F : TYL -> TY [ ATS ] .), OPDS, false, false) = --- Free, arity > 0
        --- Other
        eqPreds-step2Other(M, (op F : TYL -> TY [ ATS ] .), OPDS, false, none)
        --- Itself
        renameVars((eq '_=_[F[fresh("NuITP-AUX1-", TYL, 0)], F[fresh("NuITP-AUX2-", TYL, 0)]] = eqPreds-step2ItselfFree('NuITP-Eq, fresh("NuITP-AUX1-", TYL, 0), fresh("NuITP-AUX2-", TYL, 0), empty) [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1-", TYL, 0)], F[fresh("NuITP-AUX2-", TYL, 0)]] = eqPreds-step2ItselfFree('NuITP-Rl, fresh("NuITP-AUX1-", TYL, 0), fresh("NuITP-AUX2-", TYL, 0), empty) [ metadata("eqpred") ] .), "EQ")
        --- Each
        renameVars(eqPreds-step2EachFree(M, F[fresh("NuITP-AUX0-", TYL, 0)], fresh("NuITP-AUX0-", TYL, 0), none), "EQ")
        [ owise ] .

    eq eqPreds-step2'(M, (op F : TY TY -> TY' [ ATS ] .), OPDS, false, true) = --- C
        --- Other
        eqPreds-step2Other(M, (op F : TY TY -> TY' [ ATS ] .), OPDS, false, none)
        --- Itself
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX2", TY)], F[fresh("NuITP-AUX3", TY), fresh("NuITP-AUX4", TY)]] = '_\/_['_/\_['_=_[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX3", TY)], '_=_[fresh("NuITP-AUX2", TY), fresh("NuITP-AUX4", TY)]], '_/\_['_=_[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX4", TY)], '_=_[fresh("NuITP-AUX2", TY), fresh("NuITP-AUX3", TY)]]] [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX2", TY)], F[fresh("NuITP-AUX3", TY), fresh("NuITP-AUX4", TY)]] = '_\/_['_/\_['_=>_[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX3", TY)], '_=>_[fresh("NuITP-AUX2", TY), fresh("NuITP-AUX4", TY)]], '_/\_['_=>_[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX4", TY)], '_=>_[fresh("NuITP-AUX2", TY), fresh("NuITP-AUX3", TY)]]] [ metadata("eqpred") ] .), "EQ")
        --- and
        if (sameKind(M, TY, TY'))
        then
            renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX2", TY)], fresh("NuITP-AUX1", TY)] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY), fresh("NuITP-AUX2", TY)], fresh("NuITP-AUX1", TY)] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        else none
        fi
        .

    eq eqPreds-step2'(M, (op F : TY TY' -> TY'' [ ATS ] .), OPDS, true, false) = --- A
        --- Itself
        renameVars((eq qid("eq-root-" + safeString(F))[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        --- Other
        eqPreds-step2Other(M, (op F : TY TY' -> TY'' [ ATS ] .), OPDS, true, none)
        --- Itself (2)
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX4", TY'')]] = '_=_[fresh("NuITP-AUX2", TY''), fresh("NuITP-AUX4", TY'')] [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX4", TY'')]] = '_=>_[fresh("NuITP-AUX2", TY''), fresh("NuITP-AUX4", TY'')] [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX2", TY'')]] = '_=_[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX3", TY'')] [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX2", TY'')]] = '_=>_[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX3", TY'')] [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX4", TY'')]] = 'false.NuITP-Bool if qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')] = 'true.NuITP-Bool /\ qid("eq-root-" + safeString(F))[fresh("NuITP-AUX3", TY'')] = 'true.NuITP-Bool /\ '_=_[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX3", TY'')] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX4", TY'')]] = 'false.NuITP-Bool if qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')] = 'true.NuITP-Bool /\ qid("eq-root-" + safeString(F))[fresh("NuITP-AUX3", TY'')] = 'true.NuITP-Bool /\ '_=_[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX3", TY'')] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        --- Each
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], fresh("NuITP-AUX1", TY'')] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], fresh("NuITP-AUX1", TY'')] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], fresh("NuITP-AUX2", TY'')] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], fresh("NuITP-AUX2", TY'')] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        .


    eq eqPreds-step2'(M, (op F : TY TY' -> TY'' [ ATS ] .), OPDS, true, true) = --- AC
        --- Itself (1)
        renameVars((eq qid("eq-root-" + safeString(F))[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        --- Other
        eqPreds-step2Other(M, (op F : TY TY' -> TY'' [ ATS ] .), OPDS, true, none)
        --- Itself (2)
        renameVars((ceq qid("eq-in-" + safeString(F))[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", getKind(M, TY''))] = 'false.NuITP-Bool if qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq qid("eq-in-" + safeString(F))[fresh("NuITP-AUX1", TY''), F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')]] = 'true.NuITP-Bool if 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq qid("eq-in-" + safeString(F))[fresh("NuITP-AUX", getKind(M, TY'')), F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')]] = '_\/_['_=_[fresh("NuITP-AUX", getKind(M, TY'')), fresh("NuITP-AUX1", TY'')], qid("eq-in-" + safeString(F))[fresh("NuITP-AUX", getKind(M, TY'')), fresh("NuITP-AUX2", TY'')]] if 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX", getKind(M, TY''))]] = 'true.NuITP-Bool /\ 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq qid("eq-in-" + safeString(F))[fresh("NuITP-AUX1", getKind(M, TY'')), fresh("NuITP-AUX2", getKind(M, TY''))] = '_=_[fresh("NuITP-AUX1", getKind(M, TY'')), fresh("NuITP-AUX2", getKind(M, TY''))] if 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", getKind(M, TY''))]] = 'true.NuITP-Bool /\ 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX2", getKind(M, TY''))]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        --- and (1)
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX4", TY'')]] = '_=_[fresh("NuITP-AUX2", TY''), fresh("NuITP-AUX4", TY'')] [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX4", TY'')]] = '_=>_[fresh("NuITP-AUX2", TY''), fresh("NuITP-AUX4", TY'')] [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX4", TY'')]] = 'false.NuITP-Bool if 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')]] = 'true.NuITP-Bool /\ 'not_[qid("eq-in-" + safeString(F))[fresh("NuITP-AUX1", TY''), F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX4", TY'')]]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((ceq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX4", TY'')]] = 'false.NuITP-Bool if 'not_[qid("eq-root-" + safeString(F))[fresh("NuITP-AUX1", TY'')]] = 'true.NuITP-Bool /\ 'not_[qid("eq-in-" + safeString(F))[fresh("NuITP-AUX1", TY''), F[fresh("NuITP-AUX3", TY''), fresh("NuITP-AUX4", TY'')]]] = 'true.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        --- and (2)
        renameVars((eq '_=_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], fresh("NuITP-AUX1", TY'')] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        renameVars((eq '_=>_[F[fresh("NuITP-AUX1", TY''), fresh("NuITP-AUX2", TY'')], fresh("NuITP-AUX1", TY'')] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
        .

    op eqPreds-step2Other : Module OpDecl OpDeclSet Bool EquationSet -> EquationSet .
    eq eqPreds-step2Other(M, (op F : TYL -> TY [ ATS ] .), none, B, EQS) = EQS .
    eq eqPreds-step2Other(M, (op F : TYL -> TY [ ATS ] .), (op F : TYL' -> TY' [ ATS' ] .) OPDS, B, EQS) = eqPreds-step2Other(M, (op F : TYL -> TY [ ATS ] .), OPDS, B, EQS) .
    eq eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), (op F' : nil -> TY' [ ATS' ] .) OPDS, B, EQS) =
        if (sameKind(M, TY, TY'))
        then eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), OPDS, B, EQS 
            renameVars((eq '_=_[qid(string(F) + "." + string(TY)), qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            renameVars((eq '_=>_[qid(string(F) + "." + string(TY)), qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            )
        else eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), OPDS, B, EQS)
        fi [ owise ] .
    eq eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), (op F' : NeTYL -> TY' [ ATS' ] .) OPDS, B, EQS) =
        if (sameKind(M, TY, TY'))
        then eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), OPDS, B, EQS 
            renameVars((eq '_=_[qid(string(F) + "." + string(TY)), F'[fresh("NuITP-AUX2-", NeTYL, 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            renameVars((eq '_=>_[qid(string(F) + "." + string(TY)), F'[fresh("NuITP-AUX2-", NeTYL, 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            )
        else eqPreds-step2Other(M, (op F : nil -> TY [ ATS ] .), OPDS, B, EQS)
        fi [ owise ] .
    eq eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), (op F' : nil -> TY' [ ATS' ] .) OPDS, B, EQS) =
        if (sameKind(M, TY, TY'))
        then
            if (B) --- A, AC
            then eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), OPDS, B, EQS 
                renameVars((eq qid("eq-root-" + safeString(F))[qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
                renameVars((eq '_=_[F[fresh("NuITP-AUX1-", NeTYL, 0)], qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
                renameVars((eq '_=>_[F[fresh("NuITP-AUX1-", NeTYL, 0)], qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            )
            else eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), OPDS, B, EQS 
                renameVars((eq '_=_[F[fresh("NuITP-AUX1-", NeTYL, 0)], qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
                renameVars((eq '_=>_[F[fresh("NuITP-AUX1-", NeTYL, 0)], qid(string(F') + "." + string(TY'))] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            )
            fi
        else eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), OPDS, B, EQS)
        fi [ owise ] .
    eq eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), (op F' : NeTYL' -> TY' [ ATS' ] .) OPDS, B, EQS) =
        if (sameKind(M, TY, TY'))
        then
            if (B) --- A, AC
            then eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), OPDS, B, EQS 
                renameVars((eq qid("eq-root-" + safeString(F))[F'[fresh("NuITP-AUX0-", NeTYL', 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
                renameVars((eq '_=_[F[fresh("NuITP-AUX1-", NeTYL, 0)], F'[fresh("NuITP-AUX2-", NeTYL', 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
                renameVars((eq '_=>_[F[fresh("NuITP-AUX1-", NeTYL, 0)], F'[fresh("NuITP-AUX2-", NeTYL', 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            )
            else eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), OPDS, B, EQS 
                renameVars((eq '_=_[F[fresh("NuITP-AUX1-", NeTYL, 0)], F'[fresh("NuITP-AUX2-", NeTYL', 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
                renameVars((eq '_=>_[F[fresh("NuITP-AUX1-", NeTYL, 0)], F'[fresh("NuITP-AUX2-", NeTYL', 0)]] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ")
            )
            fi
        else eqPreds-step2Other(M, (op F : NeTYL -> TY [ ATS ] .), OPDS, B, EQS)
        fi [ owise ] .

    op eqPreds-step2ItselfFree : Qid TermList TermList TermList -> Term .
    eq eqPreds-step2ItselfFree(Q, empty, empty, T) = T .
    eq eqPreds-step2ItselfFree(Q, empty, empty, TL) = '_/\_[TL] [ owise ] .
    eq eqPreds-step2ItselfFree('NuITP-Eq, (T1, TL1), (T2, TL2), TL) = eqPreds-step2ItselfFree('NuITP-Eq, TL1, TL2, (TL, ('_=_[T1, T2]))) .
    eq eqPreds-step2ItselfFree('NuITP-Rl, (T1, TL1), (T2, TL2), TL) = eqPreds-step2ItselfFree('NuITP-Rl, TL1, TL2, (TL, ('_=>_[T1, T2]))) .

    op eqPreds-step2EachFree : Module Term TermList EquationSet -> EquationSet .
    eq eqPreds-step2EachFree(M, T, empty, EQS) = EQS .
    eq eqPreds-step2EachFree(M, T, (T', TL), EQS) = eqPreds-step2EachFree(M, T, TL, EQS if (sameKind(M, getType(metaReduce(M, T)), getType(metaReduce(M, T')))) then renameVars((eq '_=_[T, T'] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ") renameVars((eq '_=>_[T, T'] = 'false.NuITP-Bool [ metadata("eqpred") ] .), "EQ") else none fi) .
endfm

fmod NuITP-SKOLEM is
    pr NuITP-UTILS .

    var M : Module .
    var F : Qid .
    var V : Variable .
    vars C C' : Constant .
    var T : Term .
    var TL : TermList .
    var TS SKO HPS : TermSet .
    var NTS : NeTermSet .
    var NTL : NeTermList .
    var NCTL : NeCTermList .
    var SB : Substitution .
    var CO : Context .

    op freeze : Substitution -> Substitution .
    op freeze : TermSet -> TermSet .
    op freeze : TermList -> TermList .
    op freeze : Term -> Term .
    eq freeze((none).Substitution) = none .
    eq freeze((mt).TermSet) = mt .
    eq freeze(empty) = empty .
    eq freeze(C) = C .
    eq freeze(V) = qid(string(getName(V)) + "." + string(getType(V))) .
    eq freeze(F[NTL]) = F[freeze(NTL)] .
    eq freeze((T,NTL)) = (freeze(T),freeze(NTL)) .
    eq freeze(T ;; NTS) = freeze(T) ;; freeze(NTS) .
    eq freeze(V <- T ; SB) = (V <- freeze(T)) ; freeze(SB) .

    op freeze : NeCTermList -> NeCTermList .
    op freeze : Context -> Context .
    eq freeze([]) = [] .
    eq freeze(F[NCTL]) = F[freeze(NCTL)] .
    eq freeze((T,NCTL)) = freeze(T), freeze(NCTL) .
    eq freeze((CO,NTL)) = freeze(CO), freeze(NTL) .

    op freeze : Substitution TermSet -> Substitution .
    op freeze : TermSet TermSet -> TermSet .
    op freeze : TermList TermSet -> TermList .
    op freeze : Term TermSet -> Term .
    eq freeze((none).Substitution, SKO) = none .
    eq freeze((mt).TermSet, SKO) = mt .
    eq freeze(empty, SKO) = empty .
    eq freeze(C, SKO) = C .
    eq freeze(V, SKO) = if (V in SKO) or-else (freeze(V) in SKO) then qid(string(getName(V)) + "." + string(getType(V))) else V fi .
    eq freeze(F[NTL], SKO) = F[freeze(NTL, SKO)] .
    eq freeze((T,NTL), SKO) = (freeze(T, SKO),freeze(NTL, SKO)) .
    eq freeze(T ;; NTS, SKO) = freeze(T, SKO) ;; freeze(NTS, SKO) .
    eq freeze(V <- T ; SB, SKO) = (V <- freeze(T, SKO)) ; freeze(SB, SKO) .

    op freeze : NeCTermList TermSet -> NeCTermList .
    op freeze : Context TermSet -> Context .
    eq freeze(CO, mt) = CO .
    eq freeze([], SKO) = [] .
    eq freeze(F[NCTL], SKO) = F[freeze(NCTL, SKO)] .
    eq freeze((T,NCTL), SKO) = freeze(T, SKO), freeze(NCTL, SKO) .
    eq freeze((CO,NTL), SKO) = freeze(CO, SKO), freeze(NTL, SKO) .

    op unfreeze : Substitution -> Substitution .
    op unfreeze : TermSet -> TermSet .
    op unfreeze : TermList -> TermList .
    op unfreeze : Term -> Term .
    eq unfreeze((none).Substitution) = none .
    eq unfreeze((mt).TermSet) = mt .
    eq unfreeze(empty) = empty .
    eq unfreeze(C) = if startsWith(string(C), "$") then qid(string(getName(C)) + ":" + string(getType(C))) else C fi .
    eq unfreeze(V) = V .
    eq unfreeze(F[NTL]) = F[unfreeze(NTL)] .
    eq unfreeze((T,NTL)) = (unfreeze(T),unfreeze(NTL)) .
    eq unfreeze(T ;; NTS) = unfreeze(T) ;; unfreeze(NTS) .
    eq unfreeze(V <- T ; SB) = (V <- unfreeze(T)) ; unfreeze(SB) .

    op unfreeze : NeCTermList -> NeCTermList .
    op unfreeze : Context -> Context .
    eq unfreeze([]) = [] .
    eq unfreeze(F[NCTL]) = F[unfreeze(NCTL)] .
    eq unfreeze((T,NCTL)) = unfreeze(T), unfreeze(NCTL) .
    eq unfreeze((CO,NTL)) = unfreeze(CO), unfreeze(NTL) .

    op unfreeze : Substitution TermSet -> Substitution .
    op unfreeze : TermSet TermSet -> TermSet .
    op unfreeze : TermList TermSet -> TermList .
    op unfreeze : Term TermSet -> Term .
    eq unfreeze((none).Substitution, SKO) = none .
    eq unfreeze(TS, mt) = TS .
    eq unfreeze(TL, mt) = TL .
    eq unfreeze((mt).TermSet, SKO) = mt .
    eq unfreeze(empty, SKO) = empty .
    eq unfreeze(C, SKO) = if (C in SKO) or-else (qid(string(getName(C)) + ":" + string(getType(C))) in SKO) then qid(string(getName(C)) + ":" + string(getType(C))) else C fi .
    eq unfreeze(V, SKO) = V .
    eq unfreeze(F[NTL], SKO) = F[unfreeze(NTL, SKO)] .
    eq unfreeze((T ;; NTS), SKO) = unfreeze(T, SKO) ;; unfreeze(NTS, SKO) .
    eq unfreeze((T,NTL), SKO) = unfreeze(T, SKO), unfreeze(NTL, SKO) .
    eq unfreeze(T, SKO) = T [ owise ] .
    eq unfreeze(V <- T ; SB, SKO) = (V <- unfreeze(T, SKO)) ; unfreeze(SB, SKO) .

    op unfreeze : NeCTermList TermSet -> NeCTermList .
    op unfreeze : Context TermSet -> Context .
    eq unfreeze(CO, mt) = CO .
    eq unfreeze([], SKO) = [] .
    eq unfreeze(F[NCTL], SKO) = F[unfreeze(NCTL, SKO)] .
    eq unfreeze((T,NCTL), SKO) = unfreeze(T, SKO), unfreeze(NCTL, SKO) .
    eq unfreeze((CO,NTL), SKO) = unfreeze(CO, SKO), unfreeze(NTL, SKO) .

    op getSkolem : TermList TermSet -> TermSet .
    eq getSkolem(C, C ;; SKO) = C .
    eq getSkolem(F[NTL], SKO) = getSkolem(NTL, SKO) .
    eq getSkolem((T,NTL), SKO) = getSkolem(T, SKO) ;; getSkolem(NTL, SKO) .
    eq getSkolem(TL, SKO) = mt [ owise ] .
    
    op getSkolemAsVars : TermList TermSet -> TermSet .
    eq getSkolemAsVars(C, C ;; SKO) = qid(string(getName(C)) + ":" + string(getType(C))) .
    eq getSkolemAsVars(F[NTL], SKO) = getSkolemAsVars(NTL, SKO) .
    eq getSkolemAsVars((T,NTL), SKO) = getSkolemAsVars(T, SKO) ;; getSkolemAsVars(NTL, SKO) .
    eq getSkolemAsVars(T, SKO) = mt [ owise ] .

    op removeSkolem : TermSet TermSet -> TermSet .
    eq removeSkolem(mt, SKO) = mt .
    eq removeSkolem(HPS, mt) = HPS .
    ceq removeSkolem(T ;; HPS, SKO) = removeSkolem(HPS, SKO)
        if getSkolem(T, SKO) =/= mt .
    eq removeSkolem(HPS, SKO) = HPS [ owise ] .

    op isNarrowex : Module Term -> Bool .
    eq isNarrowex(M, F[NTL]) = not(isOmega?(M, unfreeze(F[NTL]))) and-then isOmega?(M, unfreeze(NTL)) and-then metaNarrowingApply(M, F[NTL], empty,'#, none, 0) :: NarrowingApplyResult .
    eq isNarrowex(M, T) = false [ owise ] .
endfm

--------------------------------------------------------------------------------
---                     The following AAC-RPO code is a minimal, adapted version
---                                       of the original AAC-RPO implemented by
---                          Raúl Gutiérrez <raguti@upv.es> <r.gutierrez@upm.es>
--------------------------------------------------------------------------------

fmod NuITP-AAC-RPO is
    pr CONVERSION .
    pr META-LEVEL .
    pr STRING-OPS .

    sorts StringMap StringMapList .
    subsort StringMap < StringMapList .

    sorts NatOpDecl NatOpDeclList .
    subsort NatOpDecl < NatOpDeclList .

    sorts KindOpDeclSet KindOpDeclSetSet NEKindOpDeclSetSet .
    sorts EKindOpDeclSet EKindOpDeclSetSet NEEKindOpDeclSetSet .

    subsorts KindOpDeclSet < NEKindOpDeclSetSet < KindOpDeclSetSet  .
    subsorts EKindOpDeclSet < NEEKindOpDeclSetSet < EKindOpDeclSetSet .

    op _::_ : Kind OpDeclSet -> KindOpDeclSet [ ctor ] .
    op none : -> KindOpDeclSetSet [ ctor ] .
    op __ : NEKindOpDeclSetSet NEKindOpDeclSetSet -> NEKindOpDeclSetSet [ ctor assoc comm id: none ] .
    op __ : KindOpDeclSetSet KindOpDeclSetSet -> KindOpDeclSetSet [ assoc comm id: none ] .
    op _[_]::_ : Type TypeList OpDeclSet -> EKindOpDeclSet [ ctor ] .
    op none : -> EKindOpDeclSetSet [ ctor ] .
    op __ : NEEKindOpDeclSetSet NEEKindOpDeclSetSet -> NEEKindOpDeclSetSet [ ctor assoc comm id: none ] .
    op __ : EKindOpDeclSetSet EKindOpDeclSetSet -> EKindOpDeclSetSet [ assoc comm id: none ] .

    op ((_,_)) : Nat OpDecl -> NatOpDecl [ ctor ] .
    op nil : -> NatOpDeclList [ ctor ] .
    op __ : NatOpDeclList NatOpDeclList -> NatOpDeclList [ ctor assoc id: nil ] .

    var M : Module .
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    vars OPDS OPDS1 OPDS2 : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .

    vars T T1 T2 : Term .
    vars OPD OPD1 OPD2 : OpDecl .
    vars ATS ATS1 ATS2 : AttrSet .

    var B : Bool .
    var K : Kind .
    vars F F1 F2 : Qid .
    vars TY TY1 TY2 TY3 TYI1 TYI2 : Type .
    vars TYL TYL1 TYL2 TYL3 : TypeList .

    vars N N1 N2 : Nat .
    vars STR STR' STR'' : String .
    var SML : StringMapList .

    vars NOPD1 NOPD2 : NatOpDecl .
    vars NOPDL NOPDL1 NOPDL2 : NatOpDeclList .
    var KOPDS  : KindOpDeclSetSet .
    var EKOPDS : EKindOpDeclSetSet .

    op [_,_] : String String -> StringMap [ ctor ] .
    op empty : -> StringMapList [ ctor ] .
    op __ : StringMapList StringMapList -> StringMapList [ ctor assoc id: empty ] .

    op sort : NatOpDeclList -> NatOpDeclList .
    eq sort(NOPDL) = sort(NOPDL, nil, 0) .
    
    op sort : NatOpDeclList NatOpDeclList Nat -> NatOpDeclList .
    eq sort(nil, NOPDL, N) = NOPDL .
    eq sort(NOPDL1 (( N, OPD1 )) NOPDL2, NOPDL, N) = sort(NOPDL1 NOPDL2, NOPDL (( N, OPD1 )), N) .
    eq sort((( N1, OPD1 )) NOPDL2, NOPDL, N2) = sort((( N1, OPD1 )) NOPDL2, NOPDL, s(N2))  [ owise ] .
    
    op replace : String String String -> String .
    eq replace(STR, STR', STR'') = replace(STR, STR', STR'', find(STR, STR', 0)) .

    op replace : String String String FindResult -> String .
    eq replace(STR, STR', STR'', notFound) = STR .
    eq replace(STR, STR', STR'', N) = substr(STR, 0, N) + STR'' + replace(substr(STR, N + length(STR'), length(STR)), STR', STR'') .

    op replaceAll : String StringMapList -> String .
    eq replaceAll(STR, empty) = STR .
    eq replaceAll(STR, [ STR' , STR'' ] SML) = replaceAll(replace(STR, STR', STR''), SML) .

    op alpha : String -> String .
    eq alpha(STR) = replaceAll(STR, [ "_" , "" ] [ "`," , "comma" ] [ "`[" , "lbracket" ] [ "`]" , "rbracket" ] [ "`(" , "lparen" ] [ "`)" , "rparen" ] [ "`{" , "lbrace" ] [ "`}" , "rbrace" ]) .

    op isCommSameKind : Module OpDecl -> Bool .
    eq isCommSameKind(M, (op F : TY1 TY2 -> TY [ comm ATS ] .)) = sameKind(M, TY1, TY) .
    eq isCommSameKind(M, OPD) = false [ owise ] .

    op isComm : AttrSet -> Bool .
    eq isComm(comm ATS) = true .
    eq isComm(ATS) = false [ owise ] .

    op isAssoc : AttrSet -> Bool .
    eq isAssoc(assoc ATS) = true .
    eq isAssoc(ATS) = false [ owise ] .

    op removeCtor : AttrSet -> AttrSet .
    eq removeCtor(ctor ATS) = ATS .
    eq removeCtor(ATS) = ATS [ owise ] .

    op constrTerm : Module OpDecl Nat -> Term .
    eq constrTerm(M, (op F : nil -> TY [ ATS ] .), N) = qid(alpha(string(F)) + "." + string(TY)) .
    eq constrTerm(M, (op F : TY1 TYL -> TY2 [ ATS ] .), N) = F[listVars(M, TY1 TYL, N)] .

    op constrToACTerm : Module OpDecl Nat -> Term .
    eq constrToACTerm(M, (op F : nil -> TY [ ATS ] .), N) = qid(alpha(string(F)) + "." + string(TY)) .
    eq constrToACTerm(M, (op F : TY1 TYL -> TY2 [ ATS ] .), N) =
        if isAssoc(ATS) xor isCommSameKind(M, (op F : TY1 TYL -> TY2 [ ATS ] .))
        then qid(string(F) + "^AC")[toAClistVars(M, TY1 TYL, N)]
        else F[toAClistVars(M, TY1 TYL, N)]
        fi .

    op constrToACTermConds : Module OpDecl Term Nat -> EqCondition .
    eq constrToACTermConds(M, (op F : TY1 TYL -> TY2 [ ATS ] .),T, N) = toAClistVarConds(M, TY1 TYL,T,N) .

    op toAClistVarConds : Module TypeList Term Nat -> EqCondition .
    eq toAClistVarConds(M, TY nil, T, N) = '_=/=_[qid("V#" + string(s N,10) + ":" + string(getKind(M,TY))),T] =  'true.OBool .
    eq toAClistVarConds(M, TY TYL, T, N) = '_=/=_[qid("V#" + string(s N,10) + ":" + string(getKind(M,TY))),T] =  'true.OBool /\ toAClistVarConds(M, TYL, T, s N) [ owise ] .

    op listVars : Module TypeList Nat -> TermList .
    eq listVars(M, TY nil, N) = qid("V#" + string(s N,10) + ":" + string(getKind(M,TY))) .
    eq listVars(M, TY TYL, N) = qid("V#" + string(s N,10) + ":" + string(getKind(M,TY))) , listVars(M, TYL, s N) [ owise ] .

    op toAClistVars : Module TypeList Nat -> TermList .
    eq toAClistVars(M, TY nil, N) = 'toAC[qid("V#" + string(s N,10) + ":" + string(getKind(M,TY)))] .
    eq toAClistVars(M, TY TYL, N) = 'toAC[qid("V#" + string(s N,10) + ":" + string(getKind(M,TY)))] , toAClistVars(M, TYL, s N) [ owise ] .

    op typeListLength : TypeList -> Nat .
    eq typeListLength(nil) = 0 .
    eq typeListLength(TY TYL) = s typeListLength(TYL) .

    op fromTypeListToString : TypeList -> String .
    eq fromTypeListToString(nil) = "" .
    eq fromTypeListToString(TY TYL) = string(TY) + fromTypeListToString(TYL) .

    op setTopSort : TypeList -> Type .
    eq setTopSort(TY)  = TY .
    eq setTopSort(TYL) = qid(fromTypeListToString(TYL)) [ owise ] .

    op newTopSorts : EKindOpDeclSetSet -> SortSet .
    eq newTopSorts((none).EKindOpDeclSetSet) = (none).SortSet .
    eq newTopSorts((TY [ TY ] :: OPDS) EKOPDS) = newTopSorts(EKOPDS) .
    eq newTopSorts((TY [ TYL ] :: OPDS) EKOPDS) = TY ; newTopSorts(EKOPDS) [ owise ] .

    op newSubsorts : EKindOpDeclSetSet -> SubsortDeclSet .
    eq newSubsorts((none).EKindOpDeclSetSet) = (none).SubsortDeclSet .
    eq newSubsorts((TY [ nil ] :: OPDS) EKOPDS) = newSubsorts(EKOPDS) .
    eq newSubsorts((TY1 [ TY2 TYL ] :: OPDS) EKOPDS) =
        if (TY1 == TY2)
        then newSubsorts((TY1 [ TYL ] :: OPDS) EKOPDS)
        else (subsort TY2 < TY1 .) newSubsorts((TY1 [ TYL ] :: OPDS) EKOPDS)
        fi .

    op processKinds : KindOpDeclSetSet -> EKindOpDeclSetSet .
    eq processKinds((none).KindOpDeclSetSet) = (none).EKindOpDeclSetSet .
    eq processKinds((K :: OPDS) KOPDS) = (setTopSort(extractTypes(string(K))) [ extractTypes(string(K)) ] :: OPDS) processKinds(KOPDS) .

    op extractTypes : String -> TypeList .
    eq extractTypes(STR) =
        if startsWith(STR, "`[")
        then extractTypes(substr(STR,2, length(STR)))
        else
            if (find(STR,"`,",0) =/= notFound)
            then (qid(substr(STR,0,find(STR,"`,",0))) extractTypes(substr(STR,find(STR,"`,",0) + 2, length(STR))))
            else qid(substr(STR,0,find(STR,"`]",0)))
            fi
        fi .

    op toKind : Module TypeList -> TypeList .
    eq toKind(M, (nil).TypeList) = (nil).TypeList .
    eq toKind(M, TY) = getKind(M,TY) .
    eq toKind(M, TY TYL) = getKind(M,TY) toKind(M,TYL) [ owise ] .

    op getOpsByKind : Module KindOpDeclSetSet OpDeclSet -> KindOpDeclSetSet .
    eq getOpsByKind(M, KOPDS, (none).OpDeclSet) = KOPDS .
    eq getOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS special(NeHL:NeHookList) ] .) OPDS) = getOpsByKind(M, KOPDS, OPDS) .
    eq getOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS poly(NeNL:NeNatList) ] .) OPDS) = getOpsByKind(M, KOPDS, OPDS) .
    eq getOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS) = getOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS, getKind(M, TY)) [ owise ] .

    op getOpsByKind : Module KindOpDeclSetSet OpDeclSet Kind -> KindOpDeclSetSet .
    eq getOpsByKind(M, (K :: OPDS1) KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS2, K) = getOpsByKind(M, (K :: (OPDS1 (op F : TYL -> TY [ ATS ] .))) KOPDS, OPDS2) .
    eq getOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS, K) = getOpsByKind(M, createKindSet(K, (op F : TYL -> TY [ ATS ] .)) KOPDS, OPDS) [ owise ] .

    op getEOpsByKind : Module KindOpDeclSetSet OpDeclSet -> KindOpDeclSetSet .
    eq getEOpsByKind(M, KOPDS, (none).OpDeclSet) = KOPDS .
    eq getEOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS special(NeHL:NeHookList) ] .) OPDS) = getEOpsByKind(M, KOPDS, OPDS) .
    eq getEOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS poly(NeNL:NeNatList) ] .) OPDS) = getEOpsByKind(M, KOPDS, OPDS) .
    eq getEOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS) = getEOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS, getKind(M, TY)) [ owise ] .

    op getEOpsByKind : Module KindOpDeclSetSet OpDeclSet Kind -> KindOpDeclSetSet .
    eq getEOpsByKind(M, (K :: OPDS1) KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS2, K) =
        if isAssoc(ATS) xor isCommSameKind(M, (op F : TYL -> TY [ ATS ] .))
        then getEOpsByKind(M, (K :: (OPDS1 (op F : TYL -> TY [ ATS ] .) (op qid(string(F) + "^AC") : toKind(M,TYL) -> TY [ assoc comm removeCtor(ATS) ] .))) KOPDS, OPDS2)
        else getEOpsByKind(M, (K :: (OPDS1 (op F : TYL -> TY [ ATS ] .))) KOPDS, OPDS2)
        fi .
    eq getEOpsByKind(M, KOPDS, (op F : TYL -> TY [ ATS ] .) OPDS, K) =
        if isAssoc(ATS) xor isCommSameKind(M, (op F : TYL -> TY [ ATS ] .))
        then getEOpsByKind(M, createKindSet(K, (op F : TYL -> TY [ ATS ] .) (op qid(string(F) + "^AC") : toKind(M,TYL) -> TY [ assoc comm removeCtor(ATS) ] .)) KOPDS, OPDS)
        else getEOpsByKind(M, createKindSet(K, (op F : TYL -> TY [ ATS ] .)) KOPDS, OPDS)
        fi [ owise ] .

    op createKindSet : Kind OpDeclSet -> KindOpDeclSetSet .
    eq createKindSet(K, OPDS) = (K :: OPDS) .

    op constrWrapList : Module TypeList Nat -> Term .
    eq constrWrapList(M, nil, N) = 'nil.OWrapList .
    eq constrWrapList(M, TY TYL, N) = '__['`[`[_`]`][qid("V#" + string(N,10) + ":" + string(getKind(M,TY)))],constrWrapList(M, TYL, s N)] .

    op constrWrapSet : Module TypeList Nat -> Term .
    eq constrWrapSet(M, nil, N) = 'empty.OWrapSet .
    eq constrWrapSet(M, TY TYL, N) = '_`,_['`[`[_`]`][qid("V#" + string(N,10) + ":" + string(getKind(M,TY)))],constrWrapSet(M, TYL, s N)] .

    op mountEmbSmall4 : Module OpDecl OpDecl TypeList Nat -> Term .
    eq mountEmbSmall4(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .), (nil).TypeList,N) = qid("embSmall4-" + alpha(string(F1)))['_`,_['WS1:OWrapSet,'`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)]],'WS2:OWrapSet,'T:OTerm] .
    eq mountEmbSmall4(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .), TY3 TYL3, N) = '_or_['_>=v_[qid("(" + alpha(string(F1)) + ",_)")['_`,_['_`,_['WS1:OWrapSet,'`[`[_`]`][qid("V#" + string(N,10) + ":" + string(getKind(M,TY3)))]],'WS2:OWrapSet]],'T:OTerm],mountEmbSmall4(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .), TYL3, s N)] .

    op mountEmbSmall5 : Module OpDecl OpDecl TypeList Nat -> Term .
    eq mountEmbSmall5(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .), (nil).TypeList,N) = qid("embSmall5-" + alpha(string(F1)))['_`,_['WS1:OWrapSet,'`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)]],'WS2:OWrapSet,'T:OTerm] .
    eq mountEmbSmall5(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .), TY3 TYL3, N) = '_and_['_>v_['T:OTerm,qid("(" + alpha(string(F1)) + ",_)")['_`,_['_`,_['WS1:OWrapSet,'`[`[_`]`][qid("V#" + string(N,10) + ":" + string(getKind(M,TY3)))]],'WS2:OWrapSet]]],mountEmbSmall5(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .), TYL3, s N)] .

    op wrapSorts : Module SortSet -> OpDeclSet .
    eq wrapSorts(M, (none).SortSet) = none .
    eq wrapSorts(M, (TY ; SS)) = (op '`[`[_`]`] : getKind(M,TY) -> 'OWrap [ strat (0) ] .) wrapSorts(M, SS) .

    op aac-wrapSorts : Module SortSet -> OpDeclSet .
    eq aac-wrapSorts(M, (none).SortSet) = none .
    eq aac-wrapSorts(M, (TY ; SS)) = (op '`[`[_`]`] : getKind(M,TY) -> 'OWrap [ none ] .) (op 'toAC : getKind(M,TY) -> getKind(M,TY) [ none ] .) aac-wrapSorts(M,SS) .

    op wrapOps : EKindOpDeclSetSet -> OpDeclSet .
    eq wrapOps((none).EKindOpDeclSetSet) = none .
    eq wrapOps((TY [ TYL ] :: OPDS) EKOPDS) = wrapOps(OPDS) wrapOps(EKOPDS) .

    op wrapOps : OpDeclSet -> OpDeclSet .
    eq wrapOps((none).OpDeclSet) = (none).OpDeclSet .
    eq wrapOps((op F : TYL -> TY [ assoc comm ATS ] .) OPDS) =
        (op qid("(" + alpha(string(F)) + ",_)") : 'OWrapSet -> 'OTerm [ none ] .)
        (op qid("embSmall4-" + alpha(string(F))) : 'OWrapSet 'OWrapSet 'OTerm -> 'OBool [ none ] .)
        (op qid("embSmall5-" + alpha(string(F))) : 'OWrapSet 'OWrapSet 'OTerm -> 'OBool [ none ] .)
        (op qid("tf-" + alpha(string(F))) : 'OWrap -> 'OWrapSet [ none ] .)
        (op qid("noSmallHead-" + alpha(string(F))) : 'OWrapSet -> 'OWrapSet [ none ] .)
        (op qid("bigHead-" + alpha(string(F))) : 'OWrapSet 'OWrapSet -> 'OWrapSet [ none ] .)
        wrapOps(OPDS) .
    eq wrapOps((op F : TYL -> TY [ ATS ] .) OPDS) =
        (op qid("(" + alpha(string(F)) + ",_)") : 'OWrapList -> 'OTerm [ none ] .)
        wrapOps(OPDS)
        [ owise ] .

    op aac-wrapOps : EKindOpDeclSetSet -> OpDeclSet .
    eq aac-wrapOps((none).EKindOpDeclSetSet) = (none).OpDeclSet .
    eq aac-wrapOps((TY [ TYL ] :: OPDS) EKOPDS) =
        (op 'toACWrap : 'OWrap -> 'OWrap [ none ] .)
        aac-wrapOps(OPDS) aac-wrapOps(EKOPDS) .

    op aac-wrapOps : OpDeclSet -> OpDeclSet .
    eq aac-wrapOps((none).OpDeclSet) = (none).OpDeclSet .
    eq aac-wrapOps((op F : TYL -> TY [ assoc comm ATS ] .) OPDS) =
        (op qid("(" + alpha(string(F)) + ",_)") : 'OWrapSet -> 'OTerm [ none ] .)
        (op qid("embSmall4-" + alpha(string(F))) : 'OWrapSet 'OWrapSet 'OTerm -> 'OBool [ none ] .)
        (op qid("embSmall5-" + alpha(string(F))) : 'OWrapSet 'OWrapSet 'OTerm -> 'OBool [ none ] .)
        (op qid("tf-" + alpha(string(F))) : 'OWrap -> 'OWrapSet [ none ] .)
        (op qid("noSmallHead-" + alpha(string(F))) : 'OWrapSet -> 'OWrapSet [ none ] .)
        (op qid("bigHead-" + alpha(string(F))) : 'OWrapSet 'OWrapSet -> 'OWrapSet [ none ] .)
        (op qid("tf-" + alpha(string(F)) + "-set") : 'OWrap -> 'OWrapSet [ none ] .)
        aac-wrapOps(OPDS) .
    eq aac-wrapOps((op F : TYL -> TY [ ATS ] .) OPDS) =
        (op qid("(" + alpha(string(F)) + ",_)") : 'OWrapList -> 'OTerm [ none ] .)
        aac-wrapCommOps((op F : TYL -> TY [ ATS ] .),isComm(ATS))
        aac-wrapOps(OPDS)
        [ owise ] .

    op aac-wrapCommOps : OpDeclSet Bool -> OpDeclSet .
    eq aac-wrapCommOps((op F : TYL -> TY [ ATS ] .), true) = (op qid("tf-" + alpha(string(F)) + "-set") : 'OWrap -> 'OWrapSet [ none ] .) .
    eq aac-wrapCommOps((op F : TYL -> TY [ ATS ] .), false) = (op qid("tf-" + alpha(string(F)) + "-list") : 'OWrap -> 'OWrapList [ none ] .) .

    op wrapEqs : -> EquationSet .
    eq wrapEqs =
        (eq 'wrapToTerm['W:OWrap] = '`(variable`,_`)['W:OWrap] [ owise ] .)
        (eq '_>v_['`(variable`,_`)['W:OWrap],'T:OTerm] = 'false.OBool [ none ] .) .

    op aac-wrapSortEqs : Module SortSet -> EquationSet .
    eq aac-wrapSortEqs(M, (none).SortSet) = none .
    eq aac-wrapSortEqs(M, (TY ; SS)) =
        (eq 'toACWrap['`[`[_`]`][qid("V#1:" + string(getKind(M,TY)))]] = '`[`[_`]`]['toAC[qid("V#1:" + string(getKind(M,TY)))]] [ none ] .)
        (eq 'toAC[qid("V#1:" + string(getKind(M,TY)))] = qid("V#1:" + string(getKind(M,TY))) [ owise ] .)
        aac-wrapSortEqs(M, SS) .

    op aac-wrapEqs : EKindOpDeclSetSet -> EquationSet .
    eq aac-wrapEqs(none) =
        (eq 'wrapToTerm['W:OWrap] = '`(variable`,_`)['W:OWrap] [ owise ] .)
        (eq '_>v_['`(variable`,_`)['W:OWrap],'T:OTerm] = 'false.OBool [ none ] .) .
    eq aac-wrapEqs((TY [ TYL ] :: OPDS) EKOPDS) = aac-wrapEqs(EKOPDS) .

    op fromOpDeclToNatOpDecl : OpDecl -> NatOpDecl .
    ceq fromOpDeclToNatOpDecl((op F : TYL -> TY [ ATS metadata(STR) ] .)) = (rat(STR,10), (op F : TYL -> TY [ ATS metadata(STR) ] .)) if rat(STR,10) :: Nat .
    eq fromOpDeclToNatOpDecl((op F : TYL -> TY [ ATS ] .)) = (0, (op F : TYL -> TY [ ATS ] .)) [ owise ] .

    op fromOpDeclSetToNatOpDeclList : OpDeclSet -> NatOpDeclList .
    eq fromOpDeclSetToNatOpDeclList((none).OpDeclSet) = (nil).NatOpDeclList .
    eq fromOpDeclSetToNatOpDeclList((op F : TYL -> TY [ ATS special(NeHL:NeHookList) ] . OPDS)) = fromOpDeclSetToNatOpDeclList(OPDS) .
    eq fromOpDeclSetToNatOpDeclList((op F : TYL -> TY [ ATS poly(NeNL:NeNatList) ] . OPDS)) = fromOpDeclSetToNatOpDeclList(OPDS) .
    eq fromOpDeclSetToNatOpDeclList((OPD OPDS)) = fromOpDeclToNatOpDecl(OPD) fromOpDeclSetToNatOpDeclList(OPDS) [ owise ] .

    op addACOpDecl : Module OpDeclSet -> OpDeclSet .
    eq addACOpDecl(M, none) = none .
    eq addACOpDecl(M, (op F : TYL -> TY [ ATS ] .)) =
        if isAssoc(ATS) xor isCommSameKind(M, (op F : TYL -> TY [ ATS ] .))
        then ((op F : TYL -> TY [ ATS ] .) (op qid(string(F) + "^AC") : toKind(M,TYL) -> getKind(M,TY) [ assoc comm removeCtor(ATS) ] .))
        else (op F : TYL -> TY [ ATS ] .)
        fi .
    eq addACOpDecl(M, (OPD OPDS)) = addACOpDecl(M, OPD) addACOpDecl(M, OPDS) .

    op constrGreaterEqs : OpDecl -> EquationSet .
    eq constrGreaterEqs((op F : TYL -> TY [ assoc comm ATS ] .)) = (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WS:OWrapSet],'T:OTerm] = 'acrpo5-1-set['WS:OWrapSet,'T:OTerm] [ owise ] .) .
    eq constrGreaterEqs((op F : TYL -> TY [ ATS ] .)) = (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WL:OWrapList],'T:OTerm] = 'acrpo5-1-list['WL:OWrapList,'T:OTerm] [ owise ] .) [ owise ] .

    op aac-constrGreaterEqs : Module OpDecl -> EquationSet .
    eq aac-constrGreaterEqs(M, (op F : TYL -> TY [ assoc comm ATS ] .)) =
        (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WS:OWrapSet],'T:OTerm] = 'acrpo5-1-set['WS:OWrapSet,'T:OTerm] [ owise ] .)
        (eq '_>E_['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)],'W2:OWrap] = '_>v_['`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]],'toACWrap['W2:OWrap]] [ owise ] .) .
    eq aac-constrGreaterEqs(M, (op F : TYL -> TY [ ATS ] .)) =
        (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WL:OWrapList],'T:OTerm] = 'acrpo5-1-list['WL:OWrapList,'T:OTerm] [ owise ] .)
        (eq '_>E_['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)],'W2:OWrap] = '_>v_['`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]],'toACWrap['W2:OWrap]] [ owise ] .)
        [ owise ] .

    op constrSmallerEqs : OpDecl NatOpDeclList -> EquationSet .
    eq constrSmallerEqs(OPD, (nil).NatOpDeclList) = (none).EquationSet .
    eq constrSmallerEqs((op F1 : TYL1 -> TY1 [ ATS1 ] .), (N, (op F2 : TYL2 -> TY2 [ ATS2 ] .)) NOPDL) =
        if isComm(ATS1) and-then isAssoc(ATS1)
        then
            if isComm(ATS2) and-then isAssoc(ATS2)
            then (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]] = '_or_['acrpo5-1-set['WS1:OWrapSet,qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]],'acrpo5-2-set[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],'WS2:OWrapSet]] [ none ] .)
            else (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-set['WS1:OWrapSet,qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]],'acrpo5-2-list[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],'WL2:OWrapList]] [ none ] .)
            fi
        else
            if isComm(ATS2) and-then isAssoc(ATS2)
            then (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]] = '_or_['acrpo5-1-list['WL1:OWrapList,qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]],'acrpo5-2-set[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],'WS2:OWrapSet]] [ none ] .)
            else (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-list['WL1:OWrapList,qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]],'acrpo5-2-list[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],'WL2:OWrapList]] [ none ] .)
            fi
        fi
        constrSmallerEqs((op F1 : TYL1 -> TY1 [ ATS1 ] .), NOPDL) .

    op aac-constrSmallerEqs : Module OpDecl NatOpDeclList -> EquationSet .
    eq aac-constrSmallerEqs(M, OPD, (nil).NatOpDeclList) = (none).EquationSet .
    eq aac-constrSmallerEqs(M, (op F1 : TYL1 -> TY1 [ ATS1 ] .), (N, (op F2 : TYL2 -> TY2 [ ATS2 ] .)) NOPDL) =
        if isComm(ATS1) and-then isAssoc(ATS1)
        then
            if isComm(ATS2) and-then isAssoc(ATS2)
            then (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]] = '_or_['acrpo5-1-set['WS1:OWrapSet,qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]],'acrpo5-2-set[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],'WS2:OWrapSet]] [ none ] .)
            else (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-set['WS1:OWrapSet,qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]],'acrpo5-2-list[qid("(" + alpha(string(F1)) + ",_)")['WS1:OWrapSet],'WL2:OWrapList]] [ none ] .)
            fi
        else
            if isComm(ATS2) and-then isAssoc(ATS2)
            then (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]] = '_or_['acrpo5-1-list['WL1:OWrapList,qid("(" + alpha(string(F2)) + ",_)")['WS2:OWrapSet]],'acrpo5-2-set[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],'WS2:OWrapSet]] [ none ] .)
            else (eq '_>v_[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-list['WL1:OWrapList,qid("(" + alpha(string(F2)) + ",_)")['WL2:OWrapList]],'acrpo5-2-list[qid("(" + alpha(string(F1)) + ",_)")['WL1:OWrapList],'WL2:OWrapList]] [ none ] .)
            fi
        fi
        (eq '_>E_['`[`[_`]`][constrTerm(M, (op F1 : TYL1 -> TY1 [ ATS1 ] .),0)],'`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),typeListLength(TYL1))]] = '_>v_['`[`[_`]`]['toAC[constrTerm(M, (op F1 : TYL1 -> TY1 [ ATS1 ] .),0)]],'`[`[_`]`]['toAC[constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),typeListLength(TYL1))]]] [ none ] .)
        aac-constrSmallerEqs(M, (op F1 : TYL1 -> TY1 [ ATS1 ] .), NOPDL) .

    op constrEqualEqs : OpDecl -> EquationSet .
    eq constrEqualEqs((op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .)) = (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WS1:OWrapSet],qid("(" + alpha(string(F)) + ",_)")['WS2:OWrapSet]] = '_or_['acrpo5-1-set['WS1:OWrapSet,qid("(" + alpha(string(F)) + ",_)")['WS2:OWrapSet]],qid("embSmall4-" + alpha(string(F)))['empty.OWrapSet,'WS1:OWrapSet, qid("(" + alpha(string(F)) + ",_)")['WS2:OWrapSet]]] [ none ] .) .
    eq constrEqualEqs((op F : TYL -> TY [ ATS ] .)) = (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-list['WL1:OWrapList, qid("(" + alpha(string(F)) + ",_)")['WL2:OWrapList]], '_and_['_>v`{lex`}_['WL1:OWrapList,'WL2:OWrapList], 'acrpo5-2-list[qid("(" + alpha(string(F)) + ",_)")['WL1:OWrapList],'WL2:OWrapList]]] [ none ] .) [ owise ] .

    op aac-constrEqualEqs : Module OpDecl -> EquationSet .
    eq aac-constrEqualEqs(M, (op F : TYL -> TY [ comm ATS ] .)) =
        if isAssoc(ATS)
        then (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WS1:OWrapSet],qid("(" + alpha(string(F)) + ",_)")['WS2:OWrapSet]] = '_or_['acrpo5-1-set['WS1:OWrapSet,qid("(" + alpha(string(F)) + ",_)")['WS2:OWrapSet]],qid("embSmall4-" + alpha(string(F)))['empty.OWrapSet,'WS1:OWrapSet, qid("(" + alpha(string(F)) + ",_)")['WS2:OWrapSet]]] [ none ] .)
        else (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-list['WL1:OWrapList, qid("(" + alpha(string(F)) + ",_)")['WL2:OWrapList]], '_and_['_>v`{lex`}_['WL1:OWrapList,'WL2:OWrapList], 'acrpo5-2-list[qid("(" + alpha(string(F)) + ",_)")['WL1:OWrapList],'WL2:OWrapList]]] [ none ] .)
        fi
        (eq '_>E_['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),0)],'`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),typeListLength(TYL))]] = 'if_then_else_fi['_==_['_>v_['`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),0)]],'`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),typeListLength(TYL))]]],'true.OBool],'true.OBool,'if_then_else_fi['_==_['`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),0)]],'`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),typeListLength(TYL))]]],'_>>E_[qid("tf-" + alpha(string(F)) + "-set")['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),0)]],qid("tf-" + alpha(string(F)) + "-set")['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ comm ATS ] .),typeListLength(TYL))]]],'false.OBool]] [ none ] .) .
    eq aac-constrEqualEqs(M, (op F : TYL -> TY [ ATS ] .)) =
        (eq '_>v_[qid("(" + alpha(string(F)) + ",_)")['WL1:OWrapList],qid("(" + alpha(string(F)) + ",_)")['WL2:OWrapList]] = '_or_['acrpo5-1-list['WL1:OWrapList, qid("(" + alpha(string(F)) + ",_)")['WL2:OWrapList]], '_and_['_>v`{lex`}_['WL1:OWrapList,'WL2:OWrapList], 'acrpo5-2-list[qid("(" + alpha(string(F)) + ",_)")['WL1:OWrapList],'WL2:OWrapList]]] [ none ] .)
        (eq '_>E_['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)],'`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),typeListLength(TYL))]] = 'if_then_else_fi['_==_['_>v_['`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]],'`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),typeListLength(TYL))]]],'true.OBool],'true.OBool,'if_then_else_fi['_==_['`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]],'`[`[_`]`]['toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),typeListLength(TYL))]]],'_>E`{lex`}_[qid("tf-" + alpha(string(F)) + "-list")['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]],qid("tf-" + alpha(string(F)) + "-list")['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),typeListLength(TYL))]]],'false.OBool]] [ none ] .)
        [ owise ] .

    op aac-constrToACEqs : Module OpDecl -> EquationSet .
    eq aac-constrToACEqs(M, (op F : TYL -> TY [ id(T) ATS ] .)) = (ceq 'toAC[constrTerm(M, (op F : TYL -> TY [ id(T) ATS ] .),0)] = constrToACTerm(M, (op F : TYL -> TY [ id(T) ATS ] .),0) if constrToACTermConds(M, (op F : TYL -> TY [ id(T) ATS ] .),T,0) [ none ] .) .
    eq aac-constrToACEqs(M, (op F : TYL -> TY [ ATS ] .)) = (eq 'toAC[constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)] = constrToACTerm(M, (op F : TYL -> TY [ ATS ] .),0) [ none ] .) [ owise ] .

    op constrWrapToTermEqs : Module NatOpDeclList -> EquationSet .
    eq constrWrapToTermEqs(M, (nil).NatOpDeclList) = none .
    eq constrWrapToTermEqs(M, (N, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .)) NOPDL) =
        constrWrapToTermIdsEqs(M, (N, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .)))
        constrWrapToTermEqs(M, NOPDL) .
    eq constrWrapToTermEqs(M, (N, (op F : TYL -> TY [ ATS ] .)) NOPDL) =
        (eq 'wrapToTerm['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]] = qid("(" + alpha(string(F)) + ",_)")[constrWrapList(M, TYL,1)] [ none ] .)
        constrWrapToTermEqs(M, NOPDL)
        [ owise ] .

    op constrWrapToTermIdsEqs : Module NatOpDecl -> Equation .
    eq constrWrapToTermIdsEqs(M, (N, (op F : TYI1 TYI2 -> TY [ assoc comm id(T) ATS ] .))) =
        (ceq 'wrapToTerm['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ assoc comm id(T) ATS ] .),0)]] = qid("(" + alpha(string(F)) + ",_)")[qid("tf-" + alpha(string(F)))['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ assoc comm id(T) ATS ] .),0)]]] if constrToACTermConds(M, (op F : TYI1 TYI2 -> TY [ assoc comm id(T) ATS ] .),T,0) [ none ] .) .
    eq constrWrapToTermIdsEqs(M, (N, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .))) =
        (eq 'wrapToTerm['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .),0)]] = qid("(" + alpha(string(F)) + ",_)")[qid("tf-" + alpha(string(F)))['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .),0)]]] [ none ] .)
        [ owise ] .

    op constrWrapEqs : Module NatOpDeclList NatOpDeclList -> EquationSet .
    eq constrWrapEqs(M, NOPDL, (nil).NatOpDeclList) =
        (eq 'sharp['WS:OWrapSet,'N:ONat] = '`(_`,_`)['WS:OWrapSet,'N:ONat] [ owise ] .)
        constrWrapToTermEqs(M, NOPDL) .
    eq constrWrapEqs(M, NOPDL1, (N, (op F : TYL -> TY [ ATS ] .)) NOPDL2) =
        constrGreaterEqs((op F : TYL -> TY [ ATS ] .))
        constrSmallerEqs((op F : TYL -> TY [ ATS ] .),NOPDL1)
        constrEqualEqs((op F : TYL -> TY [ ATS ] .))
        if isComm(ATS) and-then isAssoc(ATS)
        then constrACEqs(M, (op F : TYL -> TY [ ATS ] .),NOPDL1) constrBHEqs(M, (op F : TYL -> TY [ ATS ] .),NOPDL2)
        else none
        fi
        constrSharpEqs(M, (op F : TYL -> TY [ ATS ] .))
        constrWrapEqs(M, NOPDL1 (N, (op F : TYL -> TY [ ATS ] .)), NOPDL2) .

    op aac-constrWrapEqs : Module NatOpDeclList NatOpDeclList -> EquationSet .
    eq aac-constrWrapEqs(M, NOPDL, (nil).NatOpDeclList) = (eq 'sharp['WS:OWrapSet,'N:ONat] = '`(_`,_`)['WS:OWrapSet,'N:ONat] [ owise ] .)
        constrWrapToTermEqs(M, NOPDL) .
    eq aac-constrWrapEqs(M, NOPDL1, (N, (op F : TYL -> TY [ ATS ] .)) NOPDL2) = aac-constrGreaterEqs(M, (op F : TYL -> TY [ ATS ] .))
        aac-constrSmallerEqs(M, (op F : TYL -> TY [ ATS ] .),NOPDL1)
        aac-constrEqualEqs(M, (op F : TYL -> TY [ ATS ] .))
        aac-constrToACEqs(M, (op F : TYL -> TY [ ATS ] .))
        if isComm(ATS) and-then isAssoc(ATS)
        then constrACEqs(M, (op F : TYL -> TY [ ATS ] .),NOPDL1) constrBHEqs(M, (op F : TYL -> TY [ ATS ] .),NOPDL2)
        else none
        fi
        constrSharpEqs(M, (op F : TYL -> TY [ ATS ] .))
        aac-constrtfEqs(M, (op F : TYL -> TY [ ATS ] .))
        aac-constrWrapEqs(M, NOPDL1 (N, (op F : TYL -> TY [ ATS ] .)), NOPDL2) .

    op constrACEqs : Module OpDecl NatOpDeclList -> EquationSet .
    eq constrACEqs(M, (op F : TYI1 TYI2 -> TY [ ATS ] .), (nil).NatOpDeclList) =
        constrtfACEqs(M, (op F : TYI1 TYI2 -> TY [ ATS ] .))
        (eq qid("embSmall4-" + alpha(string(F)))['WS1:OWrapSet,'WS2:OWrapSet,qid("(" + alpha(string(F)) + ",_)")['WS3:OWrapSet]] = qid("embSmall5-" + alpha(string(F)))['empty.OWrapSet,'WS3:OWrapSet,qid("(" + alpha(string(F)) + ",_)")['_`,_['WS1:OWrapSet,'WS2:OWrapSet]]] [ owise ] .)
        (eq qid("embSmall5-" + alpha(string(F)))['WS1:OWrapSet,'WS2:OWrapSet,qid("(" + alpha(string(F)) + ",_)")['WS3:OWrapSet]] = '_and_['_>>=v_[qid("noSmallHead-" + alpha(string(F)))['WS3:OWrapSet],qid("noSmallHead-" + alpha(string(F)))['_`,_['WS1:OWrapSet,'WS2:OWrapSet]]],'_or_['_>>v_[qid("bigHead-" + alpha(string(F)))['empty.OWrapSet,'WS3:OWrapSet],qid("bigHead-" + alpha(string(F)))['empty.OWrapSet,'_`,_['WS1:OWrapSet,'WS2:OWrapSet]]],'_or_['_>_['sharp['WS3:OWrapSet,'0.ONat],'sharp['_`,_['WS1:OWrapSet,'WS2:OWrapSet],'0.ONat]],'_and_['_>=_['sharp['WS3:OWrapSet,'0.ONat],'sharp['_`,_['WS1:OWrapSet,'WS2:OWrapSet],'0.ONat]],'_>>v_['WS3:OWrapSet,'_`,_['WS1:OWrapSet,'WS2:OWrapSet]]]]]] [ owise ] .)
        (eq qid("noSmallHead-" + alpha(string(F)))['WS:OWrapSet] = 'WS:OWrapSet [ owise ] .) .
    eq constrACEqs(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (N, (op F2 : TYL2 -> TY2 [ ATS2 ] .)) NOPDL) =
        (eq qid("embSmall4-" + alpha(string(F1)))['WS1:OWrapSet,'_`,_['`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)],'WS2:OWrapSet],'T:OTerm] = mountEmbSmall4(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .),TYL2,1) [ none ] .)
        (eq qid("embSmall5-" + alpha(string(F1)))['WS1:OWrapSet,'_`,_['`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)],'WS2:OWrapSet],'T:OTerm] = mountEmbSmall5(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (op F2 : TYL2 -> TY2 [ ATS2 ] .),TYL2,1) [ none ] .)
        (eq qid("noSmallHead-" + alpha(string(F1)))['_`,_['`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)],'WS:OWrapSet]] = qid("noSmallHead-" + alpha(string(F1)))['WS:OWrapSet] [ none ] .)
        constrACEqs(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), NOPDL) .

    op constrtfACEqs : Module OpDecl -> EquationSet .
    eq constrtfACEqs(M, (op F : TYI1 TYI2 -> TY [ id(T) ATS ] .)) =
        (ceq qid("tf-" + alpha(string(F)))['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ id(T) ATS ] .),0)]] = '_`,_[qid("tf-" + alpha(string(F)))['`[`[_`]`][qid("V#" + string(1,10) + ":" + string(getKind(M,TYI1)))]],qid("tf-" + alpha(string(F)))['`[`[_`]`][qid("V#" + string(2,10) + ":" + string(getKind(M,TYI2)))]]] if constrToACTermConds(M, (op F : TYI1 TYI2 -> TY [ id(T) ATS ] .),T,0) [ none ] .)
        (eq qid("tf-" + alpha(string(F)))['W:OWrap] = 'W:OWrap [ owise ] .) .
    eq constrtfACEqs(M, (op F : TYI1 TYI2 -> TY [ ATS ] .)) =
        (eq qid("tf-" + alpha(string(F)))['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ ATS ] .),0)]] = '_`,_[qid("tf-" + alpha(string(F)))['`[`[_`]`][qid("V#" + string(1,10) + ":" + string(getKind(M,TYI1)))]],qid("tf-" + alpha(string(F)))['`[`[_`]`][qid("V#" + string(2,10) + ":" + string(getKind(M,TYI2)))]]] [ none ] .)
        (eq qid("tf-" + alpha(string(F)))['W:OWrap] = 'W:OWrap [ owise ] .)
        [ owise ] .

    op constrBHEqs : Module OpDecl NatOpDeclList -> EquationSet .
    eq constrBHEqs(M, (op F : TYI1 TYI2 -> TY [ ATS ] .), (nil).NatOpDeclList) =
        (eq qid("bigHead-" + alpha(string(F)))['WS1:OWrapSet,'WS2:OWrapSet] = 'WS1:OWrapSet [ owise ] .) .
    eq constrBHEqs(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), (N, (op F2 : TYL2 -> TY2 [ ATS2 ] .)) NOPDL) =
        (eq qid("bigHead-" + alpha(string(F1)))['WS1:OWrapSet,'_`,_['`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)],'WS2:OWrapSet]] = qid("bigHead-" + alpha(string(F1)))['_`,_['WS1:OWrapSet,'`[`[_`]`][constrTerm(M, (op F2 : TYL2 -> TY2 [ ATS2 ] .),0)]],'WS2:OWrapSet] [ none ] .)
        constrBHEqs(M, (op F1 : TYI1 TYI2 -> TY1 [ ATS1 ] .), NOPDL) .

    op constrSharpEqs : Module OpDecl -> EquationSet .
    eq constrSharpEqs(M, (op F : TYL -> TY [ ATS ] .)) = (eq 'sharp['_`,_['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)],'WS:OWrapSet],'N:ONat] = 'sharp['WS:OWrapSet,'s_['N:ONat]] [ none ] .) .

    op aac-constrtfEqs : Module OpDecl -> EquationSet .
    eq aac-constrtfEqs(M, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .)) =
        (eq qid("tf-" + alpha(string(F)) + "-set")['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ assoc comm ATS ] .),0)]] = '_`,_[qid("tf-" + alpha(string(F)) + "-set")['`[`[_`]`][qid("V#" + string(1,10) + ":" + string(getKind(M,TYI1)))]],qid("tf-" + alpha(string(F)) + "-set")['`[`[_`]`][qid("V#" + string(2,10) + ":" + string(getKind(M, TYI2)))]]] [ none ] .)
        (eq qid("tf-" + alpha(string(F)) + "-set")['W:OWrap] = 'W:OWrap [ owise ] .) .
    eq aac-constrtfEqs(M, (op F : TYL -> TY [ ATS ] .)) = aac-constrtfCommEqs(M, (op F : TYL -> TY [ ATS ] .), isComm(ATS)) [ owise ] .

    op aac-constrtfCommEqs : Module OpDecl Bool -> EquationSet .
    eq aac-constrtfCommEqs(M, (op F : TYL -> TY [ ATS ] .), true) =
        (eq qid("tf-" + alpha(string(F)) + "-set")['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]] = constrWrapSet(M, TYL,1) [ none ] .)
        (eq qid("tf-" + alpha(string(F)) + "-set")['W:OWrap] = 'W:OWrap [ owise ] .) .
    eq aac-constrtfCommEqs(M, (op F : TYL -> TY [ ATS ] .), false) = aac-constrtfAssocEqs(M, (op F : TYL -> TY [ ATS ] .), isAssoc(ATS)) [ owise ] .

    op aac-constrtfAssocEqs : Module OpDecl Bool -> EquationSet .
    eq aac-constrtfAssocEqs(M, (op F : TYI1 TYI2 -> TY [ ATS ] .), true) =
        (eq qid("tf-" + alpha(string(F)) + "-list")['`[`[_`]`][constrTerm(M, (op F : TYI1 TYI2 -> TY [ ATS ] .),0)]] = '__[qid("tf-" + alpha(string(F)) + "-list")['`[`[_`]`][qid("V#" + string(1,10) + ":" + string(getKind(M,TYI1)))]],qid("tf-" + alpha(string(F)) + "-list")['`[`[_`]`][qid("V#" + string(2,10) + ":" + string(getKind(M,TYI2)))]]] [ none ] .)
        (eq qid("tf-" + alpha(string(F)) + "-list")['W:OWrap] = 'W:OWrap [ owise ] .) .
    eq aac-constrtfAssocEqs(M, (op F : TYL -> TY [ ATS ] .), false) = (eq qid("tf-" + alpha(string(F)) + "-list")['`[`[_`]`][constrTerm(M, (op F : TYL -> TY [ ATS ] .),0)]] = constrWrapList(M, TYL,1) [ none ] .) [ owise ] .

    op aac-compWithOrd : Module -> FModule [ memo ] .
    eq aac-compWithOrd(fmod H is IL sorts 'Bool ; SS . SSDS OPDS (op 'false : nil -> 'Bool [ ctor special(id-hook('SystemFalse, nil)) ] .) (op 'true : nil -> 'Bool [ ctor special(id-hook('SystemTrue, nil)) ] .) MAS EQS endfm) =
       aac-compWithOrd'(fmod H is IL sorts 'Bool ; SS . SSDS OPDS (op 'false : nil -> 'Bool [ ctor metadata("0") ].) (op 'true : nil -> 'Bool [ ctor metadata("0") ] .) MAS EQS endfm) .
    eq aac-compWithOrd(mod H is IL sorts 'Bool ; SS . SSDS OPDS (op 'false : nil -> 'Bool [ ctor special(id-hook('SystemFalse, nil)) ] .) (op 'true : nil -> 'Bool [ ctor special(id-hook('SystemTrue, nil)) ] .) MAS EQS RLS endm) =
       aac-compWithOrd'(fmod H is IL sorts 'Bool ; SS . SSDS OPDS (op 'false : nil -> 'Bool [ ctor metadata("0") ].) (op 'true : nil -> 'Bool [ ctor metadata("0") ] .) MAS EQS endfm) .
    eq aac-compWithOrd(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) = aac-compWithOrd'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) [ owise ] .
    eq aac-compWithOrd(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = aac-compWithOrd'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) [ owise ] .
    
    op aac-compWithOrd' : Module -> Module .
    eq aac-compWithOrd'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) =
        fmod 'NuITP-RPO-MOD is
            IL
            (protecting 'NAT * (
                sort 'Bool to 'OBool,
                sort 'Zero to 'OZero,
                sort 'NzNat to 'ONzNat,
                sort 'Nat to 'ONat) .)
            sorts (SS ; 'OTerm ; 'OWrap ; 'OWrapList ; 'OWrapSet ; 'OWrapPolynomial ; newTopSorts(processKinds(getOpsByKind(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, (none).KindOpDeclSetSet, OPDS)))) .
            (subsort 'OWrap < 'OWrapList .)
            (subsort 'OWrap < 'OWrapSet .)
            newSubsorts(processKinds(getOpsByKind(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, (none).KindOpDeclSetSet, OPDS)))
            SSDS
            (op 'nil : nil -> 'OWrapList [ ctor ] .)
            (op '__ : 'OWrapList 'OWrapList -> 'OWrapList [ ctor assoc id('nil.OWrapList) ] .)
            (op 'empty : nil -> 'OWrapSet [ ctor ] .)
            (op '_`,_ : 'OWrapSet 'OWrapSet -> 'OWrapSet [ ctor assoc comm id('empty.OWrapSet) ] .)
            (op '`(_`,_`) : 'OWrapSet 'ONat -> 'OWrapPolynomial [ ctor ] .)
            aac-wrapSorts(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, SS)
            aac-wrapOps(processKinds(getEOpsByKind(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, (none).KindOpDeclSetSet, OPDS)))
            (op '`(variable`,_`) : 'OWrap -> 'OTerm [ none ] .)
            (op '_>v_  : 'OTerm 'OTerm -> 'OBool [ none ] .)
            (op '_>=v_ : 'OTerm 'OTerm -> 'OBool [ none ] .)
            (op '_>v_  : 'OWrap 'OWrap -> 'OBool [ none ] .)
            (op '_>=v_ : 'OWrap 'OWrap -> 'OBool [ none ] .)
            (op '_>v`{lex`}_ : 'OWrapList 'OWrapList -> 'OBool [ none ] .)
            (op '_>>v_ : 'OWrapSet 'OWrapSet -> 'OBool [ none ] .)
            (op '_>>=v_ : 'OWrapSet 'OWrapSet -> 'OBool [ none ] .)
            (op '_>E_  : 'OWrap 'OWrap -> 'OBool [ none ] .)
            (op '_>=E_ : 'OWrap 'OWrap -> 'OBool [ none ] .)
            (op '_>E`{lex`}_ : 'OWrapList 'OWrapList -> 'OBool [ none ] .)
            (op '_>>E_ : 'OWrapSet 'OWrapSet -> 'OBool [ none ] .)
            (op '_>>=E_ : 'OWrapSet 'OWrapSet -> 'OBool [ none ] .)
            (op 'wrapToTerm : 'OWrap -> 'OTerm [ none ] .)
            (op 'acrpo5-1-set : 'OWrapSet 'OTerm -> 'OBool [ none ] .)
            (op 'acrpo5-1-list : 'OWrapList 'OTerm -> 'OBool [ none ] .)
            (op 'acrpo5-2-set : 'OTerm 'OWrapSet -> 'OBool [ none ] .)
            (op 'acrpo5-2-list : 'OTerm 'OWrapList -> 'OBool [ none ] .)
            (op 'sharp : 'OWrapSet 'ONat -> 'OWrapPolynomial [ none ] .)
            (op 'filter : 'OWrap 'OWrapSet -> 'OWrapSet [ none ] .)
            (op '_\_ : 'OWrapSet 'OWrapSet -> 'OWrapSet [ none ] .)
            (op 'size : 'OWrapSet -> 'ONat [ none ] .)
            (op '_>_ : 'OWrapPolynomial 'OWrapPolynomial -> 'OBool [ none ] .)
            (op '_>=_ : 'OWrapPolynomial 'OWrapPolynomial -> 'OBool [ none ] .)
            addACOpDecl(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, OPDS)
            MAS
            (eq '_>v`{lex`}_['nil.OWrapList,'WL:OWrapList] = 'false.OBool [ none ] .)
            (eq '_>v`{lex`}_['__['W:OWrap,'WL:OWrapList],'nil.OWrapList] = 'true.OBool [ none ] .)
            (eq '_>v`{lex`}_['__['W1:OWrap,'WL1:OWrapList],'__['W2:OWrap,'WL2:OWrapList]] = '_or_['_>v_['wrapToTerm['W1:OWrap],'wrapToTerm['W2:OWrap]],'_and_['_==_['W1:OWrap,'W2:OWrap],'_>v`{lex`}_['WL1:OWrapList,'WL2:OWrapList]]] [ none ] .)
            (eq '_>>v_['empty.OWrapSet,'WS:OWrapSet] = 'false.OBool [ none ] .)
            (eq '_>>v_['_`,_['W:OWrap,'WS:OWrapSet],'empty.OWrapSet] = 'true.OBool [ none ] .)
            (eq '_>>v_['_`,_['W:OWrap,'WS1:OWrapSet],'_`,_['W:OWrap,'WS2:OWrapSet]] = '_>>v_['WS1:OWrapSet,'WS2:OWrapSet] [ none ] .)
            (eq '_>>v_['_`,_['W:OWrap,'WS1:OWrapSet],'WS2:OWrapSet] = '_>>=v_['WS1:OWrapSet,'filter['W:OWrap,'WS2:OWrapSet]] [ owise ] .)
            (eq 'acrpo5-1-set['empty.OWrapSet,'T:OTerm] = 'false.OBool [ none ] .)
            (eq 'acrpo5-1-set['_`,_['W:OWrap,'WS:OWrapSet],'T:OTerm] = '_or_['_>=v_['wrapToTerm['W:OWrap],'T:OTerm],'acrpo5-1-set['WS:OWrapSet,'T:OTerm]] [ none ] .)
            (eq 'acrpo5-1-list['nil.OWrapList,'T:OTerm] = 'false.OBool [ none ] .)
            (eq 'acrpo5-1-list['__['W:OWrap,'WL:OWrapList],'T:OTerm] = '_or_['_>=v_['wrapToTerm['W:OWrap],'T:OTerm],'acrpo5-1-list['WL:OWrapList,'T:OTerm]] [ none ] .)
            (eq 'acrpo5-2-set['T:OTerm,'empty.OWrapSet] = 'true.OBool [ none ] .)
            (eq 'acrpo5-2-set['T:OTerm,'_`,_['W:OWrap,'WS:OWrapSet]] = '_and_['_>v_['T:OTerm,'wrapToTerm['W:OWrap]],'acrpo5-2-set['T:OTerm,'WS:OWrapSet]] [ none ] .)
            (eq 'acrpo5-2-list['T:OTerm,'nil.OWrapList] = 'true.OBool [ none ] .)
            (eq 'acrpo5-2-list['T:OTerm,'__['W:OWrap,'WL:OWrapList]] = '_and_['_>v_['T:OTerm,'wrapToTerm['W:OWrap]],'acrpo5-2-list['T:OTerm,'WL:OWrapList]] [ none ] .)
            (eq '_>=v_['T1:OTerm,'T2:OTerm] = '_or_['_==_['T1:OTerm,'T2:OTerm],'_>v_['T1:OTerm,'T2:OTerm]] [ none ] .)
            (eq '_>=v_['W1:OWrap,'W2:OWrap] = '_or_['_==_['W1:OWrap,'W2:OWrap],'_>v_['W1:OWrap,'W2:OWrap]] [ none ] .)
            (eq '_>>=v_['WS1:OWrapSet,'WS2:OWrapSet] = '_or_['_==_['WS1:OWrapSet,'WS2:OWrapSet],'_>>v_['WS1:OWrapSet,'WS2:OWrapSet]] [ none ] .)
            (eq '_>E`{lex`}_['nil.OWrapList,'WL:OWrapList] = 'false.OBool [ none ] .)
            (eq '_>E`{lex`}_['__['W:OWrap,'WL:OWrapList],'nil.OWrapList] = 'true.OBool [ none ] .)
            (eq '_>E`{lex`}_['__['W1:OWrap,'WL1:OWrapList],'__['W2:OWrap,'WL2:OWrapList]] = '_or_['_>E_['W1:OWrap,'W2:OWrap],'_and_['_==_['W1:OWrap,'W2:OWrap],'_>E`{lex`}_['WL1:OWrapList,'WL2:OWrapList]]] [ none ] .)
            (eq '_>>E_['empty.OWrapSet,'WS:OWrapSet] = 'false.OBool [ none ] .)
            (eq '_>>E_['_`,_['W:OWrap,'WS:OWrapSet],'empty.OWrapSet] = 'true.OBool [ none ] .)
            (eq '_>>E_['_`,_['W:OWrap,'WS1:OWrapSet],'_`,_['W:OWrap,'WS2:OWrapSet]] = '_>>E_['WS1:OWrapSet,'WS2:OWrapSet] [ none ] .)
            (eq '_>>E_['_`,_['W:OWrap,'WS1:OWrapSet],'WS2:OWrapSet] = '_>>=E_['WS1:OWrapSet,'filter['W:OWrap,'WS2:OWrapSet]] [ owise ] .)
            (eq '_>=E_['W1:OWrap,'W2:OWrap] = '_or_['_==_['W1:OWrap,'W2:OWrap],'_>E_['W1:OWrap,'W2:OWrap]] [ none ] .)
            (eq '_>>=E_['WS1:OWrapSet,'WS2:OWrapSet] = '_or_['_==_['WS1:OWrapSet,'WS2:OWrapSet],'_>>E_['WS1:OWrapSet,'WS2:OWrapSet]] [ none ] .)
            (eq 'filter['W:OWrap,'empty.OWrapSet] = 'empty.OWrapSet [ none ] .)
            (eq 'filter['W1:OWrap,'_`,_['W2:OWrap,'WS:OWrapSet]] = 'if_then_else_fi['_>E_['W1:OWrap,'W2:OWrap],'filter['W1:OWrap,'WS:OWrapSet],'_`,_['W2:OWrap,'filter['W1:OWrap,'WS:OWrapSet]]] [ none ] .)
            (eq '_\_['_`,_['W:OWrap,'WS1:OWrapSet],'_`,_['W:OWrap,'WS2:OWrapSet]] = '_\_['WS1:OWrapSet,'WS2:OWrapSet] [ none ] .)
            (eq '_\_['WS1:OWrapSet,'WS2:OWrapSet] = 'WS1:OWrapSet [ owise ] .)
            (eq 'size['empty.OWrapSet] = '0.ONat [ none ] .)
            (eq 'size['_`,_['W:OWrap,'WS1:OWrapSet]] = 's_['size['WS1:OWrapSet]] [ none ] .)
            (eq '_>_['`(_`,_`)['WS1:OWrapSet,'N1:ONat],'`(_`,_`)['WS2:OWrapSet,'N2:ONat]] = '_and_['_==_['_\_['WS2:OWrapSet,'WS1:OWrapSet],'empty.OWrapSet],'_>_['_+_['size['_\_['WS1:OWrapSet,'WS2:OWrapSet]],'N1:ONat],'N2:ONat]] [ none ] .)
            (eq '_>=_['`(_`,_`)['WS1:OWrapSet,'N1:ONat],'`(_`,_`)['WS2:OWrapSet,'N2:ONat]] = '_and_['_==_['_\_['WS2:OWrapSet,'WS1:OWrapSet],'empty.OWrapSet],'_>=_['_+_['size['_\_['WS1:OWrapSet,'WS2:OWrapSet]],'N1:ONat],'N2:ONat]] [ none ] .)
            (eq '_>v_['W1:OWrap,'W2:OWrap] = '_>v_['wrapToTerm['W1:OWrap],'wrapToTerm['W2:OWrap]] [ none ] .)
            aac-wrapSortEqs(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm,SS)
            aac-wrapEqs(processKinds(getEOpsByKind(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, none, OPDS)))
            aac-constrWrapEqs(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, nil, sort(fromOpDeclSetToNatOpDeclList(addACOpDecl(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm, OPDS))))
        endfm .

    op _>AAC{_}_ : Term Module Term -> Bool [ memo ] .
    eq T1 >AAC{ M } T2 = getTerm(metaReduce(aac-compWithOrd(M), '_>=E_['`[`[_`]`][T1],'`[`[_`]`][T2]])) == 'true.OBool .
endfm

--------------------------------------------------------------------------------
---                         The above AAC-RPO code is a minimal, adapted version
---                                       of the original AAC-RPO implemented by
---                          Raúl Gutiérrez <raguti@upv.es> <r.gutierrez@upm.es>
--------------------------------------------------------------------------------

fmod NuITP-RPO is
    pr NuITP-AAC-RPO .
    pr NuITP-REMOVE-U .
    pr NuITP-SKOLEM .

    sorts OpDeclList OpDeclListTriple .
    subsort OpDecl < OpDeclList .

    var M : Module .
    vars LHS RHS : Term .
    var ODT : OpDeclListTriple .
    var OP : OpDecl .
    var OPDS : OpDeclSet .
    vars ODL ODL1 ODL2 ODL3 : OpDeclList .
    vars F F' : Qid .
    vars TYL TYL' : TypeList .
    vars TY TY' : TypeList .
    var N : Nat .
    vars ATS ATS' : AttrSet .
    vars STR STR' : String .
    var NeHL : NeHookList .

    op nil : -> OpDeclList [ ctor ] .
    op _,_ : OpDeclList OpDeclList -> OpDeclList [ ctor assoc id: nil ] .

    op _:_:_ : OpDeclList OpDeclList OpDeclList -> OpDeclListTriple [ ctor ] .

    op sortOps : Module -> Module [ memo ] .
    eq sortOps(M) = setOps(M, getSpecial(getOps(M)) sortOps(M, split(getOps(M)))) .

    op sortOps : Module OpDeclListTriple -> OpDeclSet .
    eq sortOps(M, ODL1 : ODL2 : ODL3) = sortOverloaded(M, sortOps(sortNat(ODL1) : sortSKONat(ODL2) : sortNat(ODL3), 1)) .

    op sortOverloaded : Module OpDeclSet -> OpDeclSet .
    ceq sortOverloaded(M, (op F : TYL -> TY [ ATS metadata(STR) ] .) (op F : TYL' -> TY' [ ATS' metadata(STR') ] .) OPDS) =
       sortOverloaded(M, (op F : TYL -> TY [ ATS metadata(STR) ] .) (op F : TYL' -> TY' [ ATS' metadata(STR) ] .) OPDS)
        if (sameKind(M, TY, TY'))
        /\ (rat(STR', 10) > rat(STR,10)) .
    eq sortOverloaded(M, OPDS) = OPDS [ owise ] .

    op sortOps : OpDeclListTriple Nat -> OpDeclSet .
    eq sortOps(nil : nil : nil , N) = none .
    eq sortOps(nil : nil : ((op F : TYL -> TY [ ATS metadata(STR) ] .) , ODL3), N) = (op F : TYL -> TY [ ATS metadata(string(N,10)) ] .) sortOps(nil : nil : ODL3, N + 1) .
    eq sortOps(nil : ((op F : TYL -> TY [ ATS metadata(STR) ] .) , ODL2) : ODL3, N) = (op F : TYL -> TY [ ATS metadata(string(N,10)) ] .) sortOps(nil : ODL2 : ODL3, N + 1) .
    eq sortOps(((op F : TYL -> TY [ ATS metadata(STR) ] .) , ODL1) : ODL2 : ODL3, N) = (op F : TYL -> TY [ ATS metadata(string(N,10)) ] .) sortOps(ODL1 : ODL2 : ODL3, N + 1) .

    op getSpecial : OpDeclSet -> OpDeclSet .
    eq getSpecial((op F : TYL -> TY [ ATS special(NeHL) ] .) OPDS) = (op F : TYL -> TY [ ATS special(NeHL) ] .) getSpecial(OPDS) .
    eq getSpecial(OPDS) = none [ owise ] .

    op split : OpDeclSet -> OpDeclListTriple .
    eq split((op F : TYL -> TY [ ATS special(NeHL) ] .) OPDS) = split(OPDS) .
    eq split(OPDS) = split(OPDS, nil : nil : nil) [ owise ] .

    op split : OpDeclSet OpDeclListTriple -> OpDeclListTriple .
    eq split(none, ODT) = ODT .
    eq split((op F : TYL -> TY [ ATS ctor ] .) OPDS, ODL1 : ODL2 : ODL3) = split(OPDS, (ODL1 , (op F : TYL -> TY [ fixMetadata(ATS) ctor ] .)) : ODL2 : ODL3) .
    eq split((op F : TYL -> TY [ ATS metadata("skolem") ] .) OPDS, ODL1 : ODL2 : ODL3) = split(OPDS, ODL1 : (ODL2 , (op F : TYL -> TY [ ATS metadata("skolem") ] .)) : ODL3) .
    eq split((op F : TYL -> TY [ ATS ] .) OPDS, ODL1 : ODL2 : ODL3) = split(OPDS, ODL1 : ODL2 : (ODL3 , (op F : TYL -> TY [ fixMetadata(ATS) ] .))) [ owise ] .

    op fixMetadata : AttrSet -> AttrSet .
    eq fixMetadata(ATS metadata(STR)) = ATS (if (rat(STR,10) :: Nat) then metadata(STR) else metadata("0") fi) .
    eq fixMetadata(ATS) = ATS metadata("0") [ owise ] .

    op sortNat : OpDeclList -> OpDeclList [ memo ] .
    ceq sortNat((ODL1 , (op F : TYL -> TY [ ATS metadata(STR) ] .) , ODL2 , (op F' : TYL' -> TY' [ ATS' metadata(STR') ] .) , ODL3)) =
        sortNat((ODL1 , (op F' : TYL' -> TY' [ ATS' metadata(STR') ] .) , ODL2 , (op F : TYL -> TY [ ATS metadata(STR) ] .) , ODL3))
        if (rat(STR, 10) > rat(STR',10)) .
    eq sortNat(ODL) = ODL [ owise ] .

    op sortSKONat : OpDeclList -> OpDeclList .
    ceq sortSKONat((ODL1 , (op F : TYL -> TY [ ATS metadata("skolem") ] .) , ODL2 , (op F' : TYL' -> TY' [ ATS' metadata("skolem") ] .) , ODL3)) =
        sortSKONat((ODL1 , (op F' : TYL' -> TY' [ ATS' metadata("skolem") ] .) , ODL2 , (op F : TYL -> TY [ ATS metadata("skolem") ] .) , ODL3))
        if (startsWith(string(F), "$") and-then startsWith(string(F'), "$"))
        /\ (rat(substr(string(F), 1, length(string(F))),10) < rat(substr(string(F'), 1, length(string(F'))),10)) .
    eq sortSKONat(ODL) = ODL [ owise ] .

    op sortSko : Module OpDeclList -> OpDeclList .
    ceq sortSko(M, (ODL1 , (op F : TYL -> TY [ ATS ] .) , ODL2 , (op F' : TYL' -> TY' [ ATS' ] .) , ODL3)) = sortSko(M, (ODL1 , (op F' : TYL' -> TY' [ ATS' ] .) , ODL2 , (op F : TYL -> TY [ ATS ] .) , ODL3))
        if sameKind(M, TY, TY') and-then not(sortLeq(M, TY, TY')) .
    eq sortSko(M, ODL) = ODL [ owise ] .

    op _>RPO{_}_ : Term Module Term -> [Bool] [ memo ] .
    eq LHS >RPO{ M } RHS = LHS >AAC{ removeU(sortOps(M)) } RHS .

    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .
    var STDS : StratDeclSet .
    var STDFS : StratDefSet .
    vars T T' T1 GAMMA GAMMA' LHS' RHS' : Term .
    var NTL : NeTermList .
    vars TL1 TL2 : TermList .
    var NTS : NeTermSet .
    var TS : TermSet .
    var Q : Qid .
    var SB : Substitution .
    var PA : Parent .
    var B : Bool .

    op u-transform : Module TermSet -> TermSet .
    eq u-transform(fmod H is IL  sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfm, NTS) = u-transform'(fmod H is IL sorts SS . SSDS getOps(removeU(fmod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(fmod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) endfm, NTS) .
    eq u-transform(fth Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfth, NTS) = u-transform'(fth Q is IL sorts SS . SSDS getOps(removeU(fth Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(fth Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS endfth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) endfth, NTS) .
    eq u-transform(mod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endm, NTS) = u-transform'(mod H is IL sorts SS . SSDS getOps(removeU(mod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(mod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS endm, NTS) .
    eq u-transform(th Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endth, NTS) = u-transform'(th Q is IL sorts SS . SSDS getOps(removeU(th Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(th Q is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS endth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS endth, NTS) .
    eq u-transform(smod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsm, NTS) = u-transform'(smod H is IL sorts SS . SSDS getOps(removeU(smod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(smod H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsm, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS STDS STDFS endsm, NTS) .
    eq u-transform(sth H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsth, NTS) = u-transform'(sth H is IL sorts SS . SSDS getOps(removeU(sth H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) MAS getEqs(removeU(sth H is IL sorts SS . SSDS OPDS (op F : TYL -> TY [ id(T) ATS ] .) MAS EQS RLS STDS STDFS endsth, OPDS (op F : TYL -> TY [ id(T) ATS ] .))) RLS STDS STDFS endsth, NTS) .
    eq u-transform(M, TS) = TS [ owise ] .

    op u-transform' : Module TermSet -> TermSet .
    eq u-transform'(M, mt) = mt .
    eq u-transform'(M, T ;; TS) = u-transform'(M, T, 0) ;; u-transform'(M, TS) .

    op u-transform' : Module Term Nat -> TermSet .
    ceq u-transform'(M, '_->_[GAMMA,'_=>_[LHS,RHS]], N) =
        (
            if (LHS' >RPO{M} RHS') and-then 
            (getTerm(metaReduce(setEqs(M, none), disorient(safeVars('_->_[GAMMA','_=>_[LHS',RHS']],"NuITP-RU-")))) =/= 'true.NuITP-Bool) and-then 
            ((GAMMA' == 'true.NuITP-Bool) or-else checkCondition(M, LHS', GAMMA'))
        then safeVars('_->_[GAMMA','_=>_[LHS',RHS']],"NuITP-RU-")
        else mt
        fi) ;; u-transform'(M, '_->_[GAMMA,'_=>_[LHS,RHS]], N + 1)
        if { '_->_[GAMMA','_=>_[LHS',RHS']], SB, F, PA, B } := metaGetVariant(M, '_->_[GAMMA,'_=>_[LHS,RHS]], empty, '#, N) .
    eq u-transform'(M, T, N) = mt [ owise ] .

    op checkCondition : Module TermList TermList -> Bool .
    eq checkCondition(M, mt, GAMMA) = true .
    eq checkCondition(M, T, empty) = true .
    eq checkCondition(M, T, '_=_[LHS,RHS]) = (T >RPO{ M } LHS) and-then (T >RPO{ M } RHS) .
    eq checkCondition(M, T, '_/\_[NTL]) = checkCondition(M, T, NTL) .
    eq checkCondition(M, T, (T1,NTL)) = checkCondition(M, T, T1) and-then checkCondition(M, T, NTL) .
    eq checkCondition(M, (('_=_[LHS,RHS]), NTL), GAMMA) = checkCondition(M, LHS, GAMMA) and-then checkCondition(M, NTL, GAMMA) .
    eq checkCondition(M, TL1, TL2) = false [ owise ] .
endfm

fmod NuITP-CONG-CLOSURE is
    pr NuITP-UTILS .
    pr NuITP-RPO .

    sorts CCState CCResultTriple CCDBPair CCDBPairSet .
    subsort CCDBPair < CCDBPairSet .

    --- Module EquationList RuleList Rule RuleList Nat
    op <_|_|_#_#_|_|_|_> : Module TermList TermList TermList TermList CCDBPairSet CCDBPairSet Nat -> CCState [ ctor ] .
    op {_:_:_} : TermList TermList TermList -> CCResultTriple [ ctor ] .
    
    op [_:_] : Qid TermList -> CCDBPair [ ctor ] .
    op mt : -> CCDBPairSet [ ctor ] .
    op __ : CCDBPairSet CCDBPairSet -> CCDBPairSet [ assoc comm id: mt ] .
    eq DBP DBP = DBP .
    eq ([ F : TL1 ] [ F : TL2 ]) = [ F : (TL1,TL2) ] .
    
    var M : Module .
    vars EQL EQL' RLL  RL0 RL0' RL1 RL1' RFAC RFA TL TL1 TL2 : TermList .
    var DBP : CCDBPair .
    vars DBAC DBA : CCDBPairSet .
    var N : Nat .
    var OPDS : OpDeclSet .
    vars F Q : Qid .
    vars T T1 T2 T1' T2' LHS RHS RHS' TU TV TW TU1 TU2 TV1 TV2 RHSU RHSV GAMMA LAMBDA : Term .
    var SKO : TermSet .
    var NTL : NeTermList .
    var NTS : NeTermSet .
    var ATS : AttrSet .
    vars TY TY1 TY2 TY3 TY1' TY2' : Type .
    var STR : String .
    var SB : Substitution .

    op isAssoc? : Module Term -> Bool .
    eq isAssoc?(M, T) = isAssoc?(M, getOps(M), T) .
    
    op isAssoc? : Module OpDeclSet TermList -> Bool .
    ceq isAssoc?(M, (op F : TY1 TY2 -> TY [ assoc ATS ] .) OPDS, F[NTL]) = true 
        if sameKind(M, TY, getType(metaNormalize(M, F[NTL])))
        /\ SB := metaMatch(M, F[fresh("NuITP-AUX1",TY1),fresh("NuITP-AUX2",TY2)], F[NTL], nil, 0) .
    eq isAssoc?(M, OPDS, T) = false [ owise ] .

    op isComm? : Module Term -> Bool .
    eq isComm?(M, T) = isComm?(M, getOps(M), T) .
    
    op isComm? : Module OpDeclSet TermList -> Bool .
    ceq isComm?(M, (op F : TY1 TY2 -> TY [ comm ATS ] .) OPDS, F[NTL]) = true 
        if sameKind(M, TY, getType(metaNormalize(M, F[NTL])))
        /\ SB := metaMatch(M, F[fresh("NuITP-AUX1",TY1),fresh("NuITP-AUX2",TY2)], F[NTL], nil, 0) .
    eq isComm?(M, OPDS, T) = false [ owise ] .

    eq [add] : < M | (('_=_[LHS,RHS]),EQL) | RL0 # empty # RL1 | DBAC | DBA | N > =
        if (getTerm(metaReduce(setEqs(M, toEqs((RL0,RL1))), LHS)) == getTerm(metaReduce(setEqs(M, toEqs((RL0,RL1))), RHS))) 
        then < M | EQL | RL0 # empty # RL1 | DBAC | DBA | N >
        else 
            if (LHS >RPO{ M } RHS)
            then < M | EQL | RL0 # '_=>_[(getTerm(metaReduce(setEqs(M, toEqs((RL0,RL1))), LHS)),getTerm(metaReduce(setEqs(M, toEqs((RL0,RL1))), RHS)))] # RL1 | DBAC | DBA | N >
            else < M | EQL | RL0 # '_=>_[(getTerm(metaReduce(setEqs(M, toEqs((RL0,RL1))), RHS)),getTerm(metaReduce(setEqs(M, toEqs((RL0,RL1))), LHS)))] # RL1 | DBAC | DBA | N >
            fi 
        fi .

    ceq [inter-reduce-lhs] : < M | EQL | RL0 # ('_=>_[LHS,RHS]) # RL1 | DBAC | DBA | N > = < M | (EQL,EQL') | (RL0',(if isAssoc?(M, LHS) then empty else ('_=>_[LHS,RHS]) fi)) # empty # (RL1',(if isAssoc?(M, LHS) then ('_=>_[LHS,RHS]) else empty fi)) | DBAC | DBA | N > 
        if { EQL' : RL0' : RL1' } := interReduce(addEqs(M, toEqs('_=>_[LHS,RHS])), empty, RL0, RL1) .
    
    op interReduce : Module TermList TermList TermList -> CCResultTriple .
    ceq interReduce(M, EQL, (RL0,('_=>_[LHS,RHS]),RL0'), RL1) = interReduce(M, (EQL,('_=_[getTerm(metaReduce(M, getTerm(metaNormalize(M, LHS)))), RHS])), (RL0,RL0'), RL1)
        if getTerm(metaReduce(M, getTerm(metaNormalize(M, LHS)))) =/= getTerm(metaNormalize(M, LHS)) .
    ceq interReduce(M, EQL, RL0, (RL1,('_=>_[LHS,RHS]),RL1')) = interReduce(M, (EQL,('_=_[getTerm(metaReduce(M, getTerm(metaNormalize(M, LHS)))), RHS])), RL0, (RL1,RL1'))
        if getTerm(metaReduce(M, getTerm(metaNormalize(M, LHS)))) =/= getTerm(metaNormalize(M, LHS)) .
    eq interReduce(M, EQL, RL0, RL1) = { EQL : RL0 : RL1 } [ owise ] .

    eq [cp-gen-ac] : < M | empty | RL0 # empty # (('_=>_[F[T1,T2],RHS]),RL1) | [ F : RFAC ] DBAC | DBA | N > = 
                     < M | cpsAC(M, getOps(M), ('_=>_[F[T1,T2],RHS]), RFAC) | (RL0,('_=>_[F[T1,T2],RHS])) # empty # RL1 | [ F : (RFAC, ('_=>_[F[T1,T2],RHS])) ] DBAC | DBA | N + 1 > .

    eq [cp-gen-a] : < M | empty | RL0 # empty # (('_=>_[F[T1,T2],RHS]),RL1) | DBAC | [ F : RFA ] DBA | N > = 
                     < M | cpsA(M, getOps(M), ('_=>_[F[T1,T2],RHS]), RFA) | (RL0,('_=>_[F[T1,T2],RHS])) # empty # RL1 | DBAC | [ F : (RFA, ('_=>_[F[T1,T2],RHS])) ] DBA | N + 1 > .

    op cpsAC : Module OpDeclSet Term TermList -> TermList .
    ceq cpsAC(M, (op F : TY1 TY2 -> TY3 [ ATS assoc comm ] .) OPDS, ('_=>_[F[T1,T2],RHS]), TL) = 
        cpsAC(addEqs(addOps(addSorts(M, qid("Overlaps#" + safeString(F))), (op '_|_ : TY TY -> qid("Overlaps#" + safeString(F)) [ ctor ] .) (op '_|_|_ : TY TY TY -> qid("Overlaps#" + safeString(F)) [ ctor ] .)), 
            (
                eq '_|_[F[qid("NuITP-CC-AC1:" + cleanString(TY)),qid("NuITP-CC-AC3:" + cleanString(TY))],F[qid("NuITP-CC-AC2:" + cleanString(TY)),qid("NuITP-CC-AC3:" + cleanString(TY))]] 
                =  '_|_|_[qid("NuITP-CC-AC1:" + cleanString(TY)),qid("NuITP-CC-AC3:" + cleanString(TY)),qid("NuITP-CC-AC2:" + cleanString(TY))] [ none ] .
            ) 
            (
                eq '_|_|_[F[qid("NuITP-CC-AC1:" + cleanString(TY)),qid("NuITP-CC-AC3:" + cleanString(TY))],qid("NuITP-CC-AC4:" + cleanString(TY)),F[qid("NuITP-CC-AC2:" + cleanString(TY)),qid("NuITP-CC-AC3:" + cleanString(TY))]] 
                =  '_|_|_[qid("NuITP-CC-AC1:" + cleanString(TY)),F[qid("NuITP-CC-AC3:" + cleanString(TY)),qid("NuITP-CC-AC4:" + cleanString(TY))],qid("NuITP-CC-AC2:" + cleanString(TY))] [ none ] .
            )
        ), ('_=>_[F[T1,T2],RHS]), TL) 
        if TY1' := leastSort(M, T1)
        /\ TY2' := leastSort(M, T2)
        /\ TY := (if sortLeq(M, TY1', TY2') then TY1' else TY2' fi) .
    op cpsA : Module OpDeclSet Term TermList -> TermList .
    eq cpsA(M, (op F : TY1 TY2 -> TY [ ATS assoc ] .) OPDS, ('_=>_[F[T1,T2],RHS]), (('_=>_[F[T1',T2'],RHS']),TL)) = 
        cpsA(addOps(addSorts(M, qid("Overlaps#" + safeString(F))), (op '_|_ : TY TY -> qid("Overlaps#" + safeString(F)) [ ctor ] .)), 
        cleanString(getKind(M, TY)), 
        ('_=>_[F[T1,T2],RHS]), 
        ('_=>_[F[T1',T2'],RHS']),
        0) cpsA(addOps(addSorts(M, qid("Overlaps#" + safeString(F))), (op '_|_ : TY TY -> qid("Overlaps#" + safeString(F)) [ ctor ] .)), 
        cleanString(getKind(M, TY)), 
        ('_=>_[F[T1',T2'],RHS']),
        ('_=>_[F[T1,T2],RHS]), 
        0) cpsA(M, (op F : TY1 TY2 -> TY [ ATS assoc ] .) OPDS, ('_=>_[F[T1,T2],RHS]), TL) .
    eq cpsA(M, (op F : TY1 TY2 -> TY [ ATS assoc ] .) OPDS, ('_=>_[F[T1,T2],RHS]), TL) = 
        cpsA(addOps(addSorts(M, qid("Overlaps#" + safeString(F))), (op '_|_ : TY TY -> qid("Overlaps#" + safeString(F)) [ ctor ] .)), 
        cleanString(getKind(M, TY)), 
        ('_=>_[F[T1,T2],RHS]), 
        TL,
        0) [ owise ] .

    op cpsAC : Module Term TermList -> TermList .
    eq cpsAC(M, '_=>_[F[T1,T2],RHS], empty) = empty .
    eq cpsAC(M, '_=>_[F[T1,T2],RHS], ('_=>_[F[T1',T2'],RHS'],TL)) = cpsAC(getTerm(metaReduce(M, '_|_[F[T1,T2],F[T1',T2']])), F, RHS, RHS') , cpsAC(M, '_=>_[F[T1,T2],RHS], TL) .
    eq cpsAC(M, '_=>_[F[T1,T2],RHS], (T,TL)) = cpsAC(M, '_=>_[F[T1,T2],RHS], TL) [ owise ] .
    
    op cpsAC : Term Qid Term Term -> TermList .
    eq cpsAC('_|_[F[T1,T2],F[T1',T2']], F, RHS, RHS') = empty .
    eq cpsAC('_|_[TU, TV, TW], F, RHS, RHS') = '_=_[F[RHS,TW],F[RHS',TU]] .
    eq cpsAC('_|_|_[TU, TV, TW], F, RHS, RHS') = '_=_[F[RHS,TW],F[RHS',TU]] . --- Fix?

    op cpsA : Module String Term Term Nat -> TermList .
    ceq cpsA(M, STR, ('_=>_[F[TU1,TU2],RHSU]), ('_=>_[F[TV1,TV2],RHSV]), N) = ('_=_[F[RHSU,applySub(qid("NuITP-CC-A1:" + STR), SB)],F[applySub(qid("NuITP-CC-A2:" + STR),SB),RHSV]]) , cpsA(M, STR, ('_=>_[F[TU1,TU2],RHSU]), ('_=>_[F[TV1,TV2],RHSV]), N + 1)
        if { SB, Q } := metaUnify(M, '_|_[F[TU1,TU2],F[TV1,TV2]] =? '_|_[F[qid("NuITP-CC-A2:" + STR),qid("NuITP-CC-A3:" + STR)],F[qid("NuITP-CC-A3:" + STR),qid("NuITP-CC-A1:" + STR)]], '#, N) .
    eq cpsA(M, STR, T1, T2, N) = empty [ owise ] .

    op toHPS : TermList -> TermSet .
    eq toHPS(T) = '_->_['true.NuITP-Bool, T] .
    eq toHPS((T,NTL)) = ('_->_['true.NuITP-Bool, T]) ;; toHPS(NTL) .

    op getRls : CCState -> [TermSet] .
    eq getRls(< M | empty | RL0 # empty # empty | DBAC | DBA | N >) = toHPS(RL0) .
    eq getRls(< M | empty | RL0 # empty # RL1 | DBAC | DBA | N >) = toHPS((RL0,RL1)) .

    op cong-closure : Module TermSet -> [TermSet] .
    op cong-closure : Module TermList -> [TermSet] .
    eq cong-closure(M, empty) = mt .
    eq cong-closure(M, mt) = mt .
    eq cong-closure(M, NTS) = cong-closure'(removeU(M), NTS) .
    eq cong-closure(M, NTL) = cong-closure'(removeU(M), NTL) .

    op cong-closure' : Module TermSet -> [TermSet] .
    op cong-closure' : Module TermList -> [TermSet] .
    eq cong-closure'(M, NTS) = getRls(< setRls(setEqs(M, none), none) | toCCEqs(NTS) | empty # empty # empty | getACs(M, orient(M, toCCEqs(NTS))) | getAs(M, orient(M, toCCEqs(NTS))) | 0 >) .
    eq cong-closure'(M, NTL) = getRls(< setRls(setEqs(M, none), none) | toCCEqs(NTL) | empty # empty # empty | getACs(M, orient(M, toCCEqs(NTL))) | getAs(M, orient(M, toCCEqs(NTL))) | 0 >) .

    op getACs : Module NeTermSet -> CCDBPairSet .
    op getACs : Module NeTermList -> CCDBPairSet .
    eq getACs(M, T) = mt [ owise ] .
    eq getACs(M, ('_=>_[F[T1,T2],RHS])) =
        if isAssoc?(M, F[T1,T2]) and-then isComm?(M, F[T1,T2])
        then [ F : RHS ]
        else mt
        fi . 
    eq getACs(M, (T ;; NTS)) = getACs(M, T) getACs(M, NTS) .
    eq getACs(M, (T,NTL)) = getACs(M, T) getACs(M, NTL) .

    op getAs : Module NeTermSet -> CCDBPairSet .
    op getAs : Module NeTermList -> CCDBPairSet .
    eq getAs(M, T) = mt [ owise ] .
    eq getAs(M, ('_=>_[F[T1,T2],RHS])) =
        if isAssoc?(M, F[T1,T2]) and-then not(isComm?(M, F[T1,T2]))
        then [ F : RHS ]
        else mt
        fi . 
    eq getAs(M, (T ;; NTS)) = getAs(M, T) getAs(M, NTS) .
    eq getAs(M, (T,NTL)) = getAs(M, T) getAs(M, NTL) .

    --- Only HGEs or GAMMAs
    op toCCEqs : TermSet -> TermList .
    op toCCEqs : TermList -> TermList .
    eq toCCEqs(mt) = empty .
    eq toCCEqs(empty) = empty .
    eq toCCEqs('true.NuITP-Bool) = empty .
    eq toCCEqs('_=_[LHS,RHS]) = '_=_[LHS,RHS] .
    eq toCCEqs('_=>_[LHS,RHS]) = '_=_[LHS,RHS] .
    eq toCCEqs('_/\_[NTL]) = toCCEqs(NTL) .
    eq toCCEqs('_->_['true.NuITP-Bool,'_=_[LHS,RHS]]) = '_=_[LHS,RHS] .
    eq toCCEqs('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]]) = '_=_[LHS,RHS] .
    eq toCCEqs((T,NTL)) = (toCCEqs(T) , toCCEqs(NTL)) .
    eq toCCEqs(T ;; NTS) = (toCCEqs(T) , toCCEqs(NTS)) .

    --- Ground eqs are always orientable due to total ordering.
    op orient : Module TermList -> TermList .
    op orient : Module TermSet -> TermSet .
    op orient : Module Term -> Term .
    eq orient(M, empty) = empty .
    eq orient(M, mt) = mt .
    eq orient(M, '_->_[GAMMA,LAMBDA]) = '_->_[GAMMA,orient(M, LAMBDA)] .
    eq orient(M, '_=>_[LHS,RHS]) = '_=>_[LHS,RHS] .
    eq orient(M, '_=_[LHS,RHS]) =
        (if (LHS >RPO{ M } RHS)
        then '_=>_[LHS,RHS]
        else
            if (RHS >RPO{ M } LHS)
            then '_=>_[RHS,LHS]
            else '_=_[LHS,RHS]
            fi
        fi) .
    eq orient(M, '_\/_[NTL]) = '_\/_[orient(M, NTL)] .
    eq orient(M, '_/\_[NTL]) = '_/\_[orient(M, NTL)] .
    eq orient(M, (T,NTL)) = orient(M,T) , orient(M,NTL) .
    eq orient(M, (T ;; NTS)) = orient(M,T) ;; orient(M,NTS) .
    eq orient(M, T) = T [ owise ] .
endfm

fmod NuITP-HSIMP is
    pr NuITP-EQPREDS .
    pr NuITP-REMOVE-U .
    pr NuITP-CONG-CLOSURE .

    var F : Qid .
    var M : Module .
    vars N CTOR DEF : Nat .
    vars LHS RHS T GAMMA LAMBDA : Term .
    vars TS TS' SKO HGE HE HNE : TermSet .
    var OPDS : OpDeclSet .
    var NTS : NeTermSet .
    var NTL : NeTermList .
    var TL : TermList .
    var TYL : TypeList .
    var TY : Type .
    var ATS : AttrSet .
    var STR : String .

    op [_|_|_] : TermSet TermSet TermSet -> ResultTriple [ ctor ] .

    op getHGE : ResultTriple -> TermSet .
    eq getHGE([ HGE | HE | HNE ]) = HGE .

    op getHE : ResultTriple -> TermSet .
    eq getHE([ HGE | HE | HNE ]) = HE .

    op getHNE : ResultTriple -> TermSet .
    eq getHNE([ HGE | HE | HNE ]) = HNE .

    --- Executables
    op he : Module TermSet TermSet -> TermSet .
    eq he(M, SKO, mt) = mt .
    eq he(M, SKO, NTS) = getHE(hClassify(addOps(M, SKO), NTS)) ;; getHGE(hClassify(addOps(M, SKO), NTS)) .

    op hgeu : Module TermSet TermSet -> TermSet .
    eq hgeu(M, SKO, mt) = mt .
    eq hgeu(M, SKO, NTS) = u-transform(addOps(M, SKO), getHGE(hClassify(addOps(M, SKO), NTS))) .

    op heu+ : Module TermSet TermSet -> TermSet .
    eq heu+(M, SKO, mt) = mt .
    eq heu+(M, SKO, NTS) = u-transform(addOps(M, SKO), getHE(hClassify(addOps(M, SKO), NTS)) ;; getHGE(hClassify(addOps(M, SKO), NTS))) .

    op heu++ : Module TermSet TermSet -> TermSet .
    eq heu++(M, SKO, mt) = mt .
    eq heu++(M, SKO, NTS) = u-transform(addOps(M, SKO), getHE(hClassify(addOps(M, SKO), NTS))) .

    --- Non-executables
    op hne : Module TermSet TermSet -> TermSet .
    eq hne(M, SKO, mt) = mt .
    eq hne(M, SKO, NTS) = getHNE(hClassify(addOps(M, SKO), NTS)) .

    --- Ground eqs are always orientable due to total ordering.
    op orient : Module TermList -> TermList .
    op orient : Module TermSet -> TermSet .
    op orient : Module Term -> Term .
    eq orient(M, empty) = empty .
    eq orient(M, mt) = mt .
    eq orient(M, '_->_[GAMMA,LAMBDA]) = '_->_[GAMMA,orient(M, LAMBDA)] .
    eq orient(M, '_=>_[LHS,RHS]) = '_=>_[LHS,RHS] .
    eq orient(M, '_=_[LHS,RHS]) =
        (if (LHS >RPO{ M } RHS)
        then '_=>_[LHS,RHS]
        else
            if (RHS >RPO{ M } LHS)
            then '_=>_[RHS,LHS]
            else '_=_[LHS,RHS]
            fi
        fi) .
    eq orient(M, '_\/_[NTL]) = '_\/_[orient(M, NTL)] .
    eq orient(M, '_/\_[NTL]) = '_/\_[orient(M, NTL)] .
    eq orient(M, (T,NTL)) = orient(M,T) , orient(M,NTL) .
    eq orient(M, (T ;; NTS)) = orient(M,T) ;; orient(M,NTS) .
    eq orient(M, T) = T [ owise ] .

    op eu : Module -> Module .
    eq eu(M) = removeU(M) .

    op euR : Module Term -> Module [ memo ] .
    eq euR(M, F[NTL]) = setRls(setEqs(M, (none).EquationSet), toRls(getEqs(removeU(M)), F[NTL], 0)) .

    op e=xu : Module TermSet -> Module .
    eq e=xu(M, SKO) = addOps(eqPreds(removeU(M)),toOps(SKO)) .

    op hClassify : Module TermSet -> ResultTriple .
    eq hClassify(M, mt) = [ mt | mt | mt ] .
    eq hClassify(M, NTS) = hClassify(M, NTS, [ mt | mt | mt ]) .

    op hClassify : Module NeTermSet ResultTriple -> ResultTriple .
    --- Needed if the goal is actually false?
    eq hClassify(M, 'false.NuITP-Bool, [ HGE | HE | HNE ]) = [ HGE | HE | HNE ;; 'false.NuITP-Bool ] .
    eq hClassify(M, 'false.NuITP-Bool ;; NTS, [ HGE | HE | HNE ]) = hClassify(M, NTS, [ HGE | HE | HNE ;; 'false.NuITP-Bool ]) .

    eq hClassify(M, '_->_['true.NuITP-Bool,'_=_[LHS,RHS]], [ HGE | HE | HNE ]) = [ HGE | HE | (HNE ;; ('_->_['true.NuITP-Bool,'_=_[LHS,RHS]])) ] .
    eq hClassify(M, '_->_['true.NuITP-Bool,'_=>_[LHS,RHS]], [ HGE | HE | HNE ]) =
        if ('_=>_[LHS,RHS] :: GroundTerm)
        then [ (HGE ;; ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]])) | HE | HNE ]
        else
            if (getVars(RHS) in getVars(LHS))
            then [ HGE | (HE ;; ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]])) | HNE ]
            else [ HGE | HE | (HNE ;; ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]])) ]
            fi
        fi .
    eq hClassify(M, '_->_[GAMMA,'_=_[LHS,RHS]], [ HGE | HE | HNE ]) = [ HGE | HE | (HNE ;; ('_->_[GAMMA,'_=_[LHS,RHS]])) ] [ owise ] .
    eq hClassify(M, '_->_[GAMMA,'_=>_[LHS,RHS]], [ HGE | HE | HNE ]) =
        if (getVars(RHS) in getVars(LHS)) and-then (getVars(GAMMA) in getVars(LHS)) and-then checkCondition(M, LHS, GAMMA)
        then [ HGE | (HE ;; ('_->_[GAMMA,'_=>_[LHS,RHS]])) | HNE ]
        else [ HGE | HE | (HNE ;; ('_->_[GAMMA,'_=>_[LHS,RHS]])) ]
        fi [ owise ] .
    eq hClassify(M, '_->_[GAMMA,'false.NuITP-Bool], [ HGE | HE | HNE ]) = [ HGE | HE | (HNE ;; ('_->_[GAMMA,'false.NuITP-Bool])) ] .
    eq hClassify(M, '_->_[GAMMA,'_\/_[NTL]], [ HGE | HE | HNE ]) =
        if (getVars(GAMMA) in getVars(NTL)) and-then checkCondition(M, NTL, GAMMA)
        then [ HGE | HE ;; ('_->_[GAMMA,'_\/_[NTL]]) | HNE ]
        else [ HGE | HE | HNE ;; ('_->_[GAMMA,'_\/_[NTL]]) ]
        fi [ owise ] .

    eq hClassify(M, ('_->_['true.NuITP-Bool,'_=_[LHS,RHS]]) ;; NTS, [ HGE | HE | HNE ]) = hClassify(M, NTS, [ HGE | HE | (HNE ;; ('_->_['true.NuITP-Bool,'_=_[LHS,RHS]])) ]) .
    eq hClassify(M, ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]]) ;; NTS, [ HGE | HE | HNE ]) =
        if ('_=>_[LHS,RHS] :: GroundTerm)
        then hClassify(M, NTS, [ (HGE ;; ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]])) | HE | HNE ])
        else
            if (getVars(RHS) in getVars(LHS))
            then hClassify(M, NTS, [ HGE | (HE ;; ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]])) | HNE ])
            else hClassify(M, NTS, [ HGE | HE | (HNE ;; ('_->_['true.NuITP-Bool,'_=>_[LHS,RHS]])) ])
            fi
        fi .

    eq hClassify(M, ('_->_[GAMMA,'_=_[LHS,RHS]]) ;; NTS, [ HGE | HE | HNE ]) = hClassify(M, NTS, [ HGE | HE | (HNE ;; ('_->_[GAMMA,'_=_[LHS,RHS]])) ]) [ owise ] .
    eq hClassify(M, ('_->_[GAMMA,'_=>_[LHS,RHS]]) ;; NTS, [ HGE | HE | HNE ]) =
        if (getVars(RHS) in getVars(LHS)) and-then (getVars(GAMMA) in getVars(LHS)) and-then checkCondition(M, LHS, GAMMA)
        then hClassify(M, NTS, [ HGE | (HE ;; ('_->_[GAMMA,'_=>_[LHS,RHS]])) | HNE ])
        else hClassify(M, NTS, [ HGE | HE | (HNE ;; ('_->_[GAMMA,'_=>_[LHS,RHS]])) ])
        fi [ owise ] .
    eq hClassify(M, ('_->_[GAMMA,'false.NuITP-Bool]) ;; NTS, [ HGE | HE | HNE ]) = hClassify(M, NTS, [ HGE | HE | (HNE ;; ('_->_[GAMMA,'false.NuITP-Bool])) ]) .
    eq hClassify(M, ('_->_[GAMMA,'_\/_[NTL]]) ;; NTS, [ HGE | HE | HNE ]) =
        if (getVars(GAMMA) in getVars(NTL)) and-then checkCondition(M, NTL, GAMMA)
        then hClassify(M, NTS, [ HGE | HE ;; ('_->_[GAMMA,'_\/_[NTL]]) | HNE ])
        else hClassify(M, NTS, [ HGE | HE | HNE ;; ('_->_[GAMMA,'_\/_[NTL]]) ])
        fi [ owise ] .

    op hsimp : Module TermSet TermSet -> TermSet .
    eq hsimp(M, SKO, mt) = mt .
    eq hsimp(M, SKO, 'false.NuITP-Bool ;; TS) = 'false.NuITP-Bool . --- In case the lemma trying to prove is actually false
    eq hsimp(M, SKO, NTS) =
        hsimp'(
            e=xu(M, SKO),
            hsimp''(
                addOps(M, SKO),
                hClassify(addOps(M, SKO), orient(addOps(M, SKO), hsimp'(e=xu(M, SKO), disorient(NTS))))
            )
        ) [ owise ] .

    op hsimp' : Module NeTermSet -> TermSet .
    eq hsimp'(M, mt) = mt .
    eq hsimp'(M, 'true.NuITP-Bool) = mt .
    eq hsimp'(M, T) =
        if (getTerm(metaReduce(M, T)) == 'true.NuITP-Bool)
        then mt
        else orient(M, disorient(getTerm(metaReduce(M, T))))
        fi [ owise ] .
    eq hsimp'(M, T ;; NTS) = hsimp'(M, T) ;; hsimp'(M, NTS) .

    op hsimp'' : Module ResultTriple -> TermSet .
    eq hsimp''(M, [ HGE | HE | HNE ]) =
        h''ge(M, HGE) ;;
        h''e++(addEqs(M, h''ge(M, HGE)), HE) ;;
        h''ne(addEqs(M, h''ge(M, HGE)), HNE)
        .

    op h''ge : Module TermSet -> TermSet .
    eq h''ge(M, mt) = mt .
    eq h''ge(M, NTS) = cong-closure(M, NTS) .

    op h''e++ : Module TermSet -> TermSet .
    eq h''e++(M, mt) = mt .
    eq h''e++(M, T) = getTerm(metaReduce(M, T)) .
    eq h''e++(M, T ;; NTS) = getTerm(metaReduce(M, T)) ;; h''e++(M, NTS) .

    op h''ne : Module TermSet -> TermSet .
    eq h''ne(M, mt) = mt .
    eq h''ne(M, T) = getTerm(metaReduce(M, T)) .
    eq h''ne(M, T ;; NTS) = h''ne(M, T) ;; h''ne(M, NTS) .

    op oriented? : TermList -> Bool .
    eq oriented?(empty) = true .
    eq oriented?('true.NuITP-Bool) = true .
    eq oriented?('false.NuITP-Bool) = true .
    eq oriented?('_=_[LHS,RHS]) = false .
    eq oriented?('_=>_[LHS,RHS]) = true .
    eq oriented?('_/\_[NTL]) = oriented?(NTL) .
    eq oriented?('_\/_[NTL]) = oriented?(NTL) .
    eq oriented?('_->_[GAMMA,LAMBDA]) = oriented?(LAMBDA) .
    eq oriented?((T,TL)) = oriented?(T) and-then oriented?(TL) [ owise ] .

    --- Just to show a warning message. NuITP fixes this automatically
    op checkRPOIndices : Module -> Bool .
    eq checkRPOIndices(M) = checkRPOIndices(getOps(M), 0, 0) .

    op checkRPOIndices : OpDeclSet Nat Nat -> Bool .
    eq checkRPOIndices(none, CTOR, DEF) = ((CTOR == 0) and-then (DEF > 0)) or-else (DEF > CTOR) .
    ceq checkRPOIndices((op F : TYL -> TY [ ctor ATS metadata(STR) ] .) OPDS, CTOR, DEF) = checkRPOIndices(OPDS, max(CTOR, N), DEF)
        if N := rat(STR, 10) .
    
    op checkRPOSignature : OpDeclSet -> OpDeclSet .
    ceq checkRPOSignature((op F : TYL -> TY [ ATS metadata(STR) ] .) OPDS) = checkRPOSignature(OPDS) 
        if rat(STR, 10) :: Nat .
    eq checkRPOSignature(OPDS) = OPDS [ owise ] .

    op checkRPOEquations : Module -> [EquationSet] .
    ceq checkRPOEquations(M) = toEqs(checkRPOEquations'(toOrientedClauses(removeNonExec(getEqs(M))), HGE ;; HE))
        if [ HGE | HE | HNE ] := hClassify(M, orient(M, toClauses(removeNonExec(getEqs(M))))) .

    op checkRPOEquations' : TermSet TermSet -> TermSet .
    eq checkRPOEquations'(T ;; TS, T ;; TS') = checkRPOEquations'(TS,TS') .
    eq checkRPOEquations'(TS, TS') = TS [ owise ] .
endfm

fmod NuITP-CONSTRUCTOR is
    pr NuITP-UTILS .

    var M : Module .
    vars T T' T1 T2 LHS RHS : Term .
    vars NTL NTL1 NTL2 : NeTermList .
    vars TL1 TL2 : TermList .
    var N : Nat .
    vars S S' : Sort .
    vars TY TY' : Type .
    var TYL : TypeList .
    var F : Qid .
    var OPD : OpDecl .
    var ATS : AttrSet .
    var C : Constant .
    var V : Variable .
    var TL : TermList .
    var COND : Condition .
    var QS : TermSet .
    var SB : Substitution .
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .
    var K : Kind .
    var KS : KindSet .
    var STR : String .

    op auxModule : Module -> Module .
    eq auxModule(M) = addEqs(addOps(addSubSorts(addSubSorts(addSorts(M,auxSorts(getSorts(M) ; 'NuITP-Bool)),auxSubSorts(getSubsorts(M))),auxSubSorts'(getSorts(M) ; 'NuITP-Bool)), auxOps(getOps(M)) (op 'NuITP-tt : nil -> 'NuITP-Bool [ ctor ] .) (op '_=?=_ : 'Universal 'Universal -> '`[NuITP-Bool`] [ ctor poly (1 2) ] .)),auxEqs(auxSorts(getSorts(M) ; 'NuITP-Bool))) .

    op auxEqs : SortSet -> EquationSet .
    eq auxEqs(none) = none .
    eq auxEqs(S ; SS) = (eq '_=?=_[qid("X:" + cleanString(S)),qid("X:" + cleanString(S))] = 'NuITP-tt.NuITP-Bool [ label('unif) variant ] .) auxEqs(SS) .

    op auxSorts : SortSet -> SortSet .
    eq auxSorts(none) = none .
    eq auxSorts(S ; SS) = qid("#" + string(S)) ; auxSorts(SS) [ owise ] .

    op auxSubSorts : SubsortDeclSet -> SubsortDeclSet .
    eq auxSubSorts(none) = none .
    eq auxSubSorts((subsort S < S' .) SSDS) = (subsort qid("#" + string(S)) < qid("#" + string(S')) .) auxSubSorts(SSDS) .

    op auxSubSorts' : SortSet -> SubsortDeclSet .
    eq auxSubSorts'(none) = none .
    eq auxSubSorts'(S ; SS) = (subsort qid("#" + string(S)) < S .) auxSubSorts'(SS) .

    op auxTypes : TypeList -> TypeList .
    eq auxTypes(nil) = nil .
    eq auxTypes(TY TYL) =
        if startsWith(string(TY), "`[")
        then qid("`[#" + substr(string(TY),2,length(string(TY)))) auxTypes(TYL)
        else qid("#" + string(TY)) auxTypes(TYL)
        fi .

    op auxOps : OpDeclSet -> OpDeclSet .
    eq auxOps(none) = none .
    eq auxOps((op F : TYL -> TY [ ctor ATS ] .) OPDS) = (op F : auxTypes(TYL) -> auxTypes(TY)  [ ctor ATS ] .) auxOps(OPDS) .
    eq auxOps(OPD OPDS) = auxOps(OPDS) [ owise ] .

    op restoreSorts : Substitution -> Substitution .
    eq restoreSorts((none).Substitution) = none .
    eq restoreSorts(V <- T ; SB) = restoreSorts(V) <- restoreSorts(T) ; restoreSorts(SB) [ owise ] .

    op restoreSorts : Term -> Term .
    eq restoreSorts(C) =
        if startsWith(string(getType(C)), "#")
        then qid(string(getName(C)) + "." + substr(string(getType(C)),1,length(string(getType(C)))))
        else C
        fi .
    eq restoreSorts(V) =
        if startsWith(string(getType(V)), "#")
        then qid(string(getName(V)) + ":" + substr(string(getType(V)),1,length(string(getType(V)))))
        else V
        fi .
    eq restoreSorts(F[TL]) = F[restoreSorts'(TL)] .

    op restoreSorts' : TermList -> TermList .
    eq restoreSorts'(empty) = empty .
    eq restoreSorts'((T,TL)) = (restoreSorts(T),restoreSorts'(TL)) .

    op getCUnifiers : Module NeTermList  -> SubstitutionSet .
    eq getCUnifiers(M, '_=_[LHS,RHS]) = getCUnifiers(M, LHS, RHS) .
    eq getCUnifiers(M, (T,NTL)) = getCUnifiers'(M, (T,NTL), empty, empty) .

    op getCUnifiers' : Module TermList TermList TermList -> SubstitutionSet .
    eq getCUnifiers'(M, empty, empty, empty) = mt .
    eq getCUnifiers'(M, empty, T1, T2) = getCUnifiers(M, T1, T2) .
    eq getCUnifiers'(M, empty, (T1,NTL1), (T2,NTL2)) = getCUnifiers(addOps(M, (op 'auxCUWrapper : getTypeList(M, (T1,NTL1)) -> 'NuITP-Bool [ ctor ] .) (op 'auxCUWrapper : getTypeList(M, (T2,NTL2)) -> 'NuITP-Bool [ ctor ] .)), 'auxCUWrapper[(T1,NTL1)], 'auxCUWrapper[(T2,NTL2)]) .
    eq getCUnifiers'(M, ('_=_[LHS,RHS],TL), TL1, TL2) = getCUnifiers'(M, TL, (TL1,LHS), (TL2,RHS)) .

    op getCUnifiers : Module Term Term -> SubstitutionSet .
    eq getCUnifiers(M, T, T) = none . --- Just none, NOT mt.
    eq getCUnifiers(M, T, T') = getCUnifiers(auxModule(M),'_=?=_[T,T'],'NuITP-tt.NuITP-Bool,0) [ owise ] .

    op getCUnifiers : Module Term Term Nat -> SubstitutionSet .
    eq getCUnifiers(M,T,T',N) =
        if (metaVariantUnify(M, T =? T', empty, '#, filter delay, N) :: UnificationPair)
        then restoreSorts(getSubstitution(metaVariantUnify(M, T =? T', empty, '#, filter delay, N))) | getCUnifiers(M,T,T',N + 1)
        else mt
        fi .
endfm

fmod NuITP-RULES-NORMALIZATION is
    pr NuITP-SKOLEM .

    var GID : QidList .
    var RID : Qid .
    vars FRO SFRO INTER : Bool .
    vars SKO HPS TS : TermSet .
    var NTS : NeTermSet .
    vars CLA T : Term .
    var TL : TermList .
    var V : Variable .
    vars N VC : Nat .
    var STR : String .

    op size : TermList -> Nat .
    eq size((empty).TermList) = 0 .
    eq size((T,TL)) = s(size(TL)) .

    op size : TermSet -> Nat .
    eq size((mt).TermSet) = 0 .
    eq size(T ;; TS) = s(size(TS)) .

    op sizeVars : TermSet -> Nat .
    eq sizeVars(mt) = 0 .
    eq sizeVars(T ;; TS) = size(getVars(T)) + sizeVars(TS) .

    --- Just for initial goals with skolem vars.
    op normalizeVars : Goal -> Goal .
    eq normalizeVars({ GID, RID, INTER, FRO, SFRO, 1, SKO, mt, CLA }) = normalizeVars({ GID, RID, INTER, FRO, SFRO, 1, SKO, mt, CLA }, getVars(CLA ;; unfreeze(SKO))) .
    op normalizeVars : Goal TermSet -> Goal .
    eq normalizeVars({ GID, RID, INTER, FRO, SFRO, VC, SKO, mt, CLA }, mt) = { GID, RID, INTER, FRO, SFRO, VC, SKO, mt, freeze(CLA, SKO) } .
    eq normalizeVars({ GID, RID, INTER, FRO, SFRO, VC, SKO, mt, CLA }, V ;; TS) = normalizeVars({ GID, RID, INTER, FRO, SFRO, VC + 1, freeze(applySub(unfreeze(SKO), V <- qid("$" + string(VC, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V))))))), mt, applySub(CLA, V <- qid("$" + string(VC, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V)))))) }, TS) .

    op normalizeVars : Term -> Term .
    eq normalizeVars(T) = normalizeVars(T, getVars(T), 1) .
    op normalizeVars : Term TermSet Nat -> TermList .
    eq normalizeVars(T, mt, N) = T .
    eq normalizeVars(T, V, N) = applySub(T, V <- qid("$" + string(N, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V)))))) .
    eq normalizeVars(T, V ;; NTS, N) = normalizeVars(applySub(T, V <- qid("$" + string(N, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V)))))), NTS, N + 1) .

    op normalizeVars : TermSet Nat -> Substitution .
    eq normalizeVars(mt, N) = none .
    eq normalizeVars(V, N) = V <- qid("$" + string(N, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V))))) .
    eq normalizeVars(V ;; NTS, N) = V <- qid("$" + string(N, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V))))) ; normalizeVars(NTS, N + 1) .

    op normalizeVars : TermSet String Nat -> Substitution .
    eq normalizeVars(mt, STR, N) = none .
    eq normalizeVars(V, STR, N) = V <- qid(STR + string(N, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V))))) .
    eq normalizeVars(V ;; NTS, STR, N) = V <- qid(STR + string(N, 10) + ":" + substr(string(getType(V)), 0, length(string(getType(V))))) ; normalizeVars(NTS, STR, N + 1) .

    op normalizeVarsGenset : TermSet Nat -> TermSet .
    eq normalizeVarsGenset(mt, N) = mt .
    eq normalizeVarsGenset(T ;; TS, N) = applySub(T, normalizeVars(getVars(T), N)) ;; normalizeVarsGenset(TS, N) .

    op normalizeVarsInternal : TermSet String Nat -> TermSet .
    eq normalizeVarsInternal(mt, STR, N) = mt .
    eq normalizeVarsInternal('true.NuITP-Bool ;; TS, STR, N) = normalizeVarsInternal(TS, STR, N) .
    eq normalizeVarsInternal(T ;; TS, STR, N) = applySub(T, normalizeVars(getVars(T), STR, N)) ;; normalizeVarsInternal(TS, STR, N + size(getVars(T))) [ owise ] .
endfm

fmod NuITP-INTERNALIZATION is
    pr NuITP-HSIMP .
    pr NuITP-RULES-NORMALIZATION .

    sorts Internal LocalIntResult .

    vars M INTMOD : Module .
    vars GID GID' : QidList .
    vars RID RID' F : Qid .
    vars FRO SFRO SFRO' INTER INTER' : Bool .
    vars SKO HPS HPS' HGE HE HNE TS INTHPS INTLOCAL LCLAS : TermSet .
    var NTS : NeTermSet .
    vars CLA LEMMA T T1 T2 T3 LHS RHS TPROOF : Term .
    var V : Variable .
    vars N VC : Nat .
    var EQS : EquationSet .
    var GS GOALS GOALS' LGOALS : GoalSet .
    var A : Attr .
    var ATS : AttrSet .
    vars TY TY' TY1 TY2 TY3 : Type .
    vars OPDS OPDS' : OpDeclSet .
    vars TYS TYS' : TypeSet .
    var SB : Substitution .
    var COND : Condition .
    var STR : String .

    op mt : -> Internal [ ctor ] .
    op _|_|_ : Module TermSet TermSet -> Internal [ ctor ] .
    
    op getModule : Internal -> Module .
    eq getModule(INTMOD | INTHPS | INTLOCAL) = INTMOD .

    --- Subsumed goals are automatically removed from the frontier (only those with Skolem, to avoid local internalization of unproved clauses)
    ceq { GID, RID, true, true, SFRO, VC, SKO, HPS, CLA } { GID', RID', INTER', true, SFRO', VC, SKO, HPS, CLA } = { GID, RID, true, true, SFRO, VC, SKO, HPS, CLA } { GID', RID', INTER', false, false, VC, SKO, HPS, CLA } { GID' tokenize(". 1"), 'LSB, INTER', false, false, VC, SKO, HPS, CLA }
        if getSkolem(CLA, SKO) =/= mt .
    ceq { GID, RID, false, true, SFRO, VC, SKO, HPS, CLA } { GID', RID', false, true, SFRO', VC, SKO, HPS, CLA } = { GID, RID, false, true, SFRO, VC, SKO, HPS, CLA } { GID', RID', false, false, false, VC, SKO, HPS, CLA } { GID' tokenize(". 1"), 'LSB, false, false, false, VC, SKO, HPS, CLA } 
        if getSkolem(CLA, SKO) =/= mt .
    ceq { GID, RID, false, true, SFRO, VC, SKO, HPS, CLA } { GID', RID', true, true, SFRO', VC, SKO, HPS, CLA } = { GID, RID, false, false, false, VC, SKO, HPS, CLA } { GID', RID', true, true, SFRO', VC, SKO, HPS, CLA } { GID tokenize(". 1"), 'LSB, false, false, false, VC, SKO, HPS, CLA }
        if getSkolem(CLA, SKO) =/= mt .

    op [_|_] : TermSet GoalSet -> LocalIntResult [ ctor ] .
    op getClauses : LocalIntResult -> TermSet .
    eq getClauses([ LCLAS | LGOALS ]) = LCLAS .
    op getGoals : LocalIntResult -> GoalSet .
    eq getGoals([ LCLAS | LGOALS ]) = LGOALS .
    
    op getLocalInt : GoalSet -> LocalIntResult .
    eq getLocalInt(GOALS) = getLocalInt(GOALS, GOALS, [ mt | mt ]) .

    op getLocalInt : GoalSet GoalSet LocalIntResult -> LocalIntResult .
    eq getLocalInt(GOALS, mt, [ LCLAS | LGOALS ]) = [ LCLAS | LGOALS ] .
    eq getLocalInt(GOALS, { GID, RID, true, FRO, SFRO, VC, SKO, HPS, CLA } GOALS', [ LCLAS | LGOALS ]) = getLocalInt(GOALS, GOALS', [ LCLAS | LGOALS { GID, RID, true, FRO, SFRO, VC, SKO, HPS, CLA } ]) .
    eq getLocalInt(GOALS, { GID, RID, false, FRO, SFRO, VC, SKO, HPS, CLA } GOALS', [ LCLAS | LGOALS ]) = 
        if (getSkolemAsVars(CLA, SKO) == mt) and-then areProven(getChildren(GOALS, GID) { GID, RID, false, FRO, SFRO, VC, SKO, HPS, CLA })
        then getLocalInt(GOALS, GOALS', [ LCLAS ;; CLA | LGOALS { GID, RID, true, FRO, SFRO, VC, SKO, HPS, CLA } ])
        else getLocalInt(GOALS, GOALS', [ LCLAS | LGOALS { GID, RID, false, FRO, SFRO, VC, SKO, HPS, CLA } ])
        fi .

    op internalizeLocal : Module TermSet TermSet TermSet -> Internal .
    eq internalizeLocal(INTMOD, INTHPS, INTLOCAL, mt) = INTMOD | INTHPS | INTLOCAL .
    ---eq internalizeLocal(INTMOD, INTHPS, INTLOCAL, (T ;; TS)) = internalizeLocal(INTMOD, INTHPS, checkLocalSubsumption(INTMOD, INTLOCAL, getTerm(metaReduce(redModule(INTMOD, mt), T))), TS) .
    eq internalizeLocal(INTMOD, INTHPS, INTLOCAL, (T ;; TS)) = internalizeLocal(INTMOD, INTHPS, checkLocalSubsumption(INTMOD, INTLOCAL, getTerm(metaReduce(eqPreds(removeU(INTMOD)), T))), TS) .
    
    op getLocalModule : Internal -> Module .
    eq getLocalModule(INTMOD | INTHPS | INTLOCAL) = getLocalModule(INTMOD, INTLOCAL) .

    op getLocalModule : Module TermSet -> Module .
    eq getLocalModule(INTMOD, INTLOCAL) = getModule(internalizeE(INTMOD, mt, mt, INTLOCAL, "local")) .
    
    op checkLocalSubsumption : Module TermSet Term -> TermSet .
    eq checkLocalSubsumption(INTMOD, mt, T) = normalizeVarsInternal(T, "H", 0) .
    ceq checkLocalSubsumption(INTMOD, T1 ;; INTLOCAL, T2) = (T1 ;; INTLOCAL) 
        if SB := metaMatch(INTMOD, T1, normalizeVarsInternal(T2, "LH", 0), nil, 0) .
    eq checkLocalSubsumption(INTMOD, INTLOCAL, T) = checkLocalSubsumption'(INTMOD, INTLOCAL, T) [ owise ] .
    
    op checkLocalSubsumption' : Module TermSet Term -> TermSet .
    ceq checkLocalSubsumption'(INTMOD, T1 ;; INTLOCAL, T2) = checkLocalSubsumption'(INTMOD, INTLOCAL, T2)
        if SB := metaMatch(INTMOD, normalizeVarsInternal(getTerm(metaReduce(eqPreds(removeU(INTMOD)), T2)), "LH", 0), T1, nil, 0) .
    eq checkLocalSubsumption'(INTMOD, INTLOCAL, T) = INTLOCAL ;; normalizeVarsInternal(getTerm(metaReduce(eqPreds(removeU(INTMOD)), T)), "H", 0) [ owise ] .
    
    op internalize : Module TermSet TermSet GoalSet -> Internal .
    eq internalize(INTMOD, INTHPS, INTLOCAL, GS) = internalize(INTMOD, INTHPS, INTLOCAL, getFreeClauses(GS)) .

    --- Only ONE active at the same time
    op internalize : Module TermSet TermSet TermSet -> Internal .
    eq internalize(INTMOD, INTHPS, INTLOCAL, TS) = internalizeE(INTMOD, INTHPS, INTLOCAL, TS, "internal") .
    ---eq internalize(INTMOD, INTHPS, TS) = internalizeH(INTMOD, INTHPS, TS) .

    --- Executable as equations, non-executable as hypotheses
    op internalizeE : Module TermSet TermSet TermSet String -> Internal .
    eq internalizeE(INTMOD, INTHPS, INTLOCAL, mt, STR) = INTMOD | INTHPS | INTLOCAL .
    ceq internalizeE(INTMOD, INTHPS, INTLOCAL, CLA, STR) = addEqs(INTMOD, toEqs(normalizeVarsInternal(HGE, "H", 0), STR) toEqs(normalizeVarsInternal(HE, "H", 0), STR)) | disorient(hsimp(INTMOD, mt, INTHPS ;; normalizeVarsInternal(HNE, "H", 0))) | INTLOCAL
        if [ HGE | HE | HNE ] := hClassify(INTMOD, split(orient(INTMOD, CLA))) .
    ceq internalizeE(INTMOD, INTHPS, INTLOCAL, (CLA ;; NTS), STR) = internalizeE(addEqs(INTMOD, toEqs(normalizeVarsInternal(HGE, "H", 0)) toEqs(normalizeVarsInternal(HE, "H", 0))), disorient(hsimp(INTMOD, mt, INTHPS ;; normalizeVarsInternal(HNE, "H", 0))), INTLOCAL, NTS, STR)
        if [ HGE | HE | HNE ] := hClassify(INTMOD, split(orient(INTMOD, CLA))) .
    eq internalizeE(INTMOD, INTHPS, INTLOCAL, (CLA ;; TS), STR) = internalizeE(INTMOD, INTHPS, INTLOCAL, TS, STR) [ owise ] .

    --- All as hypotheses
    op internalizeH : Module TermSet TermSet TermSet -> Internal .
    eq internalizeH(INTMOD, INTHPS, INTLOCAL, mt) = INTMOD | INTHPS | INTLOCAL .
    ceq internalizeH(INTMOD, INTHPS, INTLOCAL, CLA) = INTMOD | hsimp(INTMOD, mt, INTHPS ;; normalizeVarsInternal(HGE, "H", 0) ;; normalizeVarsInternal(HE, "H", 0) ;; normalizeVarsInternal(HNE, "H", 0)) | INTLOCAL
        if [ HGE | HE | HNE ] := hClassify(INTMOD, split(orient(INTMOD, CLA))) .
    ceq internalizeH(INTMOD, INTHPS, INTLOCAL, (CLA ;; NTS)) = internalizeH(INTMOD, hsimp(INTMOD, mt, INTHPS ;; normalizeVarsInternal(HGE, "H", 0) ;; normalizeVarsInternal(HE, "H", 0) ;; normalizeVarsInternal(HNE, "H", 0)), INTLOCAL, NTS)
        if [ HGE | HE | HNE ] := hClassify(INTMOD, split(orient(INTMOD, CLA))) .
    eq internalizeH(INTMOD, INTHPS, INTLOCAL, (CLA ;; TS)) = internalizeH(INTMOD, INTHPS, INTLOCAL, TS) [ owise ] .

    --- Axiom internalization and checks for error messages
    op internalize : Module TermSet TermSet Term Attr -> [Internal] .
    ceq internalize(INTMOD, INTHPS, INTLOCAL, CLA, A) = internalize'(INTMOD, INTHPS, INTLOCAL, getTerm(metaNormalize(INTMOD, CLA)), A)
        if checkAxiom(INTMOD, CLA, A) .

    op internalize' : Module TermSet TermSet Term Attr -> [Internal] .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[F[T1,T2],T3]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[F[T1,T2],T3],F[T1,F[T2,T3]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T2,F[T1,T3]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T2,F[T3,T1]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T3,F[T1,T2]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T3,F[T2,T1]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T2,F[T1,T3]],F[T3,F[T1,T2]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T2,F[T1,T3]],F[T3,F[T2,T1]]]], assoc) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), assoc, none) .
    eq internalize'(INTMOD, INTHPS, INTLOCAL, '_->_['true.NuITP-Bool,'_=_[F[T1,T2],F[T2,T1]]], comm) = internalize(INTMOD, INTHPS, INTLOCAL, F, getType(metaNormalize(INTMOD, T1)),getOps(INTMOD), comm, none) .

    op internalize : Module TermSet TermSet Qid Type OpDeclSet Attr OpDeclSet -> [Internal] .
    eq internalize(INTMOD, INTHPS, INTLOCAL, F, TY, (op F : TY TY -> TY [ ATS ] .) OPDS, A, OPDS') = internalize(INTMOD, INTHPS, INTLOCAL, F, TY, OPDS, A, OPDS' (op F : TY TY -> TY [ ATS A ] .)) .
    ceq internalize(INTMOD, INTHPS, INTLOCAL, F, TY, (op F : TY1 TY2 -> TY3 [ ATS ] .) OPDS, A, OPDS') = internalize(INTMOD, INTHPS, INTLOCAL, F, TY, OPDS, A, OPDS' (op F : TY1 TY2 -> TY3 [ ATS A ] .))
        if sameKind(INTMOD, TY, TY1)
        /\ sameKind(INTMOD, TY, TY2)
        /\ sameKind(INTMOD, TY, TY3)
        /\ SB := metaMatch(INTMOD, F[fresh("NuITP-AX1",TY),fresh("NuITP-AX2",TY)], F[fresh("NuITP-AX3",TY1),fresh("NuITP-AX4",TY2)], nil, 0) .
    eq internalize(INTMOD, INTHPS, INTLOCAL, F, TY, OPDS, A, OPDS') = setOps(INTMOD, OPDS OPDS') | INTHPS | INTLOCAL [ owise ] .

    op checkAxiom : Module Term Attr -> Bool .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[F[T1,T2],T3]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, none, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[F[T1,T2],T3],F[T1,F[T2,T3]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, none, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T2,F[T1,T3]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, comm, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T2,F[T3,T1]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, comm, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T3,F[T1,T2]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, comm, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T1,F[T2,T3]],F[T3,F[T2,T1]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, comm, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T2,F[T1,T3]],F[T3,F[T1,T2]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, comm, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T2,F[T1,T3]],F[T3,F[T2,T1]]]], assoc) = checkAxiom(INTMOD,getOps(INTMOD), F, comm, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)) ; getType(metaNormalize(INTMOD, T3)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, '_->_['true.NuITP-Bool,'_=_[F[T1,T2],F[T2,T1]]], comm) = checkAxiom(INTMOD,getOps(INTMOD), F, none, getType(metaNormalize(INTMOD, T1)) ; getType(metaNormalize(INTMOD, T2)), maximalSorts(INTMOD, getKind(INTMOD, getType(metaNormalize(INTMOD, T1))))) .
    eq checkAxiom(INTMOD, CLA, A) = false [ owise ] .

    op checkAxiom : Module OpDeclSet Qid AttrSet TypeSet TypeSet -> Bool .
    eq checkAxiom(INTMOD, (op F : TY TY -> TY [ ATS ] .) OPDS, F, none, TY, TY ; TYS) = true .
    eq checkAxiom(INTMOD, (op F : TY TY -> TY [ ATS comm ] .) OPDS, F, comm, TY, TY ; TYS) = true .
    eq checkAxiom(INTMOD, OPDS, F, ATS, TYS, TYS') = false [ owise ] .

    op checkExec : Internal -> Bool .
    eq checkExec(INTMOD | INTHPS | INTLOCAL) = (hne(INTMOD, mt, orient(INTMOD, toClauses(getEqs(INTMOD)))) == mt) .

    op checkExec : Module -> Bool .
    eq checkExec(INTMOD) = (hne(INTMOD, mt, orient(INTMOD, toClauses(getEqs(INTMOD)))) == mt) .

    op updateInternal : Internal GoalSet -> GoalSet .
    eq updateInternal(INTMOD | NTS | INTLOCAL, { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS) = { GID, RID, INTER, true, SFRO, VC, SKO, hsimp(INTMOD, SKO, HPS ;; NTS), CLA } updateInternal(INTMOD | NTS | INTLOCAL, GS) .
    eq updateInternal(INTMOD | INTHPS | INTLOCAL, GS) = GS [ owise ] .

    op getInternalEqs : Module -> EquationSet .
    eq getInternalEqs(M) = getInternalEqs(getEqs(M)) .

    op getInternalEqs : EquationSet -> EquationSet .
    eq getInternalEqs((eq LHS = RHS [ ATS metadata("internal")] .) EQS) = (eq LHS = RHS [ ATS metadata("internal")] .) getInternalEqs(EQS) .
    eq getInternalEqs((ceq LHS = RHS if COND [ ATS metadata("internal")] .) EQS) = (ceq LHS = RHS if COND [ ATS metadata("internal")] .) getInternalEqs(EQS) .
    eq getInternalEqs(EQS) = none [ owise ] .
endfm

mod NuITP-SIMPLIFICATION-RULES is
    pr NuITP-RULES-NORMALIZATION .
    pr NuITP-HSIMP .
    pr NuITP-CONSTRUCTOR .
    pr NuITP-FREECTOR .

    vars GID GID' : QidList .
    vars F F' RID RID' : Qid .
    vars FRO FRO' SFRO SFRO' B INTER INTER' : Bool .
    vars N N' VC VC' : Nat .
    vars M MR : Module .
    var G : Goal .
    var GS : GoalSet .
    var C : Constant .
    var V : Variable .
    vars T T' HP CLA CLA' GAMMA GAMMA' GAMMA#i GAMMA#i! LAMBDA LAMBDA' LAMBDAi LHS RHS TV TU : Term .
    vars SKO SKO' HPS HEU++ HEU++# TS TS' SKVARS TVARS GAMMA# GAMMA#! INTLOCAL : TermSet .
    vars TL TL' TL'' TUL TVL GAMMAi : TermList .
    vars CO CO' : Context .
    vars NTL NTL' : NeTermList .
    vars NTS NTS' : NeTermSet .
    vars NSB SB SB1 SB2 SB3 SB1' SB2' ALPHA : Substitution .
    var SBS : SubstitutionSet .
    var STR : String .
    var TY : Type .
    var TYL : TypeList .
    var COND : Condition .
    var S : Sort .
    var HEU+ : EquationSet .
    var HNE HEUR+ : RuleSet .
    var GCS : GenSetCollectionSet .
    var FT : FreeTriple .
    var FTS : FreeTripleSet .
    var EQS : EquationSet .
    var EQ : Equation .

    rl [refresh] : M | GCS | INTLOCAL | GS { GID, RID, INTER, true, false, VC, SKO, HPS, CLA } => M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA } .

    --- Equality Predicate Simplification (EPS)
    crl [eps] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        eps(M, ordRewriting(e=xu(M, SKO ;; freeze(getVars(CLA))), toEqs(heu+(M, (SKO ;; freeze(getVars(CLA))), HPS)), toRls(hne(M, SKO, HPS))), { GID, RID, INTER, false, false, VC, SKO, HPS, freeze(CLA) }, freeze(CLA), getVars(CLA), 0, true)
        if (eps(M, ordRewriting(e=xu(M, SKO ;; freeze(getVars(CLA))), toEqs(heu+(M, (SKO ;; freeze(getVars(CLA))), HPS)), toRls(hne(M, SKO, HPS))), { GID, RID, INTER, false, false, VC, SKO, HPS, freeze(CLA) }, freeze(CLA), getVars(CLA), 0, true) =/= mt) .

    op eps : Module Module Goal Term TermSet Nat Bool -> GoalSet .
    eq eps(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, CLA', TVARS, N, true) = eps'(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, getTerm(metaReduce(MR, CLA')), TVARS, N, true) .

    op eps' : Module Module Goal Term TermSet Nat Bool -> GoalSet .
    eq eps'(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, CLA', TVARS, N, true) =
        if (metaSearch(MR, CLA, 'RES:`[NuITP-Bool`], nil, '!, unbounded, N) :: ResultTriple)
        then
            if (getTerm(metaSearch(MR, CLA, 'RES:`[NuITP-Bool`], nil, '!, unbounded, N)) == 'true.NuITP-Bool)
            then { GID tokenize(". 1"), 'EPS, false, false, false, VC, SKO, HPS, 'true.NuITP-Bool }
            else
                if (getTerm(metaSearch(MR, CLA, 'RES:`[NuITP-Bool`], nil, '!, unbounded, N)) == 'false.NuITP-Bool)
                then { GID tokenize(". 1"), 'EPS, false, false, false, VC, SKO, HPS, 'false.NuITP-Bool }
                else eps'(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, getTerm(metaSearch(MR, CLA, 'RES:`[NuITP-Bool`], nil, '!, unbounded, N)), TVARS, N + 1, true)
                fi
            fi
        else 
            if (getTerm(metaReduce(redModule(M, SKO), unfreeze(CLA, TVARS))) == getTerm(metaReduce(redModule(M, SKO), unfreeze(CLA', TVARS)))) 
            then mt 
            else { GID tokenize(". 1"), 'EPS, false, true, false, VC, SKO, HPS, getTerm(metaReduce(redModule(M, SKO), unfreeze(CLA', TVARS))) } 
            fi
        fi .

    op ordRewriting : Module EquationSet RuleSet -> Module .
    eq ordRewriting(M, HEU+, none) = addEqs(M, HEU+) .
    eq ordRewriting(M, HEU+, HNE) = addRls(addEqs(aac-compWithOrd(M), getEqs(M) HEU+), HNE) [ owise ] .

    op ordRewriting : Module RuleSet RuleSet -> Module .
    eq ordRewriting(M, HEUR+, none) = addRls(M, HEUR+) .
    eq ordRewriting(M, HEUR+, HNE) = addRls(addEqs(aac-compWithOrd(M), getEqs(M)), HEUR+ HNE) [ owise ] .

    --- Constructor Variant Unification Left (CVUL)
    crl [cvul] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        cvul(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, NTL, TL, getSkolemAsVars(NTL, SKO), getCUnifiers(M, unfreeze(NTL, SKO)), 1)
        if { NTL :: TL } := splitBySigma(addOps(M, SKO), GAMMA) .

    op cvul : Module Goal NeTermList TermList TermSet SubstitutionSet Nat -> GoalSet .
    eq cvul(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, NTL, TL, SKVARS, mt, 1) = { GID tokenize(". 1"), 'CVUL, false, false, false, VC, SKO, HPS, 'true.NuITP-Bool } .
    eq cvul(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, NTL, TL, SKVARS, mt, N) = mt [ owise ] .
    eq cvul(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, NTL, empty, SKVARS, SB | SBS, N) =
        {
            GID tokenize(". " + string(N,10)),
            'CVUL,
            false,
            true,
            false,
            VC + size(getRanVars(SB)),
            SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC))))),
            hsimp(
                M,
                SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC))))),
                HPS ;; cvulHPS(SKVARS, freeze(applySub(SB, normalizeVars(getRanVars(SB), VC)), SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC)))))))
            ),
            getTerm(metaReduce(
                redModule(M, SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC)))))),
                freeze(applySub(unfreeze('_->_['true.NuITP-Bool,LAMBDA], SKO), applySub(SB, normalizeVars(getRanVars(SB), VC))), SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC))))))
            ))
        }
        cvul(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, NTL, empty, SKVARS, SBS, N + 1) .
    eq cvul(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, NTL, NTL', SKVARS, SB | SBS, N) =
        {
            GID tokenize(". " + string(N,10)),
            'CVUL,
            false,
            true,
            false,
            VC + size(getRanVars(SB)),
            SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC))))),
            hsimp(
                M,
                SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC))))),
                HPS ;; cvulHPS(SKVARS, freeze(applySub(SB, normalizeVars(getRanVars(SB), VC)), SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC)))))))
            ),
            getTerm(metaReduce(
                redModule(M, SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC)))))),
                freeze(applySub(unfreeze('_->_[wrapAnd(NTL'),LAMBDA], SKO), applySub(SB, normalizeVars(getRanVars(SB), VC))), SKO ;; freeze(getVars(applySub(SKVARS, applySub(SB, normalizeVars(getRanVars(SB), VC))))))
            ))
        }
        cvul(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, NTL, NTL', SKVARS, SBS, N + 1) .

    op cvulHPS : TermSet Substitution -> TermSet .
    eq cvulHPS(mt, SB) = mt .
    eq cvulHPS(V, SB) = '_->_['true.NuITP-Bool,'_=_[freeze(V),applySub(V, SB)]] .
    eq cvulHPS(V ;; NTS, SB) = ('_->_['true.NuITP-Bool,'_=_[freeze(V),applySub(V, SB)]]) ;; cvulHPS(NTS, SB) .


    --- Constructor Variant Unification Failure Right (CVUFR)
    crl [cvufr] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA,'_=_[LHS,RHS]] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA,'_=_[LHS,RHS]] }
        cvufr(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA,'_=_[LHS,RHS]] }, LHS, RHS)
        if isSigma1?(addOps(M, SKO), '_=_[LHS,RHS])
        /\ getCUnifiers(addOps(M, SKO), unfreeze(LHS, SKO), unfreeze(RHS, SKO)) == mt .

    crl [cvufr] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA, '_\/_[TL,'_=_[LHS,RHS],TL']] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA, '_\/_[TL,'_=_[LHS,RHS],TL']] }
        cvufr(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA, '_\/_[TL,'_=_[LHS,RHS],TL']] }, LHS, RHS)
        if isSigma1?(addOps(M, SKO), '_=_[LHS,RHS])
        /\ getCUnifiers(addOps(M, SKO), unfreeze(LHS, SKO), unfreeze(RHS, SKO)) == mt .


    op cvufr : Module Goal Term Term -> GoalSet .
    eq cvufr(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,'_=_[LHS,RHS]] }, LHS, RHS) =
        {
            GID tokenize(". 1"),
            'CVUFR,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO),'_->_[GAMMA,'false.NuITP-Bool]))
        } .
    eq cvufr(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA, '_\/_[TL,'_=_[LHS,RHS],TL']] }, LHS, RHS) =
        {
            GID tokenize(". 1"),
            'CVUFR,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO),'_->_[GAMMA,'_\/_[TL,'false.NuITP-Bool,TL']]))
        } .


    --- Substitution Left (SUBL)
    crl [subl] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_['_=_[V,T],LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_['_=_[V,T],LAMBDA] }
        subl(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_['_=_[V,T],LAMBDA] }, V, T)
        if sortLeq(M,leastSort(addOps(M, SKO), T), getType(V))
        /\ not(V in getVars(T))
        /\ not(isSigma1?(addOps(M, SKO), T)) .

    crl [subl] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[V,T],TL'],LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[V,T],TL'],LAMBDA] }
        subl(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[V,T],TL'],LAMBDA] }, V, T)
        if sortLeq(M,leastSort(addOps(M, SKO), T), getType(V))
        /\ not(V in getVars(T))
        /\ not(isSigma1?(addOps(M, SKO), T))
        /\ not(isSigma1?(addOps(M, SKO), (TL,TL'))) .

    crl [subl] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, C ;; SKO, HPS, '_->_['_=_[C,T],LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, C ;; SKO, HPS, '_->_['_=_[C,T],LAMBDA] }
        subl(M, { GID, RID, INTER, true, false, VC, C ;; SKO, HPS, '_->_['_=_[C,T],LAMBDA] }, C, T)
        if sortLeq(addOps(M, C ;; SKO), leastSort(M,T), getType(C))
        /\ not(C in getVars(T))
        /\ not(isSigma1?(addOps(M, C ;; SKO), T)) .

    crl [subl] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, C ;; SKO, HPS, '_->_['_/\_[TL,'_=_[C,T],TL'],LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, C ;; SKO, HPS, '_->_['_/\_[TL,'_=_[C,T],TL'],LAMBDA] }
        subl(M, { GID, RID, INTER, true, false, VC, C ;; SKO, HPS, '_->_['_/\_[TL,'_=_[C,T],TL'],LAMBDA] }, C, T)
        if sortLeq(addOps(M, C ;; SKO), leastSort(M,T), getType(C))
        /\ not(C in getVars(T))
        /\ not(isSigma1?(addOps(M, C ;; SKO), T))
        /\ not(isSigma1?(addOps(M, C ;; SKO), (TL,TL'))) .

    op subl : Module Goal Term Term -> GoalSet .
    eq subl(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_['_=_[V,T],LAMBDA] }, V, T) =
        {
            GID tokenize(". 1"),
            'SUBL,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), applySub('_->_['true.NuITP-Bool,LAMBDA], (V <- T))))
        } .
    eq subl(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[V,T],TL'],LAMBDA] }, V, T) =
        {
            GID tokenize(". 1"),
            'SUBL,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), applySub('_->_[(TL,TL'),LAMBDA], (V <- T))))
        } .
    eq subl(M, { GID, RID, INTER, FRO, SFRO, VC, C ;; SKO, HPS, '_->_['_=_[C,T],LAMBDA] }, C, T) =
        {
            GID tokenize(". 1"),
            'SUBL,
            false,
            true,
            false,
            VC,
            (C ;; SKO ;; freeze(getVars(T))),
            hsimp(
                M,
                (C ;; SKO ;; freeze(getVars(T))),
                (HPS ;; ('_->_['true.NuITP-Bool,'_=_[C,freeze(T)]]))
            ),
            getTerm(metaReduce(
                redModule(M, (C ;; SKO ;; freeze(getVars(T)))),
                freeze(applySub(unfreeze('_->_['true.NuITP-Bool,LAMBDA], C), (unfreeze(C) <- freeze(T))), freeze(getVars(T)))
            ))
        } .
    eq subl(M, { GID, RID, INTER, FRO, SFRO, VC, C ;; SKO, HPS, '_->_['_/\_[TL,'_=_[C,T],TL'],LAMBDA] }, C, T) =
        {
            GID tokenize(". 1"),
            'SUBL,
            false,
            true,
            false,
            VC,
            (C ;; SKO ;; freeze(getVars(T))),
            hsimp(
                M,
                (C ;; SKO ;; freeze(getVars(T))),
                (HPS ;; ('_->_['true.NuITP-Bool,'_=_[C,freeze(T)]]))
            ),
            getTerm(metaReduce(
                redModule(M, (C ;; SKO ;; freeze(getVars(T)))),
                freeze(applySub(unfreeze('_->_[(TL,TL'),LAMBDA], C), (unfreeze(C) <- freeze(T))), freeze(getVars(T)))
            ))
        } .


    --- Substitution Right (SUBR)
    crl [subr] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[V,T],TL']] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[V,T],TL']] }
        subr(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[V,T],TL']] }, V, T)
        if (wrapAnd((TL,TL')) =/= 'true.NuITP-Bool)
        /\ sortLeq(addOps(M, SKO), leastSort(addOps(M, SKO), T), getType(V))
        /\ not(V in T) .

    crl [subr] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, C ;; SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[C,T],TL']] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, C ;; SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[C,T],TL']] }
        subr(M, { GID, RID, INTER, true, false, VC, C ;; SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[C,T],TL']] }, C, T)
        if (wrapAnd((TL,TL')) =/= 'true.NuITP-Bool)
        /\ sortLeq(addOps(M, C ;; SKO), leastSort(addOps(M, C ;; SKO), T), getType(C))
        /\ not(C in T) .

    op subr : Module Goal Term Term -> GoalSet .
    eq subr(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[V,T],TL']] }, V, T) =
        {
            GID tokenize(". 1"),
            'SUBR,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(
                redModule(M, SKO),
                '_->_[GAMMA,'_=_[V,T]]
            ))
        }
        {
            GID tokenize(". 2"),
            'SUBR,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(
                redModule(M, SKO),
                applySub('_->_[GAMMA, (TL,TL')], (V <- T))
            ))
        } .
    eq subr(M, { GID, RID, INTER, FRO, SFRO, VC, C ;; SKO, HPS, '_->_[GAMMA,'_/\_[TL,'_=_[C,T],TL']] }, C, T) =
        {
            GID tokenize(". 1"),
            'SUBR,
            false,
            true,
            false,
            VC,
            C ;; SKO,
            HPS,
            getTerm(metaReduce(
                redModule(M, C ;; SKO),
                '_->_[GAMMA,'_=_[C,T]]
            ))
        }
        {
            GID tokenize(". 2"),
            'SUBR,
            false,
            true,
            false,
            VC,
            (C ;; (SKO ;; freeze(getVars(T)))),
            hsimp(
                M,
                (C ;; (SKO ;; freeze(getVars(T)))),
                (HPS ;; ('_->_[GAMMA,'_=_[C,freeze(T)]]))
            ),
            getTerm(metaReduce(
                redModule(M, (C ;; (SKO ;; freeze(getVars(T))))),
                freeze(applySub(unfreeze('_->_[GAMMA, (TL,TL')], C), (unfreeze(C) <- freeze(T))), freeze(getVars(T)))
            ))
        } .


    --- Narrowing Simplification (NS)
    crl [ns] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        ns(M, euR(M, F[NTL]), { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, F[NTL], getSkolemAsVars(F[NTL], SKO), RHS, freeze(unfreeze(CO), SKO), 0)
        if (('_=_[F[NTL],RHS]) ;; TS) := getEqualities(CLA)
        /\ isSigma1?(addOps(M, SKO), RHS)
        /\ not(sigma1Top?(addOps(M, SKO), F[NTL]))
        /\ isNarrowex(euR(addOps(M, SKO), F[NTL]), F[NTL])
        /\ { none , CO } := metaXmatch(addOps(M, SKO ;; freeze(getVars(CLA))), freeze('_=_[F[NTL],RHS]), freeze(CLA), nil, 0, unbounded, 0) .

    crl [ns] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        ns(M, euR(M, F[NTL]), { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, F[NTL], getSkolemAsVars(F[NTL], SKO), LHS, freeze(unfreeze(CO), SKO), 0)
        if (('_=_[LHS,F[NTL]]) ;; TS) := getEqualities(CLA)
        /\ isSigma1?(addOps(M, SKO), LHS)
        /\ not(sigma1Top?(addOps(M, SKO), F[NTL]))
        /\ isNarrowex(euR(addOps(M, SKO), F[NTL]), F[NTL])
        /\ { none , CO } := metaXmatch(addOps(M, SKO ;; freeze(getVars(CLA))), freeze('_=_[LHS,F[NTL]]), freeze(CLA), nil, 0, unbounded, 0) .

    crl [ins] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        ns(M, euR(M, ARG1:Term), { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, ARG1:Term, getSkolemAsVars(ARG1:Term, SKO), RHS, freeze(unfreeze(CO), SKO), 0)
        if (('_=_[ARG1:Term,RHS]) ;; TS) := getEqualities(CLA)
        /\ isSigma1?(addOps(M, SKO), RHS)
        /\ not(sigma1Top?(addOps(M, SKO), ARG1:Term))
        /\ isNarrowex(euR(addOps(M, SKO), ARG1:Term), ARG1:Term)
        /\ { none , CO } := metaXmatch(addOps(M, SKO ;; freeze(getVars(CLA))), freeze('_=_[ARG1:Term,RHS]), freeze(CLA), nil, 0, unbounded, 0) [ nonexec ] .

    crl [ins] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        ns(M, euR(M, ARG1:Term), { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, ARG1:Term, getSkolemAsVars(ARG1:Term, SKO), LHS, freeze(unfreeze(CO), SKO), 0)
        if (('_=_[LHS,ARG1:Term]) ;; TS) := getEqualities(CLA)
        /\ isSigma1?(addOps(M, SKO), LHS)
        /\ not(sigma1Top?(addOps(M, SKO), ARG1:Term))
        /\ isNarrowex(euR(addOps(M, SKO), ARG1:Term), ARG1:Term)
        /\ { none , CO } := metaXmatch(addOps(M, SKO ;; freeze(getVars(CLA))), freeze('_=_[LHS,ARG1:Term]), freeze(CLA), nil, 0, unbounded, 0) [ nonexec ] .

    op ns : Module Module Goal Term TermSet Term Context Nat -> GoalSet .
    ceq ns(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, SKVARS, TU, CO, N) =
        {
            GID tokenize(". " + string(N + 1,10)),
            'NS,
            false,
            true,
            false,
            VC + size(getRanVars(SB1 ; SB2)),
            (SKO ;; freshSKO(SB3, SKVARS)),
            nsHPS(
                M,
                (SKO ;; freshSKO(SB3, SKVARS)),
                HPS,
                (SB3),
                SKVARS,
                SKVARS,
                mt
            ),
            getTerm(metaReduce(
                redModule(M, (SKO ;; freshSKO(SB3, SKVARS))),
                freeze(addGamma(applySub(replaceHole(CO, '_=_[(applySub(T, NSB)),TU]), (SB3)), GAMMAi), (SKO ;; freshSKO(SB3, SKVARS)))
            ))
        }
        ns(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, SKVARS, TU, CO, N + 1)
        if { T, TY, [], F, SB1, SB2, F' } := metaNarrowingApply(addOps(MR, SKO), unfreeze(TV, SKO), empty, '#, none, N)
        /\ NSB := normalizeVars(getRanVars(SB1 ; SB2), VC)
        /\ SB3 := applySub(SB1 ; SB2, NSB)
        /\ GAMMAi := applySub(getCondition(getRls(MR), F), SB3) .
    eq ns(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, SKVARS, TU, CO, N) = mt [ owise ] .

    op freshSKO : Substitution TermSet -> TermSet .
    eq freshSKO(SB, mt) = mt .
    eq freshSKO(V <- T ; SB, V ;; TS) = freshSKO(SB, getVars(T) ;; V ;; TS) .
    eq freshSKO(SB, NTS) = freeze(NTS) [ owise ] .

    op nsHPS : Module TermSet TermSet Substitution TermSet TermSet TermSet -> TermSet .
    eq nsHPS(M, SKO, HPS, ALPHA, SKVARS, mt, mt) = HPS .
    eq nsHPS(M, SKO, HPS, ALPHA, SKVARS, mt, NTS) = hsimp(M, SKO, HPS ;; NTS) .
    eq nsHPS(M, SKO, HPS, ALPHA, SKVARS, T ;; TS, TS') = nsHPS(M, SKO, HPS, ALPHA, SKVARS, TS, TS' ;; ('_->_['true.NuITP-Bool,'_=_[freeze(T, SKO), freeze(unfreeze(applySub(T, ALPHA), SKVARS), SKO)]])) .


    --- Clause Subsumption (CS)
    crl [cs] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, (HPS ;; ('_->_[GAMMA,'false.NuITP-Bool])), '_->_[GAMMA',LAMBDA'] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, (HPS ;; ('_->_[GAMMA,'false.NuITP-Bool])), '_->_[GAMMA',LAMBDA'] }
        {
            GID tokenize(". 1"),
            'CS,
            false,
            true,
            false,
            VC,
            SKO,
            (HPS ;; ('_->_[GAMMA,'false.NuITP-Bool])),
            'true.NuITP-Bool
        }
        if cs(addOps(M,SKO), GAMMA, GAMMA') == 'true.NuITP-Bool .

    crl [cs] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, (HPS ;; ('_->_[GAMMA,LAMBDA])), '_->_[GAMMA',LAMBDA'] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, (HPS ;; ('_->_[GAMMA,LAMBDA])), '_->_[GAMMA',LAMBDA'] }
        {
            GID tokenize(". 1"),
            'CS,
            false,
            true,
            false,
            VC,
            SKO,
            (HPS ;; ('_->_[GAMMA,LAMBDA])),
            getTerm(metaReduce(redModule(M, SKO), '_->_[GAMMA',T]))
        }
        if T := cs(addOps(M,SKO), GAMMA, disorient(LAMBDA), GAMMA', LAMBDA') .

    crl [cs] :
        M | GCS | (INTLOCAL ;; ('_->_[GAMMA,'false.NuITP-Bool])) | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA',LAMBDA'] }
        =>
        M | GCS | (INTLOCAL ;; ('_->_[GAMMA,'false.NuITP-Bool])) | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA',LAMBDA'] }
        {
            GID tokenize(". 1"),
            'CS,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            'true.NuITP-Bool
        }
        if cs(addOps(M,SKO), GAMMA, GAMMA') == 'true.NuITP-Bool .

    crl [cs] :
        M | GCS | (INTLOCAL ;; ('_->_[GAMMA,LAMBDA])) | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA',LAMBDA'] }
        =>
        M | GCS | (INTLOCAL ;; ('_->_[GAMMA,LAMBDA])) | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA',LAMBDA'] }
        {
            GID tokenize(". 1"),
            'CS,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), '_->_[GAMMA',T]))
        }
        if T := cs(addOps(M,SKO), GAMMA, disorient(LAMBDA), GAMMA', LAMBDA') .

    op cs : Module Term Term -> Term .
    ceq cs(M, GAMMA, GAMMA') = 'true.NuITP-Bool
        if SB := metaMatch(M, GAMMA, GAMMA', nil, 0) .
    ceq cs(M, GAMMA, GAMMA') = 'true.NuITP-Bool
        if SB := metaMatch(M, '_/\_['NuITP-ES:`[NuITP-ConjEqDisj`,NuITP-Clause`],GAMMA], GAMMA', nil, 0) .

    op cs : Module Term Term Term Term -> [Term] .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = 'true.NuITP-Bool
        if SB := metaMatch(M, '_->_[GAMMA,LAMBDA], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = 'true.NuITP-Bool
        if SB := metaMatch(M, '_->_[GAMMA,'_\/_[LAMBDA,'NuITP-ES':`[NuITP-ConjEqDisj`,NuITP-Clause`]]], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = applySub('NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`],SB)
        if SB := metaMatch(M, '_->_[GAMMA,'_/\_[LAMBDA,'NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`]]], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = applySub('NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`],SB)
        if SB := metaMatch(M, '_->_[GAMMA,'_/\_['_\/_[LAMBDA,'NuITP-ES':`[NuITP-ConjEqDisj`,NuITP-Clause`]],'NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`]]], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = 'true.NuITP-Bool
        if SB := metaMatch(M, '_->_['_/\_['NuITP-ES:`[NuITP-ConjEqDisj`,NuITP-Clause`],GAMMA],LAMBDA], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = 'true.NuITP-Bool
        if SB := metaMatch(M, '_->_['_/\_['NuITP-ES:`[NuITP-ConjEqDisj`,NuITP-Clause`],GAMMA],'_\/_[LAMBDA,'NuITP-ES':`[NuITP-ConjEqDisj`,NuITP-Clause`]]], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = applySub('NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`],SB)
        if SB := metaMatch(M, '_->_['_/\_['NuITP-ES:`[NuITP-ConjEqDisj`,NuITP-Clause`],GAMMA],'_/\_[LAMBDA,'NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`]]], '_->_[GAMMA',LAMBDA'], nil, 0) .
    ceq cs(M, GAMMA, LAMBDA, GAMMA', LAMBDA') = applySub('NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`],SB)
        if SB := metaMatch(M, '_->_['_/\_['NuITP-ES:`[NuITP-ConjEqDisj`,NuITP-Clause`],GAMMA],'_/\_['_\/_[LAMBDA,'NuITP-ES':`[NuITP-ConjEqDisj`,NuITP-Clause`]],'NuITP-ESC:`[NuITP-ConjEqDisj`,NuITP-Clause`]]], '_->_[GAMMA',LAMBDA'], nil, 0) .


    --- Inductive Congruence Closure (ICC)
    crl [icc] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        icc(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, SKO', GAMMA#!)
        if SKO' := freeze(getVars('_->_[GAMMA,LAMBDA]))
        /\ GAMMA# := cong-closure(addOps(M, SKO ;; SKO'), hgeu(M, (SKO ;; SKO'), HPS) ;; freeze(GAMMA))
        /\ GAMMA#! := iccGamma#!(addEqs(e=xu(M, SKO ;; SKO'), hgeu(M, (SKO ;; SKO'), HPS) ;; heu++(M, (SKO ;; SKO'), HPS)), GAMMA#, mt)
        /\ icc(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, SKO', GAMMA#!) =/= mt .

    op iccGamma#! : Module TermSet TermSet -> [TermSet] .
    eq iccGamma#!(M, mt, GAMMA#!) = wrapAndCC(GAMMA#!) .
    ceq iccGamma#!(M, GAMMA#i ;; GAMMA#, GAMMA#!) =
        if (GAMMA#i! == 'false.NuITP-Bool)
        then 'false.NuITP-Bool
        else iccGamma#!(M, GAMMA#, GAMMA#! ;; GAMMA#i!)
        fi
        if GAMMA#i! := (getTerm(metaSearch(addRls(M, GAMMA# ;; GAMMA#!), GAMMA#i, 'RES:`[NuITP-Bool`], nil, '!, unbounded, 0))) .

    op icc : Module Goal TermSet TermSet -> GoalSet .
    eq icc(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, SKO', 'false.NuITP-Bool ;; GAMMA#!) = { GID tokenize(". 1"), 'ICC, false, false, false, VC, SKO, HPS, 'true.NuITP-Bool } .
    eq icc(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, SKO', GAMMA#!) =
        if (iccFilter({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, icc'(M, VC, SKO, SKO', HPS,  hgeu(M, (SKO ;; SKO'), HPS) ;; heu++(M, (SKO ;; SKO'), HPS), LAMBDA, GAMMA#!)) == mt)
        then mt
        else
            if iccAllTrue(icc'(M, VC, SKO, SKO', HPS, hgeu(M, (SKO ;; SKO'), HPS) ;; heu++(M, (SKO ;; SKO'), HPS), LAMBDA, GAMMA#!))
            then { GID tokenize(". 1"), 'ICC, false, false, false, VC, SKO, HPS, 'true.NuITP-Bool }
            else indexGoals(icc'(M, VC, SKO, SKO', HPS, hgeu(M, (SKO ;; SKO'), HPS) ;; heu++(M, (SKO ;; SKO'), HPS), LAMBDA, GAMMA#!), GID, 1)
            fi
        fi [ owise ] .

    op icc' : Module Nat TermSet TermSet TermSet TermSet Term TermSet -> GoalSet .
    eq icc'(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, mt) = mt .
    eq icc'(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, GAMMA#i ;; GAMMA#) = icc''(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, GAMMA#i, 0) icc'(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, GAMMA#) .

    op icc'' : Module Nat TermSet TermSet TermSet TermSet Term Term Nat -> GoalSet .
    ceq icc''(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, GAMMA#i, N) =
        {
            nil,
            'ICC,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), '_->_[disorient(unfreeze(GAMMA#i, SKO')),unfreeze(LAMBDAi, SKO')]))
        } icc''(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, GAMMA#i, N + 1)
        if LAMBDAi := getTerm(metaSearch(addEqs(addOps(eqPreds(removeU(M)), SKO ;; SKO'), (HEU++ ;; GAMMA#i)), freeze(LAMBDA), 'RES:`[NuITP-Bool`], nil, '!, unbounded, N)) .
    eq icc''(M, VC, SKO, SKO', HPS, HEU++, LAMBDA, GAMMA#i, N) = mt [ owise ] .

    op iccAllTrue : GoalSet -> Bool .
    eq iccAllTrue(mt) = true .
    eq iccAllTrue({ GID, 'ICC, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,'true.NuITP-Bool] } GS) = iccAllTrue(GS) .
    eq iccAllTrue(GS) = false [ owise ] .

    op iccFilter : Goal GoalSet -> GoalSet .
    eq iccFilter({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, { GID', RID', INTER', FRO', SFRO', VC', SKO, HPS, CLA } GS) = iccFilter({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, GS) .
    eq iccFilter(G, GS) = GS [ owise ] .


    --- Variant Satisfiability (VARSAT)
    crl [varsat] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        { GID tokenize(". 1"), 'VARSAT, false, false, false, VC, SKO, HPS, 'true.NuITP-Bool }
        if isSigma1?(addOps(M, SKO), CLA)
        /\ not(sat?(sigma1(addOps(M, SKO)), toDNF(sigma1(addOps(M, SKO)), 'not_[unfreeze(CLA, SKO)]))) .

    op sat? : Module Term -> Bool . --- TODO
    eq sat?(M, 'not_[T]) = not(sat?(M, T)) .
    eq sat?(M, '_\/_[T,T']) = sat?(M, T) or-else sat?(M, T') .
    eq sat?(M, '_\/_[T,T',NTL]) = sat?(M, T) or-else sat?(M, '_\/_[T',NTL]) .
    eq sat?(M, '_/\_[NTL]) = sat?(M, NTL, empty, empty, nil) .
    eq sat?(M, '_=_[TU,TV]) = (metaVariantUnify(auxModule(M), '_=?=_[TU,TV] =? 'NuITP-tt.NuITP-Bool, empty, '#, filter delay, 0) :: UnificationPair) .

    op sat? : Module TermList TermList TermList TypeList -> Bool .
    eq sat?(M, empty, TUL, TVL, TYL) = (metaVariantUnify(auxModule(addOps(M, (op 'auxWrapper : TYL -> 'NuITP-Bool [ ctor ] .))), '_=?=_['auxWrapper[TUL],'auxWrapper[TVL]] =? 'NuITP-tt.NuITP-Bool, empty, '#, filter delay, 0) :: UnificationPair) .
    eq sat?(M, '_=_[TU,TV], TUL, TVL, TYL) = sat?(M, empty, (TUL,TU), (TVL,TV), (TYL getKind(M, leastSort(M, TU)))) .
    eq sat?(M, ('_=_[TU,TV],NTL), TUL, TVL, TYL) = sat?(M, NTL, (TUL,TU), (TVL,TV), (TYL getKind(M, leastSort(M, TU)))) .


    --- Equality (EQ)
    --- Hypothesis-based
    crl [eq] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS ;; HP, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS ;; HP, CLA }
        { GID tokenize(". 1"), 'EQ, false, true, false, VC, SKO, HPS ;; HP, getTerm(metaReduce(redModule(M, SKO), T')) }
        if '_->_[GAMMA,'_=_[LHS,RHS]] := disorient(HP)
        /\ (metaMatch(addOps(M, SKO ;; freeze(getVars(HP)) ;; freeze(getVars(ARG1:Term))), freeze('_->_[GAMMA,'_=_[LHS,RHS]]), freeze(disorient(wrapCond(ARG1:Term))), nil, 0) == none)
           or-else 
           ((metaMatch(addOps(M, SKO ;; freeze(getVars(HP)) ;; freeze(getVars(ARG1:Term))), freeze('_->_[GAMMA,'_=_[RHS,LHS]]), freeze(disorient(wrapCond(ARG1:Term))), nil, 0) == none))
        /\ { T, TY, SB, CO } := metaXapply(addRls(addOps(addOps(setEqs(M, none), SKO), (op 'NuITP-EQ : getType(metaNormalize(addOps(M, SKO), RHS)) -> getType(metaNormalize(addOps(M, SKO), RHS)) [ strat(0) ] .)), wrapEQ(toRls(wrapCond(ARG1:Term), ARG2:Substitution), 'NuITP-EQ)), CLA, 'NuITP-EQRL, none, 0, unbounded, 0)
        /\ T' := unwrapEQ(T)
        [ nonexec ] .

    crl [eq] :
        M | GCS | INTLOCAL ;; HP | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL ;; HP | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        { GID tokenize(". 1"), 'EQ, false, true, false, VC, SKO, HPS ;; HP, getTerm(metaReduce(redModule(M, SKO), T')) }
        if '_->_[GAMMA,'_=_[LHS,RHS]] := disorient(HP)
        /\ (metaMatch(addOps(M, SKO ;; freeze(getVars(HP)) ;; freeze(getVars(ARG1:Term))), freeze('_->_[GAMMA,'_=_[LHS,RHS]]), freeze(disorient(wrapCond(ARG1:Term))), nil, 0) == none)
           or-else 
           (metaMatch(addOps(M, SKO ;; freeze(getVars(HP)) ;; freeze(getVars(ARG1:Term))), freeze('_->_[GAMMA,'_=_[RHS,LHS]]), freeze(disorient(wrapCond(ARG1:Term))), nil, 0) == none)
        /\ { T, TY, SB, CO } := metaXapply(addRls(addOps(addOps(setEqs(M, none), SKO), (op 'NuITP-EQ : getType(metaNormalize(addOps(M, SKO), RHS)) -> getType(metaNormalize(addOps(M, SKO), RHS)) [ strat(0) ] .)), wrapEQ(toRls(wrapCond(ARG1:Term), ARG2:Substitution), 'NuITP-EQ)), CLA, 'NuITP-EQRL, none, 0, unbounded, 0)
        /\ T' := unwrapEQ(T)
        [ nonexec ] .
    
    --- Equation-based
    crl [eq] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        { GID tokenize(". 1"), 'EQ, false, true, false, VC, SKO, HPS, getTerm(metaReduce(redModule(M, SKO), T')) }
        if EQ := getEquation(M, ARG1:Qid)
        /\ '_->_[GAMMA,'_=>_[LHS,RHS]] := toOrientedClauses(EQ)
        /\ { T, TY, SB, CO } := metaXapply(addRls(addOps(addOps(setEqs(M, none), SKO), (op 'NuITP-EQ : getType(metaNormalize(addOps(M, SKO), RHS)) -> getType(metaNormalize(addOps(M, SKO), RHS)) [ strat(0) ] .)), wrapEQ(toRls(wrapCond((if ARG3:Bool then ('_->_[GAMMA,'_=>_[RHS,LHS]]) else ('_->_[GAMMA,'_=>_[LHS,RHS]]) fi)), ARG2:Substitution), 'NuITP-EQ)), CLA, 'NuITP-EQRL, none, 0, unbounded, 0)
        /\ T' := unwrapEQ(T)
        [ nonexec ] .

        
    --- Grounding (GND)
    crl [gnd] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        gnd(M, GID, GCS, NTS, { nil, 'GND, false, true, false, VC, SKO, HPS, CLA })
        if NTS := filterGround(GCS, getVars(CLA) ;; getSkolem(CLA, SKO)) .

    op gnd : Module QidList GenSetCollectionSet TermSet GoalSet -> GoalSet .
    eq gnd(M, GID, GCS, mt, GS) = indexGoals(GS, GID, 1) .
    eq gnd(M, GID, GCS, (C ;; TS), GS) = gnd(M, GID, GCS, TS, gnd(M, getDefaultGenSet(GCS, getType(C)), C, GS)) .
    eq gnd(M, GID, GCS, (V ;; TS), GS) = gnd(M, GID, GCS, TS, gnd(M, getDefaultGenSet(GCS, getType(V)), V, GS)) .

    op gnd : Module TermSet Term GoalSet -> GoalSet .
    eq gnd(M, mt, T, GS) = mt .
    eq gnd(M, T ;; TS, C, GS) = gnd(M, C, unfreeze(C) <- T, GS) gnd(M, TS, C, GS) .
    eq gnd(M, T ;; TS, V, GS) = gnd(M, V, V <- T, GS) gnd(M, TS, V, GS) .

    op gnd : Module Term Substitution GoalSet -> GoalSet .
    eq gnd(M, T, SB, mt) = mt .
    eq gnd(M, V, (V <- T), { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) =
        {
            GID,
            RID,
            INTER,
            FRO,
            SFRO,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), applySub(CLA, V <- T)))
        } gnd(M, V, (V <- T), GS) .
    eq gnd(M, C, (V <- T), { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) =
        {
            GID,
            RID,
            INTER,
            FRO,
            SFRO,
            VC,
            SKO,
            hsimp(
                M,
                SKO,
                HPS ;; ('_->_['true.NuITP-Bool,'_=_[C,T]])
            ),
            getTerm(metaReduce(redModule(M, SKO), applySub(unfreeze(CLA, C), V <- T)))
        } gnd(M, C, (V <- T), GS) .


    --- Unity Free (UFREE)
    crl [ufree] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        ufree(M, GID, makeFreeGenerators(M), NTS, { nil, 'UFREE, false, true, false, VC, SKO, HPS, CLA })
        if NTS := getNonFreeUVars(M, CLA) .

    op ufree : Module QidList GenSetCollectionSet TermSet GoalSet -> GoalSet .
    eq ufree(M, GID, GCS, mt, GS) = indexGoals(GS, GID, 1) .
    eq ufree(M, GID, GCS, (V ;; TS), GS) = ufree(M, GID, GCS, TS, ufree(M, getDefaultGenSet(GCS, getType(V)), V, GS)) .

    op ufree : Module TermSet Term GoalSet -> GoalSet .
    eq ufree(M, mt, T, GS) = mt .
    eq ufree(M, T ;; TS, V, GS) = ufree(M, V, V <- T, GS) ufree(M, TS, V, GS) .
    
    op ufree : Module Term Substitution GoalSet -> GoalSet .
    eq ufree(M, T, SB, mt) = mt .
    eq ufree(M, V, (V <- T), { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) =
        {
            GID,
            RID,
            INTER,
            FRO,
            SFRO,
            VC + size(getVars(T)),
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), applySub(CLA, V <- normalizeVarsGenset(T, VC))))
        } ufree(M, V, (V <- T), GS) .

    --- Reset (RST)
    crl [rst] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] } { GID tokenize(". 1"), 'RST, false, true, true, VC, mt, removeSkolem(HPS, SKO), unfreeze('_->_[GAMMA,LAMBDA]) }
    if getSkolem('_->_[GAMMA,LAMBDA], SKO) =/= mt .
endm

--- Standard Inductive Rules
mod NuITP-INDUCTION-RULES is
    pr NuITP-SIMPLIFICATION-RULES .

    vars M MR : Module .
    var C : Constant .
    var G : Goal .
    vars GS GS' : GoalSet .
    vars SKO SKO' HPS HPS' GEN TS1 TS2 : TermSet .
    var V : Variable .
    var GID : QidList .
    vars F F' RID RID' : Qid .
    vars TY TY' : Type .
    var TYL : TypeList .
    var ATS : AttrSet .
    var OPDS : OpDeclSet .
    vars N VC : Nat .
    vars T T' TU TV TW CLA GAMMA GAMMA' LAMBDA DELTA LHS RHS DELTAK DIS T1 T2 : Term .
    vars NTL NTL' : NeTermList .
    vars TL TL' : TermList .
    vars TS TS' CLAS DELTAS SSCS INTLOCAL : TermSet .
    vars STR : String .
    vars SB SB1 SB2 SB3 NSB SBTOP SBRES : Substitution .
    vars CO CO' : Context .
    var NTS : NeTermSet .
    vars FRO SFRO INTER : Bool .
    var GCS : GenSetCollectionSet .
    var GSL : GenSetList .
    vars SBS SBS1 SBS2 SBS3 : SubstitutionSet .

    --- Generator Set Induction (GSI) with 1..n variables and explicit generator sets
    crl [gsi] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        gsi(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(ARG1:TermList, ARG2:GenSetList, VC, none), VC), 1)
        if size(ARG1:TermList) > 0 
        /\ ARG1:TermList in getVars(CLA) 
        [ nonexec ] .

    --- Semi-automated version with 1..n variables and default generator sets
    crl [gsi] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        gsi(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(ARG1:TermList, GCS, VC, none), VC), 1)
        if size(ARG1:TermList) > 0 
        /\ ARG1:TermList in getVars(CLA) 
        /\ hasGeneratorSet?(ARG1:TermList, GCS) [ nonexec ] .

    --- Automated version with all variables and default generator sets
    crl [gsi+] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        gsi(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(getVars(CLA), GCS, VC, none), VC), 1)
        if size(getVars(CLA)) > 0
        /\ hasGeneratorSet?(getVars(CLA), GCS) .

    op normalizeVarsSubSet : SubstitutionSet Nat -> SubstitutionSet .
    op normalizeVarsSubSet : Substitution Nat -> Substitution .
    eq normalizeVarsSubSet(mt, N) = mt .
    eq normalizeVarsSubSet(none, N) = none .
    eq normalizeVarsSubSet(V <- T ; SB, N) = (V <- applySub(T, normalizeVars(getVars(T), N))) ; normalizeVarsSubSet(SB, N + size(getVars(T))) .
    eq normalizeVarsSubSet(SB | SBS, N) = normalizeVarsSubSet(SB, N) | normalizeVarsSubSet(SBS, N) .

    op combine : TermSet GenSetCollectionSet Nat Substitution -> SubstitutionSet .
    eq combine(mt, GCS, VC, SB) = simplify(combine'(SB), none) .
    eq combine(V ;; TS, GCS, VC, SB) = combine(TS, GCS, VC, SB ; toSub(V, normalizeVarsGenset(getDefaultGenSet(GCS, getType(V)), VC))) .

    op combine : TermList GenSetCollectionSet Nat Substitution -> SubstitutionSet .
    eq combine(empty, GCS, VC, SB) = simplify(combine'(SB), none) .
    eq combine((V,TL), GCS, VC, SB) = combine(TL, GCS, VC, SB ; toSub(V, normalizeVarsGenset(getDefaultGenSet(GCS, getType(V)), VC))) .

    op combine : TermList GenSetList Nat Substitution -> SubstitutionSet .
    eq combine(empty, GSL, VC, SB) = simplify(combine'(SB), none) .
    eq combine((V,TL), [ STR : NTS ] GSL, VC, SB) = combine(TL, GSL, VC, SB ; toSub(V, normalizeVarsGenset(NTS, VC))) .
    eq combine((V,TL), [ TY :: NTS ] GSL, VC, SB) = combine(TL, GSL, VC, SB ; toSub(V, normalizeVarsGenset(NTS, VC))) .

    op combine' : Substitution -> SubstitutionSet .
    eq combine'(V <- T1 ; V <- T2 ; SB) = combine'(V <- T1 ; SB) | combine'(V <- T2 ; SB) .
    eq combine'(SB) = SB [ owise ] .

    op simplify : SubstitutionSet Substitution -> SubstitutionSet .
    eq simplify(SB | SBS, SB) = simplify(SBS, SB) .
    eq simplify(none | SBS, SB) = simplify(SBS, SB) .
    eq simplify(SBS, SB) = SBS [ owise ] .

    op toSub : TermSet GenSetCollectionSet -> Substitution .
    eq toSub(mt, GCS) = none .
    eq toSub(V, GCS) = toSub(V, getDefaultGenSet(GCS, getType(V))) .
    eq toSub((V ;; NTS), GCS) = toSub(V, getDefaultGenSet(GCS, getType(V))) ; toSub(NTS, GCS) .

    op toSub : Variable TermSet -> Substitution .
    eq toSub(V, (mt).TermSet) = none .
    eq toSub(V, T) = V <- T .
    eq toSub(V, T ;; NTS) = V <- T ; toSub(V, NTS) .

    op gsi : Module Goal SubstitutionSet Nat -> GoalSet .
    eq gsi(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, mt, N) = mt .
    ceq gsi(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, SB | SBS, N) = 
        if isTrivial(TS')
        then
            {
                GID tokenize(". " + string(N,10)),
                'GSI,
                false,
                true,
                false,
                VC + size(getRanVars(SB)),
                SKO,
                HPS,
                getTerm(metaReduce(redModule(M, SKO), applySub(CLA, SB)))
            }
        else
            {
                GID tokenize(". " + string(N,10)),
                'GSI,
                false,
                true,
                false,
                VC + size(getRanVars(SB)),
                (SKO ;; freeze(getRanVars(SB))),
                hsimp(M, (SKO ;; freeze(getRanVars(SB))), HPS ;; TS'),
                getTerm(metaReduce(redModule(M, (SKO ;; freeze(getRanVars(SB)))), applySub(CLA, freeze(SB))))
            }
        fi
        gsi(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, SBS, N + 1)
        if TS' := gsiHPS(M, (SKO ;; freeze(getRanVars(SB))), split(CLA), getSubTerms+(addOps(M, (SKO ;; freeze(getRanVars(SB)))), freeze(SB), freeze(SB), none), mt) .

    op getSubTerms : Module Substitution Nat -> TermSet .
    eq getSubTerms(M, V <- T, N) = T [ owise ] .
    ceq getSubTerms(M, V <- T, N) = if (CO == []) then T else applySub(V, SB) fi ;; getSubTerms(M, V <- T, N + 1)
        if { SB , CO } := metaXmatch(M, V, T, nil, 0, unbounded, N) .
    
    op getSubTerms+ : Module Substitution Substitution Substitution -> SubstitutionSet .
    eq getSubTerms+(M, SBTOP, none, none) = mt .
    eq getSubTerms+(M, SBTOP, none, SB) = simplify(unfoldSub(SB), SBTOP) [ owise ] .
    eq getSubTerms+(M, SBTOP, V <- T ; SB, SBRES) = getSubTerms+(M, SBTOP, SB, SBRES ; getSubTerms+'(V, getSubTerms(M, V <- T, 0))) .

    op getSubTerms+' : Variable TermSet -> Substitution .
    eq getSubTerms+'(V, mt) = none .
    eq getSubTerms+'(V, T) = V <- T .
    eq getSubTerms+'(V, T ;; NTS) = V <- T ; getSubTerms+'(V, NTS) .

    op unfoldSub : Substitution -> SubstitutionSet .
    eq unfoldSub(V <- T ; V <- T' ; SB) = unfoldSub(V <- T ; SB) | unfoldSub(V <- T' ; SB) .
    eq unfoldSub(SB) = SB [ owise ] .

    op gsiHPS : Module TermSet TermSet SubstitutionSet TermSet -> TermSet .
    eq gsiHPS(M, SKO, CLAS, mt, TS) = reduceSet(e=xu(M, SKO), TS) .
    eq gsiHPS(M, SKO, CLAS, SB | SBS, TS) = gsiHPS(M, SKO, CLAS, SBS, (TS ;; applySub(CLAS, SB))) .

    --- Narrowing Induction (NI)
    crl [ni] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        ni(M, euR(M, ARG1:Term), { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, ARG1:Term, unfreeze(CO, getVars(CLA)), 0)
        if { none , CO } := metaXmatch(addOps(M, SKO ;; freeze(getVars(ARG1:Term ;; CLA))), freeze(ARG1:Term), freeze(CLA), nil, 0, unbounded, 0)
        /\ getSkolem(ARG1:Term, SKO) == mt
        /\ isNarrowex(euR(M, ARG1:Term), ARG1:Term)
        [ nonexec ] .

    crl [ni] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA } { GID tokenize(". 1"), 'RST, INTER, false, false, VC, mt, removeSkolem(HPS, SKO), unfreeze(CLA) }
        ni(M, euR(M, unfreeze(ARG1:Term)), { GID tokenize(". 1"), 'RST, INTER, true, false, VC, mt, removeSkolem(HPS, SKO), unfreeze(CLA) }, unfreeze(ARG1:Term), unfreeze(CO), 0)
        if { none , CO } := metaXmatch(addOps(M, SKO ;; freeze(getVars(ARG1:Term ;; CLA))), freeze(ARG1:Term), freeze(CLA), nil, 0, unbounded, 0)
        /\ getSkolem(ARG1:Term, SKO) =/= mt
        /\ isNarrowex(euR(M, unfreeze(ARG1:Term)), unfreeze(ARG1:Term))
        [ nonexec ] .

    op ni : Module Module Goal Term Context Nat -> GoalSet .
    ceq ni(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, ('_->_[CO,DELTA]), N) =
        if isTrivial(TS)
        then
            {
                GID tokenize(". " + string(N + 1,10)),
                'NI,
                false,
                true,
                false,
                VC + size(getRanVars(SB1 ; SB2)),
                SKO,
                HPS,
                getTerm(metaReduce(
                    redModule(M, SKO),
                    addGamma(replaceHole(applySub('_->_[CO,DELTA], SB3), applySub(T, NSB)), applySub(getCondition(getRls(MR), F), SB3))
                ))
            }
        else
            {
                GID tokenize(". " + string(N + 1,10)),
                'NI,
                false,
                true,
                false,
                VC + size(getRanVars(SB1 ; SB2)),
                (SKO ;; freeze(getRanVars(SB3))),
                hsimp(
                    M,
                    (SKO ;; freeze(getRanVars(SB3))),
                    HPS ;; freeze(TS, getRanVars(SB3))
                ),
                getTerm(metaReduce(
                    redModule(M, (SKO ;; freeze(getRanVars(SB3)))),
                    addGamma(replaceHole(applySub('_->_[CO,DELTA], freeze(SB3)), freeze(applySub(T, NSB))), applySub(applySub(getCondition(getRls(MR), F), NSB), freeze(SB3)))
                ))
            }
        fi
        ni(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, '_->_[CO,DELTA], N + 1)
        if { T, TY, [], F, SB1, SB2, F' } := metaNarrowingApply(addOps(MR, SKO), TV, empty, '#, none, N)
        /\ NSB := normalizeVars(getRanVars(SB1 ; SB2), VC)
        /\ SB3 := applySub(SB1 ; SB2, NSB)
        /\ TS := reduceSet(addOps(eqPreds(removeU(M)), (SKO ;; freeze(getRanVars(SB3)))), split(niHPS(M, (SKO ;; freeze(getRanVars(SB3))), CLA, TV, applySub(ssc(addOps(MR, (SKO ;; freeze(getRanVars(SB3)))), getRule(MR, F)), SB3)))) .

    ceq ni(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, '_->_[GAMMA,CO], N) =
        if isTrivial(TS)
        then
            {
                GID tokenize(". " + string(N + 1,10)),
                'NI,
                false,
                true,
                false,
                VC + size(getRanVars(SB1 ; SB2)),
                SKO,
                HPS,
                getTerm(metaReduce(
                    redModule(M, SKO),
                    addGamma(replaceHole(applySub('_->_[GAMMA,CO], SB3), applySub(T, NSB)), applySub(getCondition(getRls(MR), F), SB3))
                ))
            }
        else
            {
                GID tokenize(". " + string(N + 1,10)),
                'NI,
                false,
                true,
                false,
                VC + size(getRanVars(SB1 ; SB2)),
                (SKO ;; freeze(getRanVars(SB3))),
                hsimp(
                    M,
                    (SKO ;; freeze(getRanVars(SB3))),
                    HPS ;; freeze(TS, getRanVars(SB3))
                ),
                getTerm(metaReduce(
                    redModule(M, (SKO ;; freeze(getRanVars(SB3)))),
                    addGamma(replaceHole(applySub('_->_[GAMMA,CO], freeze(SB3)), freeze(applySub(T, NSB))), applySub(applySub(getCondition(getRls(MR), F), NSB), freeze(SB3)))
                ))
            }
        fi
        ni(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, '_->_[GAMMA,CO], N + 1)
        if { T, TY, [], F, SB1, SB2, F' } := metaNarrowingApply(addOps(MR, SKO), TV, empty, '#, none, N)
        /\ NSB := normalizeVars(getRanVars(SB1 ; SB2), VC)
        /\ SB3 := applySub(SB1 ; SB2, NSB)
        /\ DELTAK := replaceHole(getDeltaK(CO), TV)
        /\ TS := reduceSet(
            addOps(eqPreds(removeU(M)), (SKO ;; freeze(getRanVars(SB3)))),
            niHPS(M, (SKO ;; freeze(getRanVars(SB3))), '_->_[GAMMA,DELTAK], TV, applySub(ssc(addOps(MR, (SKO ;; freeze(getRanVars(SB3)))), getRule(MR, F)), SB3))
        ) .
    eq ni(M, MR, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, TV, CO, N) = mt [ owise ] .

    op niHPS : Module TermSet Term Term TermSet -> TermSet .
    eq niHPS(M, SKO, CLA, TV, mt) = mt .
    eq niHPS(M, SKO, CLA, TV, T) =
        if metaMatch(M, TV, T, nil, 0) :: Substitution
        then split(applySub(CLA, freeze(metaMatch(M, TV, T, nil, 0))))
        else mt
        fi .
    eq niHPS(M, SKO, CLA, TV, T ;; NTS) = niHPS(M, SKO, CLA, TV, T) ;; niHPS(M, SKO, CLA, TV, NTS) .

    op getDeltaK : Context -> Context .
    eq getDeltaK('_/\_[TL,CO,TL']) = CO .
    eq getDeltaK(CO) = CO [ owise ] .


    --- Lemma Enrichment (LE)
    rl [le] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        {
            GID tokenize(". 1"),
            'LE,
            false,
            true,
            false,
            VC + size(getVars(ARG1:Term)),
            SKO,
            removeSkolem(HPS, SKO),
            getTerm(metaReduce(
                    redModule(M, SKO),
                    applySub(ARG1:Term, normalizeVars(getVars(ARG1:Term), VC))
                ))
        }
        {
            GID
            tokenize(". 2"),
            'LE,
            false,
            true,
            false,
            VC + size(getVars(ARG1:Term)),
            SKO,
            hsimp(M, SKO, HPS ;; split(toCNF(addOps(M, SKO), applySub(ARG1:Term, normalizeVars(getVars(ARG1:Term), VC))))),
            CLA
        }
        [ nonexec ] .


    --- Split (SP)
    crl [sp] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        {
            GID tokenize(". 1"),
            'SP,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(metaReduce(redModule(M, SKO), '_->_['true.NuITP-Bool,applySub(ARG1:Term, ARG2:Substitution)]))
        }
        sp(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, applySub(ARG1:Term, ARG2:Substitution), ARG2:Substitution, 2)
        if getVars(applySub(ARG1:Term, ARG2:Substitution)) in getVars(CLA)
        [ nonexec ] .

    op sp : Module Goal TermList Substitution Nat -> GoalSet .
    eq sp(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, '_\/_[T,NTL], SB, N) = { GID tokenize(". " + string(N,10)), 'SP, false, true, false, VC, SKO, HPS, getTerm(metaReduce(redModule(M, SKO), addGamma(CLA, applySub(T,SB)))) } sp(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, NTL, SB, N + 1) .
    eq sp(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, T, SB, N) = { GID tokenize(". " + string(N,10)), 'SP, false, true, false, VC, SKO, HPS, getTerm(metaReduce(redModule(M, SKO), addGamma(CLA, applySub(T,SB)))) } [ owise ] .
    eq sp(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, (T, NTL), SB, N) = { GID tokenize(". " + string(N,10)), 'SP, false, true, false, VC, SKO, HPS, getTerm(metaReduce(redModule(M, SKO), addGamma(CLA, applySub(T,SB)))) } sp(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, NTL, SB, N + 1) [ owise ] .


    --- Case (CAS) with 1..n variables/skolem and explicit generator sets
    crl [cas] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        cas(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(unfreeze(ARG1:TermList), ARG2:GenSetList, VC, none), VC), 1)
        if size(ARG1:TermList) > 0 
        /\ unfreeze(ARG1:TermList) in getVars(unfreeze(CLA))
        [ nonexec ] .

    --- Semi-automated version with 1..n variables/skolem and default generator sets
    crl [cas] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        cas(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(unfreeze(ARG1:TermList), GCS, VC, none), VC), 1)
        if size(ARG1:TermList) > 0 
        /\ unfreeze(ARG1:TermList) in getVars(unfreeze(CLA))
        /\ hasGeneratorSet?(unfreeze(ARG1:TermList), GCS) [ nonexec ] .

    --- Automated version with all variables/skolem and default generator sets
    crl [cas1] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        cas(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(getVars(unfreeze(CLA)), GCS, VC, none), VC), 1)
        if size(getVars(unfreeze(CLA))) == 1
        /\ hasGeneratorSet?(getVars(unfreeze(CLA)), GCS) .

    crl [cas+] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, CLA }
        cas(M, { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }, normalizeVarsSubSet(combine(getVars(unfreeze(CLA)), GCS, VC, none), VC), 1)
        if size(getVars(unfreeze(CLA))) > 0
        /\ hasGeneratorSet?(getVars(unfreeze(CLA)), GCS) .

    op cas : Module Goal SubstitutionSet Nat -> GoalSet .
    eq cas(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, mt, N) = mt .
    ceq cas(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, SB | SBS, N) = 
        {
            GID tokenize(". " + string(N,10)),
            'CAS,
            false,
            true,
            false,
            VC + size(getRanVars(SB)),
            (SKO ;; SKO'),
            hsimp(M, (SKO ;; SKO'), HPS ;; HPS'),
            getTerm(metaReduce(redModule(M, (SKO ;; SKO')), freeze(applySub(unfreeze(CLA,SKO), SB), SKO ;; SKO')))
        }
        cas(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, SBS, N + 1)
        if { SKO' ::: HPS' } := casHPS(M, unfreeze(SKO), unfreeze(SB), { mt ::: mt }) . 
    
    op casHPS : Module TermSet Substitution TermSetPair -> TermSetPair .
    eq casHPS(M, V ;; SKO, V <- T ; SB, { TS1 ::: TS2 }) = casHPS(M, V ;; SKO, SB, { TS1 ;; freeze(getVars(T)) ::: TS2 ;; ('_->_['true.NuITP-Bool,'_=_[freeze(V), freeze(T)]]) }) .
    eq casHPS(M, SKO, SB, { TS1 ::: TS2 }) = { TS1 ::: TS2 } [ owise ] .


    --- Variable Abstraction (VA)
    crl [va] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_['_=_[TU,TV],LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_['_=_[TU,TV],LAMBDA] }
        va(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_['_=_[TU,TV],LAMBDA] }, TU, TV)
        if sameKind(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), getType(metaNormalize(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), freeze(ARG1:Term))), getType(metaNormalize(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), freeze(TV))))
        /\ metaMatch(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), freeze(ARG1:Term), freeze(TV), nil, 0) :: Substitution
        /\ isSigma1?(addOps(M,SKO), TU)
        /\ not(isSigma1?(addOps(M,SKO), TV))
        [ nonexec ] .

    crl [va] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[TU,TV],TL'],LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[TU,TV],TL'],LAMBDA] }
        va(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[TU,TV],TL'],LAMBDA] }, TU, TV)
        if sameKind(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), getType(metaNormalize(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), freeze(ARG1:Term))), getType(metaNormalize(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), freeze(TV))))
        /\ metaMatch(addOps(M, SKO ;; freeze(getVars(ARG1:Term) ;; getVars(TV))), freeze(ARG1:Term), freeze(TV), nil, 0) :: Substitution
        /\ isSigma1?(addOps(M,SKO), TU)
        /\ not(isSigma1?(addOps(M,SKO), TV))
        [ nonexec ] .

    op va : Module Goal Term Term -> Goal .
    eq va(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_['_=_[TU,TV],LAMBDA] }, TU, TV) =
        {
            GID tokenize(". 1"),
            'VA,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(
                metaReduce(
                    redModule(M, SKO),
                    '_->_[
                        wrapAnd(
                            ('_=_[TU,replaceMaxNotSigma1(TV, vaSub(addOps(M, SKO), getMaxNotSigma1(addOps(M,SKO), TV), VC))],
                            vaEqs(vaSub(addOps(M, SKO), getMaxNotSigma1(addOps(M,SKO), TV), VC), empty))
                        ),
                        LAMBDA
                    ]
                )
            )
        } .
    eq va(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_['_/\_[TL,'_=_[TU,TV],TL'],LAMBDA] }, TU, TV) =
        {
            GID tokenize(". 1"),
            'VA,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(
                metaReduce(
                    redModule(M, SKO),
                    '_->_[
                        wrapAnd((TL,
                            '_=_[TU,replaceMaxNotSigma1(TV, vaSub(addOps(M, SKO), getMaxNotSigma1(addOps(M,SKO), TV), VC))],
                            vaEqs(vaSub(addOps(M, SKO), getMaxNotSigma1(addOps(M,SKO), TV), VC), empty),
                            TL')),
                        LAMBDA
                    ]
                )
            )
        } .

    op vaSub : Module TermSet Nat -> Substitution .
    eq vaSub(M, mt, N) = none .
    eq vaSub(M, T ;; TS, N) = (qid("$" + string(N, 10) + ":" + substr(string(leastSort(M, T)), 0, length(string(leastSort(M, T))))) <- T) ; vaSub(M, TS, N + 1) .

    op vaEqs : Substitution TermList -> TermList .
    eq vaEqs(none, TL) = TL .
    eq vaEqs((V <- T ; SB), TL) = vaEqs(SB, (TL, '_=_[V, T])) .

    --- Cut (CUT)
    rl [cut] :
        M | GCS | INTLOCAL | GS { GID, RID, INTER, true, true, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        =>
        M | GCS | INTLOCAL | GS { GID, RID, INTER, false, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }
        cut(M, { GID, RID, INTER, true, false, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, ARG1:Term)
        [ nonexec ] .
    
    op cut : Module Goal Term -> GoalSet .
    eq cut(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, '_->_[GAMMA,LAMBDA] }, GAMMA' ) = 
        {
            GID tokenize(". 1"),
            'CUT,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
             getTerm(
                metaReduce(
                    redModule(M, SKO),
                    '_->_[GAMMA,GAMMA']
                )
            )
        }
        {
            GID tokenize(". 2"),
            'CUT,
            false,
            true,
            false,
            VC,
            SKO,
            HPS,
            getTerm(
                metaReduce(
                    redModule(M, SKO),
                    '_->_['_/\_[GAMMA,GAMMA'],LAMBDA]
                )
            )
        } .
endm

fmod NuITP-ERROR is
    pr NuITP-UTILS .

    sort Error .

    var N : Nat .
    vars MSG MID RID GID TYPE GENSET STRAT MODNAME EQS OPDS : String .

    op {_,_} : Nat String -> Error [ ctor ] .
    op getNat : Error -> Nat .
    eq getNat({ N, MSG }) = N .
    op getMsg : Error -> String .
    eq getMsg({ N, MSG }) = MSG .

    op error : Nat String String -> Error .
    op error : Nat String -> Error .
    op error : Nat -> Error .

    eq error(N) = { 0, "Unexpected error." } [ owise ] .

    eq error(1) = { 1, "Module is not available." } .
    eq error(1, MID) = { 1, "Module " + MID + " is not available." } .
    eq error(2) = { 2, "No module loaded." } .
    eq error(3, OPDS) = { 3, "Explicit RPO data missing in the following operator declarations:\n\n" + BW + substr(OPDS, 0, length(OPDS) + - 1) } .
    eq error(4, MODNAME, EQS) = { 4, "RPO order defined in module " + MODNAME + " is inconsistent with the following equations:\n\n" + BW + substr(EQS, 0, length(EQS) + - 1) } .
    eq error(5) = { 5, "No local session started."} .
    
    eq error(20) = { 20, "Error parsing command." } .
    eq error(21) = { 21, "Error parsing goal." } .

    eq error(40) = { 40, "There are no goals." } .
    eq error(41) = { 41, "Goal does not exist." } .
    eq error(41, GID) = { 41, "Goal " + GID + " does not exist." } .

    eq error(60) = { 60, "Goal is proved. Unable to undo." } .
    eq error(60, GID) = { 60, "Goal " + GID + " is proved. Unable to undo." } .
    eq error(61) = { 61, "Goal is disproved. Unable to undo." } .
    eq error(61, GID) = { 61, "Goal " + GID + " is disproved. Unable to undo." } .
    eq error(62) = { 62, "Goal is in the frontier. Unable to undo." } .
    eq error(62, GID) = { 62, "Goal " + GID + " is in the frontier. Unable to undo." } .

    eq error(70, GID) = { 70, "Assertion failed: Goal " + GID + " does not exist." } .
    eq error(71) = { 71, "Assertion failed: Initial goal is not proved." } .
    eq error(72, GID) = { 72, "Assertion failed: Goal " + GID + " is not proved." } .
    
    eq error(80) = { 80, "Initial goal has been proved. Frontier is closed." } .
    eq error(81) = { 81, "Initial goal has been disproved. Frontier is closed." } .
    eq error(82) = { 82, "Goal is not in the frontier." } .
    eq error(82, GID) = { 82, "Goal " + GID + " is not in the frontier." } .

    eq error(90) = { 90, "Unable to internalize: Initial goal is not proved." } .
    eq error(91) = { 91, "Unable to internalize: Initial goal does not match the axiom pattern." } .
    eq error(92) = { 92, "Unable to internalize: Original theory may become non-executable." } .
    eq error(93) = { 93, "Unable to internalize: Unexpected error." } .
    eq error(94) = { 94, "Unable to internalize: Goal is not proven." } .
    eq error(95) = { 95, "Unable to internalize: Goal has Skolem constants." } .

    eq error(100) = { 100, "Equality not valid." } .
    eq error(101) = { 101, "Substitution not valid." } .
    eq error(102) = { 102, "Lemma not valid." } .
    eq error(103) = { 103, "Disjunction not valid." } .
    eq error(104) = { 104, "Narrowex not valid." } .
    eq error(105) = { 105, "Term not valid." } .
    eq error(106) = { 106, "Generator set not valid." } .
    eq error(106, TYPE) = { 106, "Generator set for sort " + TYPE + " not valid." } .
    eq error(106, TYPE, MODNAME) = { 106, "Could not find sort " + TYPE + " in module " + MODNAME + "." } .
    eq error(107, GENSET) = { 107, "Generator set " + GENSET + " already defined for a different sort." } .
    eq error(108) = { 108, "Variable not valid." } .
    eq error(109) = { 109, "Variable not found in the clause." } .
    eq error(110) = { 110, "Skolem variable not found in the clause." } .
    eq error(111) = { 111, "No generator sets defined." } .
    eq error(111, TYPE) = { 111, "No generator sets defined for sort " + TYPE + "." } .
    eq error(112, GENSET) = { 112, "Generator set " + GENSET + " not found." } .
    eq error(113) = { 113, "Conjunction not valid." } .
    eq error(114) = { 114, "Conjunction has fresh variables." } .
    eq error(115) = { 115, "Equation not found." } .

    eq error(130) = { 130, "Error parsing strategy." } .
    eq error(131) = { 131, "Strategy not valid (see strategy requirements in the manual)." } .
    eq error(132) = { 132, "No simplification strategies defined." } .
    eq error(133) = { 133, "Default simplification strategy NuITP can not be redefined." } .
    eq error(134, STRAT) = { 134, "Simplification strategy " + STRAT + " not found." } .
    
    eq error(200) = { 200, "Failure applying rule to goal." } .
    eq error(200, RID, GID) = { 200, "Failure applying rule " + RID + " to goal " + GID + "." } .
    eq error(201) = { 201, "Failure applying strategy to goal." } .
    eq error(201, RID, GID) = { 201, "Failure applying strategy " + RID + " to goal " + GID + "." } .
endfm

smod NuITP-SIMPLIFICATION-STRATEGIES is
    pr NuITP-SIMPLIFICATION-RULES .
    pr NuITP-INDUCTION-RULES .

    --- Simplification rules
    strat try-eps @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-eps := try(eps !) ; try(refresh !) .

    strat try-cvul @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-cvul := try(cvul !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-cvufr @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-cvufr := try(cvufr !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-subl @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-subl := try(subl !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-subr @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-subr := try(subr !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-ns @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-ns := try(ns !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-cs @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-cs := try(cs !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-icc @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-icc := try(icc !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-varsat @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-varsat := try(varsat !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-gnd @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-gnd := try(gnd !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-ufree @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-ufree := try(ufree !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-rst @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-rst := try(rst !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-gsi @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-gsi := try(gsi+ !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    strat try-cas @ State [ metadata "NuITP-SimpStrat" ] .
    sd try-cas := try(cas1 !) ; try(refresh !) ; try(eps !) ; try(refresh !) .

    --- Default Simplification Strategy
    strat default-simplify @ State .
    sd default-simplify := try-cs ; try-cvul ; try-cs ; try-icc ; try-cs .
    
    --- Default Update Internalization Strategy
    strat default-update-internal @ State .
    sd default-update-internal := try(cs !) ; try(refresh !) .
    
    --- Others
    strat nsplus @ State .
    sd nsplus := try-ns ; try-cvul .

    strat nsicc @ State .
    sd nsicc := try-ns ; try-cvul ; try-icc .
endsm

fmod NuITP-STRATEGY-UTILS is
    pr NuITP-UTILS .
    pr NuITP-GENSET .

    sorts SimpStrat SimpStratList .
    subsort SimpStrat < SimpStratList .

    op [_:_] : String Strategy -> SimpStrat [ ctor ] .
    
    op nil : -> SimpStratList [ ctor ] .
    op __ : SimpStratList SimpStratList -> SimpStratList [ assoc id: nil ] .
    
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .
    var STDS : StratDeclSet .
    var STDFS : StratDefSet .
    var STR : String .
    vars SD SD' : StratDefinition .
    vars SSL SSL1 SSL2 : SimpStratList .
    var M : Module .
    vars Q RID RULE STRAT : Qid .
    var QS : QidSet .
    var NQL : NeQidList .
    vars SB SB' : Substitution .
    var G : Goal .
    var GS : GoalSet .
    vars GID QL : QidList .
    var B FRO SFRO INTER : Bool .
    var TY : Type .
    vars SKO HPS INTLOCAL : TermSet .
    vars CLA TM TG TGC TLOC : Term .
    vars VC N : Nat .
    var GCS : GenSetCollectionSet .
    vars CS CS1 CS2 : CallStrategy .
    vars STA STA1 STA2 : Strategy .
    vars ATS1 ATS2 : AttrSet .

    op NuITPDefaultStrategy : -> StrategyList .
    eq NuITPDefaultStrategy = getNuITPDefaultStrategy(getSds(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false))) .

    op getNuITPDefaultStrategy : StratDefSet -> StrategyList .
    eq getNuITPDefaultStrategy((sd 'default-simplify[[empty]] := STA [none] . ) STDFS) = STA .
    eq getNuITPDefaultStrategy(STDFS) = empty [ owise ] .
    
    op getStrat : SimpStratList String -> StrategyList .
    eq getStrat(SSL1 [ STR : STA ] SSL2, STR) = STA .
    eq getStrat(SSL, STR) = empty [ owise ] .
    
    op getDefaultStrat : SimpStratList -> StrategyList .
    eq getDefaultStrat(nil) = empty .
    eq getDefaultStrat([ STR : STA ] SSL) = STA .

    op getDefaultStratId : SimpStratList -> String .
    eq getDefaultStratId(nil) = "" .
    eq getDefaultStratId([ STR : STA ] SSL) = STR .

    op addStrategy : SimpStratList String Strategy -> SimpStratList .
    eq addStrategy(SSL1 [ STR : STA1 ] SSL2, STR, STA2) = SSL1 [ STR : STA2 ] SSL2 .
    eq addStrategy(SSL, STR, STA) = SSL [ STR : STA ] [ owise ] .

    op setDefaultStrat : SimpStratList String -> SimpStratList .
    eq setDefaultStrat(SSL1 [ STR : STA ] SSL2, STR) = [ STR : STA ] SSL1 SSL2 .
    eq setDefaultStrat(SSL, STR) = SSL [ owise ] .

    op setStrategies : SModule SimpStratList Bool -> SModule .
    eq setStrategies(M, nil, B) = M .
    eq setStrategies((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS (STDFS (sd 'default-simplify[[empty]] := STA1 [ none ] .)) endsm), [ STR : STA2 ] SSL, true) = setStrategies(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS (STDFS (sd 'default-simplify[[empty]] := STA2 [ none ] .)) endsm, [ STR : STA2 ] SSL, false) .
    eq setStrategies((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), [ STR : STA2 ] SSL, false) = setStrategies((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS (STDS (strat qid(STR) : nil @ 'State [ none ] .)) (STDFS (sd qid(STR)[[empty]] := STA2 [ none ] .)) endsm), SSL, false) .

    op getSimpStrategies : StratDeclSet -> QidSet .
    eq getSimpStrategies((strat Q : nil @ 'State [ metadata("NuITP-SimpStrat") ] .) STDS) = Q ; getSimpStrategies(STDS) .
    eq getSimpStrategies(STDS) = none [ owise ] .
    
    op checkStrategy : Strategy -> Bool .
    ceq checkStrategy(Q[[empty]]) = true
        if Q ; QS := getSimpStrategies(getStrats(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false))) .
    ceq checkStrategy(Q[[empty]] ; STA) = checkStrategy(STA)
        if STA =/= idle
        /\ Q ; QS := getSimpStrategies(getStrats(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false))) .
    eq checkStrategy(STA) = false [ owise ] .

    op unfoldStrat : QidList SimpStratList -> QidList .
    eq unfoldStrat(nil, SSL) = nil .
    eq unfoldStrat(RULE, SSL) =
        if (substr(printTokens(RULE),sd(length(printTokens(RULE)),1), 1) == "!")
        then tokenize(substr(printTokens(RULE), 0, sd(length(printTokens(RULE)),1))) 'try-eps
        else
            if (substr(printTokens(RULE),sd(length(printTokens(RULE)),1), 1) == "*")
            then tokenize(substr(printTokens(RULE), 0, sd(length(printTokens(RULE)),1))) qid(getDefaultStratId(SSL))
            else RULE
            fi
        fi .
    eq unfoldStrat(RULE '`{ STRAT '`}, SSL) = unfoldStrat(RULE, SSL) STRAT .

    op refreshFrontier : GoalSet -> GoalSet .
    eq refreshFrontier(GS { GID, RID, INTER, true, false, VC, SKO, HPS, CLA }) = refreshFrontier(GS { GID, RID, INTER, true, true, VC, SKO, HPS, CLA }) .
    eq refreshFrontier(GS) = GS [ owise ] .

    op applyRule : Module QidList Substitution GenSetCollectionSet SimpStratList TermSet Goal -> GoalSet .
    ceq applyRule(M, RULE, SB, GCS, SSL, INTLOCAL, { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }) = refreshFrontier(downTerm(TG, (mt).GoalSet))
        if { '_|_|_|_[TM, TGC, TLOC, TG], TY, SB' } := metaApply(upModule('NuITP-INDUCTION-RULES, false), upTerm(M | GCS | INTLOCAL | { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }), RULE, SB, 0) .
    ceq applyRule(M, RULE STRAT, SB, GCS, SSL, INTLOCAL, { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }) = applyStrat(M, STRAT, GCS, SSL, INTLOCAL, refreshFrontier(downTerm(TG, (mt).GoalSet)))
        if { '_|_|_|_[TM, TGC, TLOC, TG], TY, SB' } := metaApply(upModule('NuITP-INDUCTION-RULES, false), upTerm(M | GCS | INTLOCAL | { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }), RULE, SB, 0) .
    eq applyRule(M, QL, SB, GCS, SSL, INTLOCAL, { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }) = mt [ owise ] .

    op applyStrat : Module QidList GenSetCollectionSet SimpStratList TermSet GoalSet -> GoalSet .
    ceq applyStrat(M, nil, GCS, SSL, INTLOCAL, { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS) = refreshFrontier(downTerm(TG, (mt).GoalSet) applyStrat(M, nil, GCS, SSL, INTLOCAL, GS))
        if { '_|_|_|_[TM, TGC, TLOC, TG], TY } := metaSrewrite(setStrategies(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false), SSL, true), upTerm(M | GCS | INTLOCAL | { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }), getDefaultStrat(SSL), depthFirst, 0) .
    ceq applyStrat(M, STRAT, GCS, SSL, INTLOCAL, { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA } GS) = refreshFrontier(downTerm(TG, (mt).GoalSet) applyStrat(M, STRAT, GCS, SSL, INTLOCAL, GS))
        if { '_|_|_|_[TM, TGC, TLOC, TG], TY } := metaSrewrite(setStrategies(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false), SSL, true), upTerm(M | GCS | INTLOCAL | { GID, RID, INTER, true, SFRO, VC, SKO, HPS, CLA }), STRAT[[empty]], depthFirst, 0) .
    eq applyStrat(M, QL, GCS, SSL, INTLOCAL, GS) = GS [ owise ] .
endfm

fmod NuITP-STRING is
    pr NuITP-STRATEGY-UTILS .
    pr NuITP-HSIMP .

    vars GID GID' PID : QidList .
    vars B FRO FRO' SFRO SFRO' VERBOSE INTER INTER' : Bool .
    vars G GF GP GP' GU GU' GB GB' : Goal .
    vars GS FRN DIS PRO UNP NEW SUB NEWFRO NEWINT : GoalSet .
    vars SKO SKO' HPS HPS' : TermSet .
    var NTS : NeTermSet .
    var TL : TermList .
    vars CLA CLA' GAMMA LAMBDA T T' LHS RHS : Term .
    var M : Module .
    var PDL : ParameterDeclList .
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .
    var STD : StratDecl .
    var STDS : StratDeclSet .
    var STDF : StratDefinition .
    var STDFS : StratDefSet .
    vars F F' F'' Q Q' RID RID' : Qid .
    vars FL QL QL' QL'' PMODS PMODS' : QidList .
    var TYL : TypeList .
    var TY : Type .
    vars ME ME' : ModuleExpression .
    var EXP : Expression .
    var PL : ParameterList .
    var NPL : NeParameterList .
    var PD : ParameterDecl .
    vars S S' : Sort .
    var SSD : SubsortDecl .
    var RS : RenamingSet .
    var A : Attr .
    var ATS : AttrSet .
    var R : Renaming .
    var NeNL : NeNatList .
    var NeHL : NeHookList .
    var HK : Hook .
    var HKL : HookList .
    var NL : NatList .
    vars N VC VC' DAY HOUR MIN SEC : Nat .
    vars STR DEF : String .
    vars COND COND' : Condition .
    var OPD : OpDecl .
    var MA : MembAx .
    var EQ : Equation .
    var RL : Rule .
    var CST : CallStrategy .
    vars STA STA' STA'' : Strategy .
    var RAP : RuleApplication .
    vars UPS UPS' : UsingPairSet .
    vars STL STL' : StrategyList .
    var SB : Substitution .
    var V : Variable .
    vars GSL GSL1 GSL2 : GenSetList .
    var GCS : GenSetCollectionSet .
    var SSL : SimpStratList .
    
    op getIDs : GoalSet -> String .
    eq getIDs(mt) = "" .
    eq getIDs({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = join(GID) .
    eq getIDs({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } { GID', RID', INTER', FRO', SFRO', VC', SKO', HPS', CLA' }) = join(GID) + " and " + join(GID') [ owise ] .
    eq getIDs({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) = join(GID) + ", " + getIDs(GS) [ owise ] .

    op toString : Module TermSet String -> String .
    eq toString(M, mt, STR) = "" .
    eq toString(M, T, STR) = STR + toString(M, T) .
    eq toString(M, (T ;; NTS), STR) = STR + toString(M, T) + "\n" + toString(M, NTS, STR) .

    op toString : Module Term -> String .
    eq toString(M, T) = metaPrintToString(M, none, T, mixfix, none) .

    op toStringApply : Module GoalSet GoalSet GoalSet GoalSet Bool -> String .
    eq toStringApply(M, FRN, NEW, mt, NEWINT, VERBOSE) = toStringApply'(M, VERBOSE, FRN, getProved(NEW), getDisproved(NEW), mt, NEWINT) .
    eq toStringApply(M, FRN, NEW, NEWFRO, NEWINT, VERBOSE) = toStringApply'(M, VERBOSE, FRN, getProved(NEW), getDisproved(NEW), NEWFRO, NEWINT) [ owise ] .

    --- frontier, proved, disproved, open
    op toStringApply' : Module Bool GoalSet GoalSet GoalSet GoalSet GoalSet -> String .
    eq toStringApply'(M, VERBOSE, mt,      mt,          mt,      mt,     NEWINT) = "" .
    eq toStringApply'(M, VERBOSE, FRN,     mt,          mt,      GU UNP, NEWINT) = toStringInternal(M, NEWINT) + toString(M, GU UNP, VERBOSE) .
    eq toStringApply'(M, VERBOSE, FRN,     PRO,         GF,      UNP,    NEWINT) = RED + "  Goal " + getIDs(GF) + " has been disproved.\n\n  Initial goal is not an inductive theorem of " + string(getName(M)) + ".\n\n" + BW .
    eq toStringApply'(M, VERBOSE, FRN,     PRO,         GF DIS,  UNP,    NEWINT) = RED + "  Goal " + getIDs(GF DIS) + " have been disproved.\n\n  Initial goal is not an inductive theorem of " + string(getName(M)) + ".\n\n" + BW .
    eq toStringApply'(M, VERBOSE, mt,      GP,          mt,      mt,     NEWINT) = GREEN + "  Goal " + getIDs(GP) + " has been proved.\n\n" + toStringInternal(M, NEWINT) + GREEN + "  qed\n\n" + BW .
    eq toStringApply'(M, VERBOSE, mt,      GP GP' PRO,  mt,      mt,     NEWINT) = GREEN + "  Goals " + getIDs(GP GP' PRO) + " have been proved.\n\n" + toStringInternal(M, NEWINT) + GREEN + "  qed\n\n" + BW .
    eq toStringApply'(M, VERBOSE, FRN,     GP,          mt,      GU UNP, NEWINT) = GREEN + "  Goal " + getIDs(GP) + " has been proved.\n\n" + toStringInternal(M, NEWINT) + BW + toString(M, GU UNP, VERBOSE) .
    eq toStringApply'(M, VERBOSE, FRN,     GP GP' PRO,  mt,      GU UNP, NEWINT) = GREEN + "  Goals " + getIDs(GP GP' PRO) + " have been proved.\n\n" + toStringInternal(M, NEWINT) + BW + toString(M, GU UNP, VERBOSE) .
    eq toStringApply'(M, VERBOSE, GF FRN,  GP,          mt,      mt,     NEWINT) = GREEN + "  Goal " + getIDs(GP) + " has been proved.\n\n" + toStringInternal(M, NEWINT) + RED + "  Unproven goals:\n\n" + BW + toString(M, GF FRN, VERBOSE) + RED + "  Total unproven goals: " + string(size(GF FRN), 10) + "\n\n" + BW .
    eq toStringApply'(M, VERBOSE, GF FRN,  GP GP' PRO,  mt,      mt,     NEWINT) = GREEN + "  Goals " + getIDs(GP GP' PRO) + " have been proved.\n\n" + toStringInternal(M, NEWINT) + RED + "  Unproven goals:\n\n" + BW + toString(M, GF FRN, VERBOSE) + RED + "  Total unproven goals: " + string(size(GF FRN), 10) + "\n\n" + BW .

    --- auto internalization
    op toStringInternal : Module GoalSet -> String .
    eq toStringInternal(M, mt) = "" .
    eq toStringInternal(M, G) = "  Goal " + getIDs(G) + " has been proved by local internalization subsumption.\n\n" + BW .
    eq toStringInternal(M, GS) = "  Goals " + getIDs(GS) + " have been proved by local internalization subsumption.\n\n" + BW [ owise ] .
    
    op toString : Module GoalSet -> String .
    eq toString(M, GS) = toString(M, GS, true) .

    op toString : Module GoalSet Bool -> String .
    eq toString(M, (mt).GoalSet, VERBOSE) = "" .
    eq toString(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA}, false) =
        WHITE + "  Goal: " + BW + join(GID) + "\n"
              + "    " + toStringCLA(addOps(M,SKO),CLA) + "\n\n" .
    eq toString(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA}, true) =
        WHITE + "  Goal Id: " + BW + join(GID) + "\n" +
        WHITE + "  Generated By: " + string(RID) + "\n" +
        WHITE + "  Skolem Ops: " + BW + if (SKO == mt) then "\n    None" else toStringSKO(addOps(M,SKO),SKO) fi + "\n" +
        WHITE + "  Executable Hypotheses: " + BW + if (he(M, SKO, HPS) == mt) then "\n    None" else toStringHPS(addOps(M,SKO),he(M, SKO, HPS)) fi + "\n" +
        WHITE + "  Non-Executable Hypotheses: " + BW + if (hne(M, SKO, HPS) == mt) then "\n    None" else toStringHPS(addOps(M,SKO),hne(M, SKO, HPS)) fi + "\n" +
        WHITE + "  Goal: " + BW + "\n    " + toStringCLA(addOps(M,SKO),CLA) + "\n\n" .
    eq toString(M, G GS, VERBOSE) = toString(M, G, VERBOSE) + toString(M, GS, VERBOSE) [ owise ] .

    op toStringTeX : Module GoalSet -> String .
    eq toStringTeX(M, (mt).GoalSet) = "\n" .
    eq toStringTeX(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA}) = "\n" +
        "\\movecounter\\label{goal:" + join(GID) + "}\n" + 
        "\\begin{Verbatim}[breaklines=true]\n" +
        "Goal Id: " + join(GID) + "\n" +
        "Skolem Ops: " + if (SKO == mt) then "\n  None" else toStringSKOTeX(addOps(M,SKO),SKO) fi + "\n" +
        "Executable Hypotheses: " + if (he(M, SKO, HPS) == mt) then "\n  None" else toStringHPSTeX(addOps(M,SKO),he(M, SKO, HPS)) fi + "\n" +
        "Non-Executable Hypotheses: " + if (hne(M, SKO, HPS) == mt) then "\n  None" else toStringHPSTeX(addOps(M,SKO),hne(M, SKO, HPS)) fi + "\n" +
        "Goal: \n  " + toStringCLATeX(addOps(M,SKO),CLA) + 
        "\n\\end{Verbatim}\n" + 
        "\\hfill\\hyperref[node:" + join(GID) + "]{\\tt\\color{red}$\\blacktriangleright$}\n" .
    eq toStringTeX(M, G GS) = toStringTeX(M, G) + toStringTeX(M, GS) [ owise ] .

    op toStringCLA : Module Term -> String .
    eq toStringCLA(M,'true.NuITP-Bool) = GREEN + "true" + BW .
    eq toStringCLA(M,'false.NuITP-Bool) = RED + "false" + BW .
    eq toStringCLA(M,'_=_[LHS,RHS]) = toString(M,'_=_[LHS,RHS]) .
    eq toStringCLA(M,'_=>_[LHS,RHS]) = toString(M,'_=>_[LHS,RHS]) .
    eq toStringCLA(M,'_->_['true.NuITP-Bool,LAMBDA]) = toString(M,LAMBDA) .
    eq toStringCLA(M,'_->_[GAMMA,'true.NuITP-Bool]) = toString(M,GAMMA) + " -> true" .
    eq toStringCLA(M,'_->_[GAMMA,'false.NuITP-Bool]) = toString(M,GAMMA) + " -> false" .
    eq toStringCLA(M,'_->_[GAMMA,LAMBDA]) = toString(M,GAMMA) + " -> " + toString(M,LAMBDA) [ owise ] .

    op toStringCLATeX : Module Term -> String .
    eq toStringCLATeX(M,'true.NuITP-Bool) = "true" .
    eq toStringCLATeX(M,'false.NuITP-Bool) = "false" .
    eq toStringCLATeX(M,'_=_[LHS,RHS]) = toString(M,'_=_[LHS,RHS]) .
    eq toStringCLATeX(M,'_=>_[LHS,RHS]) = toString(M,'_=>_[LHS,RHS]) .
    eq toStringCLATeX(M,'_->_['true.NuITP-Bool,LAMBDA]) = toString(M,LAMBDA) .
    eq toStringCLATeX(M,'_->_[GAMMA,LAMBDA]) = toString(M,GAMMA) + " -> " + toString(M,LAMBDA) [ owise ] .

    op toStringSKO : Module TermSet -> String .
    eq toStringSKO(M,mt) = "" .
    eq toStringSKO(M,T) = "\n    " + toString(M,T) + "." + string(getType(T)) .
    eq toStringSKO(M,T ;; NTS) = "\n    " + toString(M,T) + "." + string(getType(T)) + toStringSKO(M,NTS) .

    op toStringSKOTeX : Module TermSet -> String .
    eq toStringSKOTeX(M,mt) = "" .
    eq toStringSKOTeX(M,T) = "\n  " + toString(M,T) + "." + string(getType(T)) .
    eq toStringSKOTeX(M,T ;; NTS) = "\n  " + toString(M,T) + "." + string(getType(T)) + toStringSKOTeX(M,NTS) .

    op toStringHPS : Module TermSet -> String .
    eq toStringHPS(M,mt) = "" .
    eq toStringHPS(M,T) = "\n    " + toStringCLA(M,T) .
    eq toStringHPS(M,T ;; NTS) = "\n    " + toStringCLA(M,T) + toStringHPS(M,NTS) .

    op toStringHPSTeX : Module TermSet -> String .
    eq toStringHPSTeX(M,mt) = "" .
    eq toStringHPSTeX(M,T) = "\n  " + toStringCLATeX(M,T) .
    eq toStringHPSTeX(M,T ;; NTS) = "\n  " + toStringCLATeX(M,T) + toStringHPSTeX(M,NTS) .

    op PRELUDE-MODS : -> QidList .
    eq PRELUDE-MODS = 'BOOL 'TRUTH-VALUE 'BOOL-OPS 'TRUTH 'EXT-BOOL 'NAT 'INT 'RAT 'FLOAT 'STRING 'STRING-OPS 'CONVERSION 'RANDOM 'BOUND 'QID 'TRIV 'STRICT-WEAK-ORDER 'STRICT-TOTAL-ORDER 'TOTAL-PREORDER 'TOTAL-ORDER 'DEFAULT 'LIST 'WEAKLY-SORTABLE-LIST 'SORTABLE-LIST 'WEAKLY-SORTABLE-LIST' 'SORTABLE-LIST' 'SET 'LIST-AND-SET 'SORTABLE-LIST-AND-SET 'SORTABLE-LIST-AND-SET' 'LIST* 'SET* 'MAP 'ARRAY 'NAT-LIST 'QID-LIST 'QID-SET 'META-TERM 'META-CONDITION 'META-STRATEGY 'META-MODULE 'META-VIEW 'META-LEVEL 'LEXICAL 'COUNTER 'LOOP-MODE 'CONFIGURATION .

    op toString : Module -> String .
    eq toString(M) = toStringAllMods(getAllMods(M)) .

    op toString : Bool -> String .
    eq toString(true) = "true" .
    eq toString(false) = "false" .

    op toStringAllMods : QidList -> String .
    eq toStringAllMods(nil) = "" .
    eq toStringAllMods(Q) = toString'(upModule(Q, false)) .
    eq toStringAllMods(Q Q' QL) = toString'(upModule(Q, false)) + "\n\n" + toStringAllMods(Q' QL) [ owise ] .

    op cleanImports : QidList QidList -> QidList .
    eq cleanImports(QL Q QL' Q QL'', PMODS) = cleanImports(QL Q QL' QL'', PMODS) .
    ceq cleanImports(QL Q QL', PMODS Q PMODS') = cleanImports(QL QL', PMODS Q PMODS') if QL' =/= nil .
    eq cleanImports(QL, PMODS) = QL [ owise ] .

    op getAllMods : Module -> QidList .
    eq getAllMods(M) = cleanImports(getAllMods(getImports(M)) getName(M), PRELUDE-MODS) .

    op getAllMods : ImportList -> QidList .
    eq getAllMods((nil).ImportList) = nil .
    eq getAllMods(extending ME .) = getAllMods(ME) .
    eq getAllMods(including ME .) = getAllMods(ME) .
    eq getAllMods(protecting ME .) = getAllMods(ME) .
    eq getAllMods(extending ME . IL) = getAllMods(ME) getAllMods(IL) [ owise ] .
    eq getAllMods(including ME . IL) = getAllMods(ME) getAllMods(IL) [ owise ] .
    eq getAllMods(protecting ME . IL) = getAllMods(ME) getAllMods(IL) [ owise ] .

    op getAllMods : ModuleExpression -> QidList .
    eq getAllMods(Q) = getAllMods(upModule(Q, false)) Q .
    eq getAllMods(ME{NPL}) = getAllMods(ME) .
    eq getAllMods(ME + ME') = getAllMods(ME) getAllMods(ME') .
    eq getAllMods(ME *(RS)) = getAllMods(ME) .

    op toString' : Module -> String .
    eq toString'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) =
        "fmod " +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), H) +
        " is\n" +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), OPDS) +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), MAS) +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), EQS) +
        "endfm" .

    eq toString'(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) =
        "mod " +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), H) +
        " is\n" +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), OPDS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), MAS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), EQS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), RLS) +
        "endm" .

    eq toString'(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm) =
        "smod " +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), H) +
        " is\n" +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), OPDS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), MAS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), EQS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), RLS) +
        "endsm" .

    eq toString'(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) =
        "fth " +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), Q) +
        " is\n" +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), OPDS) +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), MAS) +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), EQS) +
        "endfth" .

    eq toString'(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) =
        "th " +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), Q) +
        " is\n" +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), OPDS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), MAS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), EQS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), RLS) +
        "endth" .

    eq toString'(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth) =
        "sth " +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), H) +
        " is\n" +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), OPDS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), MAS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), EQS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), RLS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), STDS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), STDFS) +
        "endsth" .
    eq toString'(M) = "Error printing module." [ owise ] .

    op toString : Module Header -> String .
    eq toString(M, Q) = string(Q) .
    eq toString(M, Q{PDL}) = string(Q) + "{" + toString(M, PDL) + "}" .

    op toString : Module ParameterDeclList -> String .
    eq toString(M, (nil).ParameterDeclList) = "" .
    eq toString(M, S :: ME) = string(S) + " :: " + toString(M, ME) .
    eq toString(M, (PD, PDL)) = toString(M, PD) + ", " + toString(M, PDL) [ owise ] .

    op toString : Module ModuleExpression -> String .
    eq toString(M, Q) = string(Q) .
    eq toString(M, ME { PL }) = toString(M, ME) + "{" + toString(PL) + "}" .
    eq toString(M, ME + ME') = toString(M, ME) + " + " + toString(M, ME') .
    eq toString(M, ME *(RS)) = toString(M, ME) + " * (" + toString(M, RS) + ")" .

    op toString : Module RenamingSet -> String .
    eq toString(M, sort F to F') = "sort " + string(F) + " to " + string(F') .
    eq toString(M, op F to F' [ ATS ]) = "op " + string(F) + " to " + string(F') + " [ " + toString(M, ATS) + " ]" .
    eq toString(M, op F : TYL -> TY to F' [ ATS ]) = "op " + string(F) + " : " + toString(TYL) + " -> " + string(TY) + " to " + string(F') + " [ " + toString(M, ATS) + " ]" .
    eq toString(M, label F to F') = "label " + string(F) + " to " + string(F') .
    eq toString(M, R, RS) = toString(M,R) + ", " + toString(M,RS) [ owise ] .

    op toString : Module ImportList -> String .
    eq toString(M, (nil).ImportList) = "" .
    eq toString(M, extending ME . IL) = "  ex " + toString(M, ME) + " .\n" + toString(M, IL) .
    eq toString(M, including ME . IL) = "  inc " + toString(M, ME) + " .\n" + toString(M, IL) .
    eq toString(M, protecting ME . IL) = "  pr " + toString(M, ME) + " .\n" + toString(M, IL) .

    op toStringSS : SortSet -> String .
    eq toStringSS((none).SortSet) = "" .
    eq toStringSS((S ; none)) = "  sort " + string(S) + " .\n" .
    eq toStringSS(SS) = "  sorts " + toStringSS'(SS) + " .\n" [ owise ] .

    op toStringSS' : SortSet -> String .
    eq toStringSS'(S) = string(S) .
    eq toStringSS'((S ; SS)) = string(S) + " " + toStringSS'(SS) [ owise ] .

    op toString : SubsortDeclSet -> String .
    eq toString((none).SubsortDeclSet) = "" .
    eq toString(subsort S < S' .) = "  subsort " + string(S) + " < " + string(S') + " .\n" .
    eq toString(SSD SSDS) = toString(SSD) + toString(SSDS) [ owise ] .

    op toString : Module AttrSet -> String .
    eq toString(M, (none).AttrSet) = "" .
    eq toString(M, assoc) = "assoc" .
    eq toString(M, comm) = "comm" .
    eq toString(M, idem) = "idem" .
    eq toString(M, iter) = "iter" .
    eq toString(M, id(T)) = "id: " + toString(M,T) .
    eq toString(M, left-id(T)) = "left-id: " + toString(M,T) .
    eq toString(M, right-id(T)) = "right-id: " + toString(M,T) .
    eq toString(M, strat(NeNL)) = "strat (" + toString(NeNL) + ")" .
    eq toString(M, memo) = "memo" .
    eq toString(M, prec(N)) = "prec " + string(N,10) .
    eq toString(M, gather(FL)) = "gather (" + toString(FL) + ")" .
    eq toString(M, format(FL)) = "format (" + toString(FL) + ")" .
    eq toString(M, ctor) = "ctor" .
    eq toString(M, config) = "config" .
    eq toString(M, object) = "object" .
    eq toString(M, msg) = "msg" .
    eq toString(M, frozen(NeNL)) = "frozen (" + toString(NeNL) + ")" .
    eq toString(M, poly(NeNL)) = "poly (" + toString(NeNL) + ")" .
    eq toString(M, special(NeHL)) = "special (" + toString(M, NeHL) + ")" .
    eq toString(M, label(F)) = "label " + string(F) .
    eq toString(M, metadata(STR)) = "metadata \"" + STR + "\"" .
    eq toString(M, owise) = "owise" .
    eq toString(M, nonexec) = "nonexec" .
    eq toString(M, variant) = "variant" .
    eq toString(M, narrowing) = "narrowing" .
    eq toString(M, print(FL)) = "print" .
    eq toString(M, A ATS) = toString(M, A) + " " + toString(M, ATS) [ owise ] .

    op toString : NatList -> String .
    eq toString(N nil) = string(N,10) .
    eq toString(N NL) = string(N,10) + " " + toString(NL) [ owise ] .

    op toString : QidList -> String .
    eq toString((nil).QidList) = "" .
    eq toString(F) = string(F) .
    eq toString(F FL) = string(F) + " " + toString(FL) [ owise ] .

    op toString : Module HookList -> String .
    eq toString(M, (nil).HookList) = "" .
    eq toString(M, id-hook(F,FL)) = if (FL == nil) then "id-hook " + string(F) else "id-hook " + string(F) + " (" + toString(FL) + ")" fi .
    eq toString(M, term-hook(F,T)) = "term-hook " + string(F) + " (" + toString(M,T) + ")" .
    eq toString(M, op-hook(F,F',FL,F'')) = "op-hook " + string(F) + " (" + string(F') + " : " + toString(FL) + " ~> " + string(F'') + ")" .
    eq toString(M, HK HKL) = toString(M,HK) + (if (HKL == nil) then "" else " " + toString(M,HKL) fi) [ owise ] .

    op toString : Expression -> String .
    eq toString(S{S'}) = string(S) + "{" + string(S') + "}" .
    eq toString(EXP{NPL}) = toString(EXP) + "{" + toString(NPL) + "}" .

    op toString : ParameterList -> String .
    eq toString((empty).ParameterList) = "" .
    eq toString((EXP, NPL)) = toString(EXP) + ", " + toString(NPL) [ owise ] .

    op toString : Module OpDeclSet -> String .
    eq toString(M, (none).OpDeclSet) = "" .
    eq toString(M, (op F : TYL -> TY [ ATS ] .)) =
        if (ATS == none)
        then "  op " + string(F) + (if (TYL == nil) then " : -> " else " : " + toString(TYL) + " -> " fi) + cleanString(TY) + " .\n"
        else "  op " + string(F) + (if (TYL == nil) then " : -> " else " : " + toString(TYL) + " -> " fi) + cleanString(TY) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, OPD OPDS) = toString(M,OPD) + toString(M,OPDS) [ owise ] .

    op toString : Module MembAxSet -> String .
    eq toString(M, (none).MembAxSet) = "" .
    eq toString(M, (mb T : S [ ATS ] .)) =
        if (ATS == none)
        then "  mb " + toString(M, T) + " : " + string(S) + " .\n"
        else "  mb " + toString(M, T) + " : " + string(S) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, (cmb T : S if COND [ ATS ] .)) =
        if (ATS == none)
        then "  cmb " + toString(M, T) + " : " + string(S) + " if " + toString(M, COND) + " .\n"
        else "  cmb " + toString(M, T) + " : " + string(S) + " if " + toString(M, COND) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, MA MAS) = toString(M, MA) + toString(M, MAS) [ owise ] .

    op toString : Module EquationSet -> String .
    eq toString(M, (none).EquationSet) = "" .
    eq toString(M, (eq LHS = RHS [ ATS ] .)) =
        if (ATS == none)
        then "  eq " + toString(M, LHS) + " = " + toString(M, RHS) + " .\n"
        else "  eq " + toString(M, LHS) + " = " + toString(M, RHS) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, (ceq LHS = RHS if COND [ ATS ] .)) =
        if (ATS == none)
        then "  ceq " + toString(M, LHS) + " = " + toString(M, RHS) + " if " + toString(M, COND) + " .\n"
        else "  ceq " + toString(M, LHS) + " = " + toString(M, RHS) + " if " + toString(M, COND) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, EQ EQS) = toString(M, EQ) + toString(M, EQS) [ owise ] .

    op toString : Module RuleSet -> String .
    eq toString(M, (none).RuleSet) = "" .
    eq toString(M, (rl LHS => RHS [ ATS ] .)) =
        if (ATS == none)
        then "  rl " + toString(M, LHS) + " => " + toString(M, RHS) + " .\n"
        else "  rl " + toString(M, LHS) + " => " + toString(M, RHS) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, (crl LHS => RHS if COND [ ATS ] .)) =
        if (ATS == none)
        then "  crl " + toString(M, LHS) + " => " + toString(M, RHS) + " if " + toString(M, COND) + " .\n"
        else "  crl " + toString(M, LHS) + " => " + toString(M, RHS) + " if " + toString(M, COND) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, RL RLS) = toString(M, RL) + toString(M, RLS) [ owise ] .

    op toString : Module Condition -> String .
    eq toString(M, (nil).Condition) = "" .
    eq toString(M, (T : S)) = toString(M, T) + " : " + string(S) .
    eq toString(M, (T = T')) = if (T' == 'true.Bool) then toString(M, T) else toString(M, T) + " = " + toString(M, T') fi .
    eq toString(M, (T' := T)) = toString(M, T') + " := " + toString(M, T) .
    eq toString(M, (T => T')) = toString(M, T) + " => " + toString(M, T') .
    eq toString(M, COND /\ COND') = toString(M, COND) + " /\\ " + toString(M, COND') [ owise ] .

    op toString : Module StratDeclSet -> String .
    eq toString(M, (none).StratDeclSet) = "" .
    eq toString(M, (strat F : TYL @ TY [ ATS ] .)) =
        if (ATS == none)
        then "  strat " + string(F) + (if (TYL == nil) then " : @ " else " : " + toString(TYL) + " @ " fi) + cleanString(TY) + " .\n"
        else "  strat " + string(F) + (if (TYL == nil) then " : @ " else " : " + toString(TYL) + " @ " fi) + cleanString(TY) + " [ " + toString(M,ATS) + " ] .\n"
        fi .
    eq toString(M,STD STDS) = toString(M,STD) + toString(M, STDS) [ owise ] .

    op toString : Module StratDefSet -> String .
    eq toString(M, (none).StratDefSet) = "" .
    eq toString(M, (sd CST := STA [ ATS ] .)) =
        if (ATS == none)
        then "  rl " + toString(M, CST) + " := " + toString(M, STA) + " .\n"
        else "  rl " + toString(M, CST) + " := " + toString(M, STA) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M, (csd CST := STA if COND [ ATS ] .)) =
        if (ATS == none)
        then "  csd " + toString(M, CST) + " := " + toString(M, STA) + " if " + toString(M, COND) + " .\n"
        else "  csd " + toString(M, CST) + " := " + toString(M, STA) + " if " + toString(M, COND) + " [ " + toString(M, ATS) + " ] .\n"
        fi .
    eq toString(M,STDF STDFS) = toString(M, STDF) + toString(M, STDFS) [ owise ] .

    op toString : Module CallStrategy -> String .
    eq toString(M, F [[ empty ]]) = string(F) .
    eq toString(M, F [[ TL ]]) = string(F) + " [[ " + toString(M, TL) + " ]]" [ owise ] .

    op toString : Module StrategyList -> String .
    eq toString(M, (empty).StrategyList) = "" .
    eq toString(M, fail) = "fail" .
    eq toString(M, idle) = "idle" .
    eq toString(M, top(RAP)) = "top " + toString(M, RAP) .
    eq toString(M, match T s.t. COND) = "match " + toString(M, T) + " s.t. " + toString(M, COND) .
    eq toString(M, xmatch T s.t. COND) = "xmatch " + toString(M, T) + " s.t. " + toString(M, COND) .
    eq toString(M, amatch T s.t. COND) = "amatch " + toString(M, T) + " s.t. " + toString(M, COND) .
    ceq toString(M, STA | STA') = toString(M, STA) + " | " + toString(M, STA') if (STA =/= fail) /\ (STA' =/= fail) .
    ceq toString(M, STA ; STA') = toString(M, STA) + " ; " + toString(M, STA') if (STA =/= idle) /\ (STA' =/= fail) .
    eq toString(M, STA or-else STA') = toString(M, STA) + " or-else " + toString(M, STA') .
    eq toString(M, STA +) = toString(M, STA) + " +" .
    eq toString(M, STA ? STA' : STA'') = toString(M, STA) + " ? " + toString(M, STA') + " : " + toString(M, STA'') .
    eq toString(M, matchrew T s.t. COND by UPS) = "match " + toString(M, T) + " s.t. " + toString(M, COND) + " by " + toString(M, UPS) .
    eq toString(M, xmatchrew T s.t. COND by UPS) = "xmatch " + toString(M, T) + " s.t. " + toString(M, COND) + " by " + toString(M, UPS) .
    eq toString(M, amatchrew T s.t. COND by UPS) = "amatch " + toString(M, T) + " s.t. " + toString(M, COND) + " by " + toString(M, UPS) .
    eq toString(M, (STA)*) = "( " + toString(M, STA) + " )*" .
    eq toString(M, (STA)!) = "( " + toString(M, STA) + " )!" .
    eq toString(M, not(STA)) =  "not(" + toString(M, STA) + ")" .
    eq toString(M, test(STA)) = "test(" + toString(M, STA) + ")" .
    eq toString(M, try(STA)) = "try( " + toString(M, STA) + ")" .
    eq toString(M, one(STA)) = "one(" + toString(M, STA) + ")" .
    eq toString(M, (STL , STL')) = toString(M, STL) + " ; " + toString(M, STL') [ owise ] .

    op toString : Module RuleApplication -> String .
    eq toString(M, all) = "all" .
    eq toString(M, F [ SB ]{ empty }) = string(F) + "[ " + toString(M, SB) + " ]" .
    eq toString(M, F [ SB ]{ STL }) = string(F) + "[ " + toString(M, SB) + " ]{ " + toString(M, STL) + " }" [ owise ] .

    op toString : Module UsingPairSet -> String .
    eq toString(M, V using STA) = toString(M, V) + " using " + toString(M, STA) .
    eq toString(M, (UPS , UPS')) = toString(M, UPS) + " , " + toString(M, UPS') [ owise ] .

    op toString : Module Substitution -> String .
    eq toString(M, (none).Substitution) = "" .
    eq toString(M, V <- T) = toString(M, V) + " <- " + toString(M, T) .
    eq toString(M, V <- T ; SB) = toString(M, V) + " <- " + toString(M, T) + ", " + toString(M, SB) [ owise ] .

    op toString : Module GenSetCollectionSet QidList -> String .
    eq toString(M, (mt).GenSetCollectionSet, QL) = "" .
    eq toString(M, [ TY | DEF | nil ] GCS, QL) = CYAN + "  Generator sets for sort " + string(TY) + ":" + WHITE + "\n\n  No generators defined.\n\n" + toString(M, GCS, QL) .
    eq toString(M, [ TY | DEF | GSL1 [ DEF : NTS ] GSL2 ] GCS, 'all) = CYAN + "  Generator sets for sort " + string(TY) + ":\n\n" + toString(M, [ DEF : NTS ] GSL1 GSL2, DEF) + toString(M, GCS, 'all) .
    eq toString(M, [ TY | DEF | [ STR : NTS ] ], 'new) = CYAN + "  Generator set " + STR + " for sort " + string(TY) + " added.\n\n" + toString(M, [ STR : NTS ], DEF) .
    eq toString(M, [ TY | DEF | [ STR : NTS ] ], 'one) = CYAN + "  Generator set " + STR + " for sort " + string(TY) + ":\n\n" + toString(M, [ STR : NTS ], DEF) .

    op toString : Module GenSetList String -> String .
    eq toString(M, (nil).GenSetList, DEF) = "\n\n" .
    eq toString(M, [ DEF : NTS ] GSL, DEF) = "  " + WHITE + DEF + " (" + GREEN + "default" + WHITE + "): " + BW + toStringGS(M, NTS) + (if GSL == nil then "" else "\n\n" fi) + toString(M, GSL, DEF) .
    eq toString(M, [ STR : NTS ] GSL, DEF) = "  " + WHITE + STR + ": " + BW + toStringGS(M, NTS) + (if GSL == nil then "" else "\n\n" fi) + toString(M, GSL, DEF) [ owise ] .

    op toStringGS : Module TermSet -> String .
    eq toStringGS(M, mt) = "" .
    eq toStringGS(M, T) = "\n    " + toString(M, T) .
    eq toStringGS(M, T ;; NTS) = "\n    " + toString(M, T) + toStringGS(M, NTS) .

    --- Input in ns
    op toStringTime : Nat -> String .
    eq toStringTime(N) = toStringTime((((N quo 1000000000) quo 60) quo 60) quo 24, (((N quo 1000000000) quo 60) quo 60) rem 24, (((N quo 1000000000) quo 60) rem 60), ((N quo 1000000000) rem 60)) .

    op toStringTime : Nat Nat Nat Nat -> String .
    eq toStringTime(0, 0, 0, SEC) = string(SEC,10) + "s" .
    eq toStringTime(0, 0, s(MIN), 0) = string(s(MIN), 10) + "m" .
    eq toStringTime(0, 0, s(MIN), s(SEC)) = string(s(MIN), 10) + "m " + string(s(SEC),10) + "s" .
    
    eq toStringTime(s(DAY), 0, 0, SEC) = string(SEC,10) + "s" .
    eq toStringTime(s(DAY), 0, s(MIN), 0) = string(s(MIN), 10) + "m" .
    eq toStringTime(s(DAY), 0, s(MIN), s(SEC)) = string(s(MIN), 10) + "m " + string(s(SEC),10) + "s" .
    
    eq toStringTime(0, s(HOUR), 0, 0) = string(s(HOUR), 10) + "h" .
    eq toStringTime(0, s(HOUR), 0, s(SEC)) = string(s(HOUR), 10) + "h " + string(s(SEC),10) + "s" .
    eq toStringTime(0, s(HOUR), s(MIN), 0) = string(s(HOUR), 10) + "h " + string(s(MIN), 10) + "m" .
    eq toStringTime(0, s(HOUR), s(MIN), s(SEC)) = string(s(HOUR), 10) + "h " + string(s(MIN), 10) + "m " + string(s(SEC),10) + "s" .

    eq toStringTime(s(DAY), s(HOUR), 0, 0) = string(s(DAY), 10) + "d " + string(s(HOUR), 10) + "h" .
    eq toStringTime(s(DAY), s(HOUR), 0, s(SEC)) = string(s(DAY), 10) + "d " + string(s(HOUR), 10) + "h " + string(s(SEC),10) + "s" .
    eq toStringTime(s(DAY), s(HOUR), s(MIN), 0) = string(s(DAY), 10) + "d " + string(s(HOUR), 10) + "h " + string(s(MIN), 10) + "m" .
    eq toStringTime(s(DAY), s(HOUR), s(MIN), s(SEC)) = string(s(DAY), 10) + "d " + string(s(HOUR), 10) + "h " + string(s(MIN), 10) + "m " + string(s(SEC),10) + "s" .

    op toString : SimpStratList -> String .
    eq toString((nil).SimpStratList) = CYAN + "  Simplification strategies:" + BW + "\n\n  No simplification strategies defined.\n\n" .
    eq toString(SSL) = CYAN + "  Simplification strategies:\n\n" + toString'(SSL, true) [ owise ] .

    op toString' : SimpStratList Bool -> String .
    eq toString'((nil).SimpStratList, B) = "" .
    eq toString'([ STR : STA] SSL, true) = "  " + WHITE + STR + " (" + GREEN + "default" + WHITE + "): " + BW + toString(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false), STA) + BW + ".\n\n" + toString'(SSL, false) .
    eq toString'([ STR : STA] SSL, false) = "  " + WHITE + STR + BW + ": " + toString(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false), STA) + BW + ".\n\n" + toString'(SSL, false) .
endfm

fmod NuITP-STATS is 
    pr NuITP-STRING .
    sort RuleNat RuleNatSet .
    subsort RuleNat < RuleNatSet .

    op mt : -> RuleNatSet [ ctor ] .
    op {_:_} : Qid Nat -> RuleNat [ ctor ] .
    op __ : RuleNatSet RuleNatSet -> RuleNatSet [ ctor assoc comm id: mt ] .

    vars GS GS' : GoalSet .
    var RAS : RuleNatSet .
    var GID : QidList .
    var RID : Qid .
    vars INTER FRO SFRO : Bool .
    vars N VC : Nat .
    vars SKO HPS : TermSet .
    var CLA : Term .

    op toString : RuleNatSet -> String .
    eq toString((mt).RuleNatSet) = "\n" + BW .
    eq toString({ RID : N } RAS) = "  " + WHITE + string(RID) + ": " + BW + string(N, 10) + "\n" + toString(RAS) .
    
    op getStats : GoalSet -> String .
    eq getStats(mt) = CYAN + "  Total Goals: " + BW + "0\n\n" + CYAN + "  Rule Applications\n\n" + BW + "  none\n\n" + CYAN + "  Generated By\n\n" + BW + "  none" .
    eq getStats(GS) = CYAN + "  Total Goals: " + BW + string(size(GS),10) + CYAN + "\n\n  Rule Applications\n\n" + BW + toString(getRuleApps(GS)) + CYAN + "  Generated By\n\n" + BW + toString(getGeneratedBy(GS)) [ owise ] .

    op getRuleApps : GoalSet -> RuleNatSet .
    eq getRuleApps(GS) = getRuleApps'(GS, GS, mt) .

    op getRuleApps' : GoalSet GoalSet RuleNatSet -> RuleNatSet .
    eq getRuleApps'(mt, GS, RAS) = RAS .
    eq getRuleApps'({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'true.NuITP-Bool } GS, GS', RAS) = getRuleApps'(GS, GS', RAS) .
    eq getRuleApps'({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, 'false.NuITP-Bool } GS, GS', RAS) = getRuleApps'(GS, GS', RAS) .
    eq getRuleApps'({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, GS', RAS) = getRuleApps'(GS, GS', addRuleNat(getGoal(GS', GID tokenize(". 1")), RAS)) .

    op getGeneratedBy : GoalSet -> RuleNatSet .
    eq getGeneratedBy(GS) = getGeneratedBy'(GS, mt) .

    op getGeneratedBy' : GoalSet RuleNatSet -> RuleNatSet .
    eq getGeneratedBy'(mt, RAS) = RAS .
    eq getGeneratedBy'({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS, RAS) = getGeneratedBy'(GS, addRuleNat({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, RAS)) .

    op addRuleNat : GoalSet RuleNatSet -> RuleNatSet .
    eq addRuleNat(mt, RAS) = RAS .
    eq addRuleNat({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, { RID : N } RAS) = { RID : s(N) } RAS .
    eq addRuleNat({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, RAS) = { RID : 1 } RAS [ owise ] .
endfm

fmod NuITP-REPORT-HTML is
    pr NuITP-STRING .

    vars M MO INTMOD : Module .
    vars ID STR : String .
    var LOG : Log .
    var GCS : GenSetCollectionSet .
    var GS : GoalSet .
    var GID : QidList .
    vars SKO HPS : TermSet .
    var NTS : NeTermSet .
    vars CLA T TM TI TL TP TF LHS RHS GAMMA LAMBDA : Term .
    vars MODNAME RID Q Q' : Qid .
    var QL : QidList .
    vars FRO SFRO INTER : Bool .
    vars VC N : Nat .
    var G : Goal .
    var H : Header .
    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .
    var STDS : StratDeclSet .
    var STDFS : StratDefSet .
    
    op HTML-TEMPLATE : -> String .
    eq HTML-TEMPLATE = "<!-- This report has been automatically generated by NuITP " + NuITP-VERSION + " -->\n\n<!doctype html>\n<html>\n\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  <title>NuITP " + NuITP-VERSION + " Proof</title>\n  <style>\n    * { margin: 0; padding: 0; }\n    body{ font-family: \"Open Sans\", serif; font-size: small; line-height: 1.5; }\n    section { max-width: 900px; margin: 0 auto; padding-top: 40px; }\n    .content{ padding: 10px; }\n    .goal{ font-family: \"Open Sans\", serif; font-size: small; margin-bottom: 30px; }\n    .goalL{ font-weight: bold; }\n    .goalD{ padding-left: 15px; }\n    hr { border: 1px solid black; }\n    h1 { font-size: 25px; line-height: 10px; margin-top: 30px; }\n    h2 { font-variant: small-caps; font-variant-caps: small-caps; font-size: 20px; }\n    nav { position:fixed; top:0; width:100%; height: 30px; text-align: center; padding-top: 8px;  background-color: #6495ED; color: #FFFFFF; }\n    .navlink { text-decoration:none; color: white; font-size: 14px; }\n    .navlink:visited { text-decoration:none; color: white; font-weight: bold; font-size: 20px; font-variant: small-caps; font-variant-caps: all-small-caps; }\n    .mod { padding-left: 15px; }\n    .sat { color: #8DB600; float: right; }\n    .unsat { color: #FF0000; float: right; }\n    .local { color: #AFE1AF; float: right; }\n    .open { color: #FFA500; float: right; }\n    .node{ cursor: pointer; }\n    .node circle { fill: #fff; stroke: steelblue; stroke-width: 1.5px; }\n    .node text { font: 10px sans-serif; }\n    .link { fill: none; stroke: #ccc; stroke-width: 1.5px; }\n    #svgcontainer { margin: 0 auto;}\n  </style>\n  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n  <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n  <link href=\"https://fonts.googleapis.com/css2?family=Inconsolata&family=Open+Sans&display=swap\" rel=\"stylesheet\">\n  <script src=\"https://d3js.org/d3.v3.min.js\" charset=\"utf-8\"></script>\n</head>\n\n<body>\n\n<nav>\n  <a class=\"navlink\" href=\"#sec:goal\">GOAL</a>&nbsp;&sdot;&nbsp;\n  <a class=\"navlink\" href=\"#sec:script\">SCRIPT</a>&nbsp;&sdot;&nbsp;\n  <a class=\"navlink\" href=\"#sec:theory\">REWRITING THEORY</a>&nbsp;&sdot;&nbsp;\n  <a class=\"navlink\" href=\"#sec:goals\">GOALS</a>&nbsp;&sdot;&nbsp;\n  <a class=\"navlink\" href=\"#sec:tree\">PROOF TREE</a>\n</nav>\n\n<section>\n<br>\n<h1>NuITP (" + NuITP-VERSION + ") Proof<span class=\"PLACEHOLDER-PROOFSTATESTYLE\">PLACEHOLDER-PROOFSTATE</span></h1>\n<br>\n</section>\n\n<section id=\"sec:goal\">\n<h2>Goal</h2>\n<hr>\n<div id=\"goal\" class=\"content\">\nPLACEHOLDER-LEMMA\n</div>\n</section>\n\n<section id=\"sec:script\">\n<h2>Script</h2>\n<hr>\n<div id=\"script\" class=\"content\">\nPLACEHOLDER-SCRIPT\n</div>\n</section>\n\n<section id=\"sec:theory\">\n<h2>Rewriting Theory</h2>\n<hr>\n<div id=\"theory\" class=\"content\">\nPLACEHOLDER-THEORY\n</div>\n</section>\n\n<section id=\"sec:goals\">\n<h2>Goals</h2>\n<hr>\n<div id=\"goals\" class=\"content\">\nPLACEHOLDER-GOALS\n</div>\n</section>\n\n<section id=\"sec:tree\">\n<h2>Proof Tree</h2>\n<hr>\n</section>\n<div id=\"tree\"></div>\nPLACEHOLDER-TREE\n</body>\n</html>\n\n" .

    op toHTMLSKO : Module TermSet -> String .
    eq toHTMLSKO(M,mt) = "" .
    eq toHTMLSKO(M,T) = toString(M,T) + "." + string(getType(T)) .
    eq toHTMLSKO(M,T ;; NTS) = toString(M,T) + "." + string(getType(T)) + "<br>\n" + toHTMLSKO(M,NTS) .

    op toHTMLHPS : Module TermSet -> String .
    eq toHTMLHPS(M, mt) = "" .
    eq toHTMLHPS(M, T) = toHTMLCLA(M, T) .
    eq toHTMLHPS(M, T ;; NTS) = toHTMLCLA(M, T) + "<br>\n" + toHTMLHPS(M, NTS) .

    op toHTMLCLA : Module Term -> String .
    eq toHTMLCLA(M, 'true.NuITP-Bool) = "true" .
    eq toHTMLCLA(M, 'false.NuITP-Bool) = "false" .
    eq toHTMLCLA(M, '_=_[LHS,RHS]) = toString(M, LHS) + " = " + toString(M, RHS) .
    eq toHTMLCLA(M, '_=>_[LHS,RHS]) = toString(M, LHS) + "<b> &rArr; </b>" + toString(M, RHS) .
    eq toHTMLCLA(M, '_->_['true.NuITP-Bool,LAMBDA]) = replaceAll(toString(M, LAMBDA), " => ", "<b> &rArr; </b>") .
    eq toHTMLCLA(M, '_->_[GAMMA,LAMBDA]) = toString(M, GAMMA) + "<b> &rarr; </b>" + replaceAll(toString(M, LAMBDA), " => ", "<b> &rArr; </b>") [ owise ] .

    op toHTML : Log -> String .
    eq toHTML(nil) = "" .
    eq toHTML([ GID : STR] LOG) = replaceAll(replaceAll(STR, " => ", "<b> &rArr; </b>"), " -> ", "<b> &rarr; </b>") + "<br>" + toHTML(LOG) .

    op toHTML : Module -> String .
    eq toHTML(M) = replaceAll(toHTMLAllMods(getAllMods(M)), "\n", "<br>\n") .

    op toHTMLAllMods : QidList -> String .
    eq toHTMLAllMods(nil) = "" .
    eq toHTMLAllMods(Q) = toHTML'(upModule(Q, false)) .
    eq toHTMLAllMods(Q Q' QL) = toHTML'(upModule(Q, false)) + "\n\n" + toHTMLAllMods(Q' QL) [ owise ] .

    op toHTML' : Module -> String .
    eq toHTML'(fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm) =
        "fmod " +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), H) +
        " is<div class=\"mod\">" +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), OPDS) +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), MAS) +
        toString((fmod H is IL sorts SS . SSDS OPDS MAS EQS endfm), EQS) +
        "</div>endfm" .

    eq toHTML'(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) =
        "mod " +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), H) +
        " is<div class=\"mod\">" +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), OPDS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), MAS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), EQS) +
        toString((mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm), RLS) +
        "</div>endm" .

    eq toHTML'(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm) =
        "smod " +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), H) +
        " is<div class=\"mod\">" +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), OPDS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), MAS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), EQS) +
        toString((smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm), RLS) +
        "</div>endsm" .

    eq toHTML'(fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth) =
        "fth " +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), Q) +
        " is<div class=\"mod\">" +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), OPDS) +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), MAS) +
        toString((fth Q is IL sorts SS . SSDS OPDS MAS EQS endfth), EQS) +
        "</div>endfth" .

    eq toHTML'(th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth) =
        "th " +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), Q) +
        " is<div class=\"mod\">" +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), OPDS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), MAS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), EQS) +
        toString((th Q is IL sorts SS . SSDS OPDS MAS EQS RLS endth), RLS) +
        "</div>endth" .

    eq toHTML'(sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth) =
        "sth " +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), H) +
        " is<div class=\"mod\">" +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), IL) +
        toStringSS(SS) +
        toString(SSDS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), OPDS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), MAS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), EQS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), RLS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), STDS) +
        toString((sth H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsth), STDFS) +
        "</div>endsth" .
    eq toHTML'(M) = "Error printing module." [ owise ] .

    op toHTML : Module GoalSet -> String .
    eq toHTML(M, (mt).GoalSet) = "" .
    eq toHTML(M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA}) = 
        "<div id=\"G" + join(GID) + "\" class=\"goal\">\n" +
        "<span class=\"goalL\">Goal Id:</span>&nbsp;&nbsp;<a href=\"#N" + join(GID) + "\">" + join(GID) + "</a><br>\n" +
        "<span class=\"goalL\">Generated By:</span>&nbsp;&nbsp;" + string(RID) + "<br>\n" +
        "<span class=\"goalL\">Skolem Ops:</span>\n<div class=\"goalD\">" + if (SKO == mt) then "None" else toHTMLSKO(addOps(M,SKO),SKO) fi + "</div>\n" +
        "<span class=\"goalL\">Executable Hypotheses:</span>\n<div class=\"goalD\">" + if (he(M, SKO, HPS) == mt) then "None" else toHTMLHPS(addOps(M,SKO),he(M, SKO, HPS)) fi + "</div>\n" +
        "<span class=\"goalL\">Non-Executable Hypotheses:</span>\n<div class=\"goalD\">" + if (hne(M, SKO, HPS) == mt) then "None" else toHTMLHPS(addOps(M,SKO),hne(M, SKO, HPS)) fi + "</div>\n" +
        "<span class=\"goalL\">Goal:</span>\n<div class=\"goalD\">" + toHTMLCLA(addOps(M,SKO),CLA) + 
        "</div>\n</div>\n" .
    eq toHTML(M, G GS) = toHTML(M, G) + toHTML(M, GS) [ owise ] .
    
    op getHTMLReport : Qid Module Log GenSetCollectionSet GoalSet -> String .
    eq getHTMLReport(MODNAME, INTMOD, LOG, GCS, GS) = getHTMLReport(upModule(MODNAME, false), INTMOD, getGoal(GS, '0), LOG, GS, getProofState(GS)) .

    op getHTMLReport : Module Module Goal Log GoalSet ProofState -> String .
    eq getHTMLReport(MO, M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, LOG, GS, sat) = replace(replace(replace(replace(replace(replace(replace(HTML-TEMPLATE, "PLACEHOLDER-PROOFSTATESTYLE", "sat"), "PLACEHOLDER-PROOFSTATE", "Proved"), "PLACEHOLDER-LEMMA", toHTMLCLA(M, CLA)), "PLACEHOLDER-SCRIPT", toHTML(LOG)), "PLACEHOLDER-THEORY", toHTML(MO)), "PLACEHOLDER-GOALS", toHTML(M, GS)), "PLACEHOLDER-TREE", getHTMLProofTree(GID, GS)) .
    eq getHTMLReport(MO, M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, LOG, GS, unsat) = replace(replace(replace(replace(replace(replace(replace(HTML-TEMPLATE, "PLACEHOLDER-PROOFSTATESTYLE", "unsat"), "PLACEHOLDER-PROOFSTATE", "Disproved"), "PLACEHOLDER-LEMMA", toHTMLCLA(M, CLA)), "PLACEHOLDER-SCRIPT", toHTML(LOG)), "PLACEHOLDER-THEORY", toHTML(MO)), "PLACEHOLDER-GOALS", toHTML(M, GS)), "PLACEHOLDER-TREE", getHTMLProofTree(GID, GS)) .
    eq getHTMLReport(MO, M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, LOG, GS, open) = replace(replace(replace(replace(replace(replace(replace(HTML-TEMPLATE, "PLACEHOLDER-PROOFSTATESTYLE", "open"), "PLACEHOLDER-PROOFSTATE", "Open"), "PLACEHOLDER-LEMMA", toHTMLCLA(M, CLA)), "PLACEHOLDER-SCRIPT", toHTML(LOG)), "PLACEHOLDER-THEORY", toHTML(MO)), "PLACEHOLDER-GOALS", toHTML(M, GS)), "PLACEHOLDER-TREE", getHTMLProofTree(GID, GS)) .

    op getHTMLProofTree : QidList GoalSet -> String .
    eq getHTMLProofTree(GID, GS) = 
        "<script>\n" +
        "var margin={top:10,right:10,bottom:10,left:10},width=960-margin.right-margin.left,height=800-margin.top-margin.bottom;\nvar root=" +
        getHTMLProofTree'(GID, GS) + 
        ";\nvar i=0,duration=750,rectW=50,rectH=30;var tree=d3.layout.tree().nodeSize([60,30]);var diagonal=d3.svg.diagonal().projection(function (d){return [d.x+rectW/2,d.y+rectH/2];});var svg=d3.select(\"#tree\").append(\"svg\").style(\"margin\",\"0 auto\").attr(\"width\",\"98%\").attr(\"height\",1000).call(zm=d3.behavior.zoom().scaleExtent([0.05,3]).on(\"zoom\",redraw)).append(\"g\").attr(\"transform\",\"translate(\"+350+\",\"+20+\")\");zm.translate([60,30]);root.x0=0;root.y0=height/2;function collapse(d){if(d.children){d._children=d.children;d._children.forEach(collapse);d.children=null;}}update(root);d3.select(\"#tree\").style(\"height\",\"800px\");d3.select(\"svg\").on(\"dblclick.zoom\",null);d3.select('body').append('div').attr('id', 'tooltip').attr('style', 'position: absolute; opacity: 0; background-color: white; border: 1px solid black; border-radius: 2px; padding-left: 10px; padding-right: 10px; padding-top: 5px; padding-bottom: 5px;');function update(source){var nodes=tree.nodes(root).reverse(),links=tree.links(nodes);nodes.forEach(function (d){d.y=d.depth*80;});var node=svg.selectAll(\"g.node\").data(nodes,function (d){return d.id || (d.id=++i);});var nodeEnter=node.enter().append(\"g\").attr(\"class\",\"node\").attr(\"id\", function (d){return \"N\"+d.name;}).attr(\"transform\",function (d){return \"translate(\"+source.x0+\",\"+source.y0+\")\";}).on(\"dblclick\",dblclick).on('mouseover',function(d){d3.select('#tooltip').transition().duration(200).style('opacity',1).text(d.name)}).on('mouseout',function(d){d3.select('#tooltip').style('opacity',0);}).on('mousemove',function(d){d3.select('#tooltip').style('left',(d3.event.pageX+10)+'px').style('top',(d3.event.pageY+10)+'px');});nodeEnter.append(\"rect\").attr(\"width\",rectW).attr(\"height\",rectH).attr(\"stroke\",\"black\").attr(\"stroke-width\",1).attr(\"rx\",2).style(\"fill\",function (d){if(d.state == \"sat\") return \"#00FF00\";if(d.state == \"unsat\") return \"#FF0000\";if (d.state == \"local\") return \"#AFE1AF\";return d._children?\"#A7C7E7\":\"#FFFFFF\";});nodeEnter.append(\"text\").attr(\"x\",rectW/2).attr(\"y\",rectH/2).attr(\"dy\",\".35em\").attr(\"text-anchor\",\"middle\").text(function (d){return d.rule;});var nodeUpdate=node.transition().duration(duration).attr(\"transform\",function (d){return \"translate(\"+d.x+\",\"+d.y+\")\";});nodeUpdate.select(\"rect\").attr(\"width\",rectW).attr(\"height\",rectH).attr(\"stroke\",\"black\").attr(\"stroke-width\",1).style(\"fill\",function (d){if(d.state == \"sat\") return \"#00FF00\";if(d.state == \"unsat\") return \"#FF0000\";if (d.state == \"local\") return \"#AFE1AF\";return d._children?\"#A7C7E7\":\"#FFFFFF\";});nodeUpdate.select(\"text\").style(\"fill-opacity\",1);var nodeExit=node.exit().transition().duration(duration).attr(\"transform\",function (d){return \"translate(\"+source.x+\",\"+source.y+\")\";}).remove();nodeExit.select(\"rect\").attr(\"width\",rectW).attr(\"height\",rectH).attr(\"stroke\",\"black\").attr(\"stroke-width\",1);nodeExit.select(\"text\");var link=svg.selectAll(\"path.link\").data(links,function (d){return d.target.id;});link.enter().insert(\"path\",\"g\").attr(\"class\",\"link\").attr(\"x\",rectW/2).attr(\"y\",rectH/2).attr(\"d\",function (d){var o={x:source.x0,y:source.y0};return diagonal({source:o,target:o});});link.transition().duration(duration).attr(\"d\",diagonal);link.exit().transition().duration(duration).attr(\"d\",function (d){var o={x:source.x,y:source.y};return diagonal({source:o,target:o});}).remove();nodes.forEach(function (d){d.x0=d.x;d.y0=d.y;});}function dblclick(d){if(d.children){d._children=d.children;d.children=null;}else{d.children=d._children;d._children=null;}update(d);}function redraw(){svg.attr(\"transform\",\"translate(\"+d3.event.translate+\")\"+\" scale(\"+d3.event.scale+\")\");}" +
        "\n</script>\n" .

    op getHTMLState : Term -> String .
    eq getHTMLState('true.NuITP-Bool) = "sat" .
    eq getHTMLState('false.NuITP-Bool) = "unsat" .
    eq getHTMLState(CLA) = "open" [ owise ] .

    op getHTMLProofTree' : QidList GoalSet -> String .
    eq getHTMLProofTree'(GID, mt) = "" .
    eq getHTMLProofTree'(GID, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = "{\"name\":\"" + join(GID) + "\",\"state\":\"" + if(RID) == 'LSB then "local" else getHTMLState(CLA) fi + "\",\"rule\":\"" + string(RID) + "\"}" .
    eq getHTMLProofTree'(GID, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) = "{\"name\":\"" + join(GID) + "\",\"state\":\"" + if(RID) == 'LSB then "local" else getHTMLState(CLA) fi + "\",\"rule\":\"" + string(RID) + "\",\"children\": [" + getHTMLProofTree''(GS) + "]}" [ owise ] .

    op getHTMLProofTree'' : GoalSet -> String .
    eq getHTMLProofTree''(mt) = "" .
    eq getHTMLProofTree''({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = "{\"name\":\"" + join(GID) + "\",\"state\":\"" + if(RID) == 'LSB then "local" else getHTMLState(CLA) fi + "\",\"rule\":\"" + string(RID) + "\"}" .
    eq getHTMLProofTree''({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) = "{\"name\":\"" + join(GID) + "\",\"state\":\"" + if(RID) == 'LSB then "local" else getHTMLState(CLA) fi + "\",\"rule\":\"" + string(RID) + "\",\"children\":[" + getHTMLProofTree''(getChildren(GS, GID)) + "]}," + getHTMLProofTree''(removeGoals(getChildren(GS, GID), GS)) .
endfm

fmod NuITP-REPORT-TEX is
    pr NuITP-STRING .

    op NuITP-R0 : -> String .
    eq NuITP-R0 = "%This report has been automatically generated by NuITP " + NuITP-VERSION + ".\n\n" .

    op NuITP-R1 : -> String .
    eq NuITP-R1 =
        "\\documentclass[10pt]{report}\n" +
        "\\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3.75cm, bottom=3.75cm]{geometry}\n" +
        "\\usepackage[utf8]{inputenc}\n" +
        "\\usepackage{amssymb}\n" + 
        "\\usepackage{xcolor}\n" +
        "\\usepackage{forest}\n" +
        "\\usepackage{fancyvrb}\n" +
        "\\usepackage{fvextra}\n" +
        "\\usepackage{pdflscape}\n" +
        "\\usepackage{titlesec}\n" +
        "\\usepackage{adjustbox}\n" +
        "\\titleformat*{\\section}{\\normalfont\\fontfamily{phv}\\fontsize{10}{10}\\bfseries}\n" +
        "\\usepackage{fancyhdr}\n" +
        "\\usepackage{lastpage}\n" +
        "\\usepackage[pdftex,pagebackref=true]{hyperref}\n" + 
        "\\definecolor{applegreen}{rgb}{0.55, 0.71, 0.0}\n" +
        "\\pagestyle{fancy}\n" +
        "\\cfoot{\\thepage\\ of \\pageref{LastPage}}\n" +
        "\\newcommand{\\movecounter}{\\noindent\\phantomsection\\vspace{-1em}}\n" +
        "\\renewcommand{\\headrulewidth}{1pt}\n" +
        "\\renewcommand{\\footrulewidth}{1pt}\n" +
        "\\fancyhf{}\n" .

    op NuITP-RSAT : -> String .
    eq NuITP-RSAT = "\\fancyhead[L]{\\fontfamily{phv}\\LARGE\\textbf{NuITP " + NuITP-VERSION + "\\hfill \\color{applegreen}Proved}}\n" .

    op NuITP-RUNSAT : -> String .
    eq NuITP-RUNSAT = "\\fancyhead[L]{\\fontfamily{phv}\\LARGE\\textbf{NuITP " + NuITP-VERSION + "\\hfill \\color{red}Disproved}}\n" .

    op NuITP-ROPEN : -> String .
    eq NuITP-ROPEN = "\\fancyhead[L]{\\fontfamily{phv}\\LARGE\\textbf{NuITP " + NuITP-VERSION + "\\hfill \\color{orange}Unkown}}\n" .

    op NuITP-R2 : -> String .
    eq NuITP-R2 =
        "\\fancyfoot[R]{\\thepage\\ of \\pageref{LastPage}}\n" +
        "\\begin{document}\n" +
        "\\small\n\n" +
        "\\movecounter\n" + 
        "\\section*{Goal}\n" +
        "\\begin{Verbatim}[breaklines=true]\n" .

    op NuITP-R3 : -> String .
    eq NuITP-R3 =
        "\n\\end{Verbatim}\n\n" +
        "\\movecounter\n" + 
        "\\section*{Script}\n" +
        "\\begin{Verbatim}[breaklines=true]\n" .

    op NuITP-R4 : -> String .
    eq NuITP-R4 =
        "\\end{Verbatim}\n\n" +
        "\\movecounter\n" + 
        "\\section*{Rewriting Theory}\n" +
        "\\begin{Verbatim}[breaklines=true]\n" .

    op NuITP-R5 : -> String .
    eq NuITP-R5 =
        "\n\\end{Verbatim}\n\n" +
        "\\movecounter\n" + 
        "\\section*{Proof Goals}\n" .

    op NuITP-R6 : -> String .
    eq NuITP-R6 =
        "\\newpage\n" +
        "\\thispagestyle{empty}\n" +
        "\\begin{landscape}\n" +
        "\\centering\n" +
        "\\begin{adjustbox}{max width=\\linewidth}\n" +
        "\\movecounter\n" +
        "\\begin{forest}\n" +
        "for tree={\n" +
        "    rounded rectangle,\n" +
        "    thick,\n" +
        "    l sep=0.6cm,\n" +
        "    s sep=0.6cm,\n" +
        "    node options={draw,font=\\sffamily},\n" +
        "    edge={semithick},\n" +
        "    minimum height=1cm,\n" +
        "    minimum width=1cm,\n" +
        "    start/.style={\n" +
        "        draw=black,\n" +
        "        fill=blue!10,\n" +
        "        double,\n" +
        "        outer sep=1pt,\n" +
        "        text height=1.5ex,\n" +
        "        text depth=.25ex,\n" +
        "    },\n" +
        "    sat/.style={\n" +
        "        draw=black,\n" +
        "        fill=green!20,\n" +
        "        text height=1.5ex,\n" +
        "        text depth=.25ex,\n" +
        "    },\n" +
        "    unsat/.style={\n" +
        "        draw=black,\n" +
        "        fill=red!20,\n" +
        "        text height=1.5ex,\n" +
        "        text depth=.25ex,\n" +
        "    },\n" +
        "    open/.style={\n" +
        "        draw=black,\n" +
        "        fill=orange!20,\n" +
        "        text height=1.5ex,\n" +
        "        text depth=.25ex,\n" +
        "    },\n" +
        "label/.style={\n" +
        "    edge label={\n" +
        "        node [midway, fill=white, font=\\scriptsize] {#1}\n" +
        "    }\n" +
        "}}\n" .

    op NuITP-R7 : -> String .
    eq NuITP-R7 =
        "\\end{forest}\n" +
        "\\end{adjustbox}\n" +
        "\\end{landscape}\n" +
        "\\end{document}\n" .

    vars M MO INTMOD : Module .
    vars ID STR : String .
    var LOG : Log .
    var GCS : GenSetCollectionSet .
    var GS : GoalSet .
    var GID : QidList .
    vars SKO HPS : TermSet .
    vars CLA T TM TI TL TP TF : Term .
    vars MODNAME RID : Qid .
    vars FRO SFRO INTER : Bool .
    var VC : Nat .

    op getTeXReport : Qid Module Log GenSetCollectionSet GoalSet -> String .
    eq getTeXReport(MODNAME, INTMOD, LOG, GCS, GS) = getTeXReport(upModule(MODNAME, false), INTMOD, getGoal(GS, '0), LOG, GS, getProofState(GS)) .

    op getTeXReport : Module Module Goal Log GoalSet ProofState -> String .
    eq getTeXReport(MO, M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, LOG, GS, sat) = NuITP-R0 + NuITP-R1 + NuITP-RSAT + NuITP-R2 + toStringCLA(M, CLA) + NuITP-R3 + toStringMin(LOG) + NuITP-R4 + toString(MO) + NuITP-R5 + toStringTeX(M, GS) + NuITP-R6 + getTeXForest(GID, GS) + NuITP-R7 .
    eq getTeXReport(MO, M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, LOG, GS, unsat) = NuITP-R0 + NuITP-R1 + NuITP-RUNSAT + NuITP-R2 + toStringCLA(M, CLA) + NuITP-R3 + toStringMin(LOG) + NuITP-R4 + toString(MO) + NuITP-R5 + toStringTeX(M, GS) + NuITP-R6 + getTeXForest(GID, GS) + NuITP-R7 .
    eq getTeXReport(MO, M, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }, LOG, GS, open) = NuITP-R0 + NuITP-R1 + NuITP-ROPEN + NuITP-R2 + toStringCLA(M, CLA) + NuITP-R3 + toStringMin(LOG) + NuITP-R4 + toString(MO) + NuITP-R5 + toStringTeX(M, GS) + NuITP-R6 + getTeXForest(GID, GS) + NuITP-R7 .

    op getTeXForest : QidList GoalSet -> String .
    eq getTeXForest(GID, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA }) = "[{\\label{node:" + join(GID) + "}\\hyperref[goal:" + join(GID) + "]{" + join(GID) + "}},start\n]" .
    eq getTeXForest(GID, { GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) = "[{\\label{node:" + join(GID) + "}\\hyperref[goal:" + join(GID) + "]{" + join(GID) + "}},start\n" + getTeXForest(GS) + "]\n" [ owise ] .

    op getTeXForest : GoalSet -> String .
    eq getTeXForest(mt) = "" .
    eq getTeXForest({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GS) =
        if getChildren(GS, GID) == mt
        then "[{\\label{node:" + join(GID) + "}\\hyperref[goal:" + join(GID) + "]{" + join(GID) + "}}, label=" + string(RID) + ", " + if (CLA == 'true.NuITP-Bool) then "sat" else if (CLA == 'false.NuITP-Bool) then "unsat" else "open" fi fi + "]\n" + getTeXForest(GS)
        else "[{\\label{node:" + join(GID) + "}\\hyperref[goal:" + join(GID) + "]{" + join(GID) + "}}, label=" + string(RID) + "\n" + getTeXForest(getChildren(GS, GID)) + "]\n" + getTeXForest(removeGoals(getChildren(GS, GID), GS))
        fi [ owise ] .
endfm

fmod NuITP-SYNTAX-GENSET is
    pr QID-LIST .

    sorts Term TermSet Bubble .
    subsort Term < TermSet .

    op bubble : QidList -> Bubble [ special (id-hook Bubble (1 -1 `( `)) op-hook qidListSymbol (__ : QidList QidList ~> QidList) op-hook qidSymbol (<Qids> : ~> Qid) id-hook Exclude ( ;; )) ] .

    op _;;_ : TermSet TermSet -> TermSet [ ctor ] .
    op _;;_ : Bubble TermSet -> TermSet [ ctor ] .
    op _;;_ : Bubble Bubble -> TermSet [ ctor ] .
endfm

fmod NuITP-SYNTAX-DISJUNCTION is
    pr QID-LIST .

    sorts NuITP-Eq NuITP-Rl NuITP-Disjunction Bubble .
    subsort NuITP-Eq NuITP-Rl < NuITP-Disjunction .

    op bubble : QidList -> Bubble [ special (id-hook Bubble (1 -1 `( `)) op-hook qidListSymbol (__ : QidList QidList ~> QidList) op-hook qidSymbol (<Qids> : ~> Qid) id-hook Exclude ( \/ = )) ] .

    op _\/_ : NuITP-Disjunction NuITP-Disjunction -> NuITP-Disjunction [ ctor assoc prec 60 ] .
    op _\/_ : NuITP-Eq NuITP-Disjunction -> NuITP-Disjunction [ ctor assoc prec 60 ] .
    op _\/_ : NuITP-Eq NuITP-Eq -> NuITP-Disjunction [ ctor assoc prec 60 ] .
    op _=_ : Bubble Bubble -> NuITP-Eq [ ctor prec 50 ] .
    op _=>_ : Bubble Bubble -> NuITP-Rl [ ctor prec 50 ] .
endfm

fmod NuITP-SYNTAX-CONJUNCTION is
    pr QID-LIST .

    sorts NuITP-Eq NuITP-Rl NuITP-Conjunction Bubble .
    subsort NuITP-Eq NuITP-Rl < NuITP-Conjunction .

    op bubble : QidList -> Bubble [ special (id-hook Bubble (1 -1 `( `)) op-hook qidListSymbol (__ : QidList QidList ~> QidList) op-hook qidSymbol (<Qids> : ~> Qid) id-hook Exclude ( /\ = )) ] .

    op _/\_ : NuITP-Conjunction NuITP-Conjunction -> NuITP-Conjunction [ ctor assoc prec 60 ] .
    op _/\_ : NuITP-Eq NuITP-Conjunction -> NuITP-Conjunction [ ctor assoc prec 60 ] .
    op _/\_ : NuITP-Eq NuITP-Eq -> NuITP-Conjunction [ ctor assoc prec 60 ] .
    op _=_ : Bubble Bubble -> NuITP-Eq [ ctor prec 50 ] .
    op _=>_ : Bubble Bubble -> NuITP-Rl [ ctor prec 50 ] .
endfm

fmod NuITP-SYNTAX-SUBSTITUTION is
    pr QID-LIST .

    sorts Variable Term Assignment Substitution Substitution? Token Bubble .
    subsort Assignment < Substitution < Substitution? .

    op token : Qid -> Token [ special (id-hook Bubble (1 1) op-hook qidSymbol (<Qids> : ~> Qid)) ] .
    op bubble : QidList -> Bubble [ special (id-hook Bubble (1 -1 `( `)) op-hook qidListSymbol (__ : QidList QidList ~> QidList) op-hook qidSymbol (<Qids> : ~> Qid) id-hook Exclude ( <- ; )) ] .

    op _<-_ : Token Bubble -> Assignment [ ctor prec 63 ] .
    op none : -> Substitution [ ctor ] .
    op _;_ : Substitution Substitution -> Substitution [ ctor assoc comm id: none prec 65 gather(e E) ] .
endfm

fmod NuITP-PARSE is
    pr NuITP-UTILS .

    var M : Module .
    var N : Nat .
    var Q : Qid .
    var QL : QidList .
    var NQL : NeQidList .
    vars T T' GAMMA DELTA LHS RHS : Term .
    var V : Variable .
    vars TS : TermSet .
    var NTS : NeTermSet .
    var NTL : NeTermList .
    var TY : Type .
    var GCS : GenSetCollectionSet .

    op downQidTermList : TermList -> QidList .
    eq downQidTermList(empty) = nil .
    eq downQidTermList(Q) = downTerm(Q, nil) .
    eq downQidTermList('__[NTL]) = downQidTermList(NTL) .
    eq downQidTermList((Q,NTL)) = downQidTermList(Q) downQidTermList(NTL) .

    op parseTerm : Module QidList -> [Term] .
    eq parseTerm(M, QL) = getTerm(metaNormalize(M, getTerm(metaParse(M, none, QL, anyType)))) .

    op parseVariables : Module QidList TermSet -> [TermList] .
    eq parseVariables(M, nil, TS) = empty .
    ceq parseVariables(M, Q QL, TS) = V , parseVariables(M, QL, TS)
        if V := getTerm(metaNormalize(M, getTerm(metaParse(M, none, Q, anyType)))) .
    ceq parseVariables(M, Q QL, V ;; TS) = qid(string(Q) + ":" + string(getType(V))) , parseVariables(M, QL, TS)
        if Q == getName(V) [ owise ] .

    op parseClause : Module QidList -> [Term] .
    ceq parseClause(M, QL) = getTerm(metaNormalize(M, '_->_[GAMMA, DELTA]))
        if '_->_[GAMMA,DELTA] := getTerm(metaParse(M, none, QL, 'NuITP-Clause)) .
    ceq parseClause(M, QL) = getTerm(metaNormalize(M, '_->_['true.NuITP-Bool, getTerm(metaParse(M, none, QL, 'NuITP-Clause))]))
        if getTerm(metaParse(M, none, QL, anyType)) :: Term .

    op parseEquality : Module QidList -> [Term] .
    ceq parseEquality(M, QL) = getTerm(metaParse(M, none, QL, 'NuITP-Clause))
        if '_->_[GAMMA,'_=>_[LHS,RHS]] := getTerm(metaParse(M, none, QL, 'NuITP-Clause)) .
    ceq parseEquality(M, QL) = getTerm(metaParse(M, none, QL, 'NuITP-Rl))
        if '_=>_[LHS,RHS] := getTerm(metaParse(M, none, QL, 'NuITP-Rl)) .

    op parseGenSets : Module GenSetCollectionSet TermList QidList -> [GenSetList] .
    eq parseGenSets(M, GCS, empty, QL) = nil .
    ceq parseGenSets(M, GCS, V, Q) = [ getType(V) :: NTS ] 
        if NTS := getGenSet(GCS, getType(V), string(Q)) .
    ceq parseGenSets(M, GCS, V, QL) = [ getType(V) :: NTS ] 
        if NTS := parseGenSet(M, getType(V), QL) [ owise ] .
    eq parseGenSets(M, GCS, (V,NTL), Q QL) = parseGenSets'(M, GCS, (V,NTL), Q QL) .
    
    op parseGenSets' : Module GenSetCollectionSet TermList QidList -> [GenSetList] .
    ceq parseGenSets'(M, GCS, V, Q) = [ getType(V) :: NTS ]
        if NTS := getGenSet(GCS, getType(V), string(Q)) .
    ceq parseGenSets'(M, GCS, (V, NTL), (Q NQL)) = [ getType(V) :: NTS ] parseGenSets'(M, GCS, NTL, NQL)
        if NTS := getGenSet(GCS, getType(V), string(Q)) .
    
    op parseGenSet : Module Type QidList -> [TermSet] .
    eq parseGenSet(M, TY, nil) = mt .
    eq parseGenSet(M, TY, NQL) =
        if (getTerm(metaParse(omega(M), none, NQL, anyType)) :: Term) and-then sortLeq(M, getType(metaParse(omega(M), none, NQL, anyType)), TY)
        then getTerm(metaParse(omega(M), none, NQL, anyType))
        else parseGenSet'(M, TY, metaParse(upModule('NuITP-SYNTAX-GENSET, false), none, NQL, anyType))
        fi .

    op parseGenSet' : Module Type ResultPair? -> [TermSet] .
    eq parseGenSet'(M, TY, { T , 'TermSet }) = parseGenSet''(M, TY, T) .
    eq parseGenSet'(M, TY, ambiguity({ T , 'TermSet },{ T' , 'TermSet})) = parseGenSet''(M, TY, T) .

    op parseGenSet'' : Module Type Term -> [TermSet] .
    eq parseGenSet''(M, TY, '_;;_[T,T']) = parseGenSet''(M, TY, T) ;; parseGenSet''(M, TY, T').
    eq parseGenSet''(M, TY, 'bubble['__[NTL]]) = parseGenSet(M, TY, downQidTermList(NTL)) .
    ceq parseGenSet''(M, TY, 'bubble[T]) = getTerm(metaParse(omega(M), downQidTermList(T), anyType))
        if sortLeq(M, getType(metaParse(omega(M), downQidTermList(T), anyType)), TY) [ owise ] .

    op parseDisjunction : Module QidList -> [Term] .
    eq parseDisjunction(M, QL) = getTerm(metaNormalize(M, parseDisjunction'(M, metaParse(upModule('NuITP-SYNTAX-DISJUNCTION, false), none, QL, anyType)))) .

    op parseDisjunction' : Module ResultPair? -> [Term] .
    eq parseDisjunction'(M, { T , 'NuITP-Disjunction }) = parseDisjunction''(M, T) .
    eq parseDisjunction'(M, { T , 'NuITP-Eq }) = parseDisjunction''(M, T) .
    eq parseDisjunction'(M, { T , 'NuITP-Rl }) = parseDisjunction''(M, T) .
    eq parseDisjunction'(M, ambiguity({ T, 'NuITP-Disjunction }, { T', 'NuITP-Disjunction })) = parseDisjunction''(M, T') .
    eq parseDisjunction'(M, ambiguity({ T, 'NuITP-Disjunction }, { T', Q })) = parseDisjunction''(M, T) [ owise ] .

    op parseDisjunction'' : Module Term -> [Term] .
    eq parseDisjunction''(M, '_\/_[T,T']) = '_\/_[parseDisjunction''(M, T),parseDisjunction''(M, T')] .
    eq parseDisjunction''(M, '_=_[T,T']) = '_=_[parseDisjunction''(M, T),parseDisjunction''(M, T')] .
    eq parseDisjunction''(M, '_=>_[T,T']) = '_=>_[parseDisjunction''(M, T),parseDisjunction''(M, T')] .
    eq parseDisjunction''(M, 'bubble['__[NTL]]) = getTerm(metaParse(M, downQidTermList(NTL), anyType)) .
    eq parseDisjunction''(M, 'bubble[T]) = getTerm(metaParse(M, downQidTermList(T), anyType)) [ owise ] .

    op parseConjunction : Module QidList -> [Term] .
    eq parseConjunction(M, QL) = getTerm(metaNormalize(M, parseConjunction'(M, metaParse(upModule('NuITP-SYNTAX-CONJUNCTION, false), none, QL, anyType)))) .

    op parseConjunction' : Module ResultPair? -> [Term] .
    eq parseConjunction'(M, { T , 'NuITP-Conjunction }) = parseConjunction''(M, T) .
    eq parseConjunction'(M, { T , 'NuITP-Eq }) = parseConjunction''(M, T) .
    eq parseConjunction'(M, { T , 'NuITP-Rl }) = parseConjunction''(M, T) .
    eq parseConjunction'(M, ambiguity({ T, 'NuITP-Conjunction }, { T', 'NuITP-Conjunction })) = parseConjunction''(M, T') .
    eq parseConjunction'(M, ambiguity({ T, 'NuITP-Conjunction }, { T', Q })) = parseConjunction''(M, T) [ owise ] .

    op parseConjunction'' : Module Term -> [Term] .
    eq parseConjunction''(M, '_/\_[T,T']) = '_/\_[parseConjunction''(M, T),parseConjunction''(M, T')] .
    eq parseConjunction''(M, '_=_[T,T']) = '_=_[parseConjunction''(M, T),parseConjunction''(M, T')] .
    eq parseConjunction''(M, '_=>_[T,T']) = '_=>_[parseConjunction''(M, T),parseConjunction''(M, T')] .
    eq parseConjunction''(M, 'bubble['__[NTL]]) = getTerm(metaParse(M, downQidTermList(NTL), anyType)) .
    eq parseConjunction''(M, 'bubble[T]) = getTerm(metaParse(M, downQidTermList(T), anyType)) [ owise ] .

    op parseSubstitution : Module QidList -> [Substitution] .
    eq parseSubstitution(M, nil) = none .
    eq parseSubstitution(M, QL) = parseSubstitution'(M, metaParse(upModule('NuITP-SYNTAX-SUBSTITUTION,false), none, QL, anyType)) .

    op parseSubstitution' : Module ResultPair? -> [Substitution] .
    eq parseSubstitution'(M, ambiguity({ T , 'Assignment},{ T' , 'Substitution })) = parseSubstitution''(M, getTerm(metaNormalize(upModule('NuITP-SYNTAX-SUBSTITUTION,false),T'))) .
    eq parseSubstitution'(M, { T , 'Assignment }) = parseSubstitution''(M, getTerm(metaNormalize(upModule('NuITP-SYNTAX-SUBSTITUTION,false),T))) .
    eq parseSubstitution'(M, { T , 'Substitution }) = parseSubstitution''(M, getTerm(metaNormalize(upModule('NuITP-SYNTAX-SUBSTITUTION,false),T))) .

    op parseSubstitution'' : Module NeTermList -> [Substitution] .
    eq parseSubstitution''(M, 'none.Substitution) = none .
    eq parseSubstitution''(M, '_<-_['token[Q],'bubble['__[NTL]]]) = downTerm(Q, nil) <- getTerm(metaParse(M, downQidTermList(NTL), anyType)) .
    eq parseSubstitution''(M, '_<-_['token[Q],'bubble[T]]) = downTerm(Q, nil) <- getTerm(metaParse(M, downQidTermList(T), anyType)) [ owise ] .
    eq parseSubstitution''(M, '_;_[NTL]) = parseSubstitution''(M, NTL) .
    eq parseSubstitution''(M, (T,NTL)) = parseSubstitution''(M, T) ; parseSubstitution''(M, NTL) .
endfm

fmod NuITP-SYNTAX is
    pr QID-LIST .

    sorts Token Bubble NuITP-Command .

    op token : Qid -> Token [ special (id-hook Bubble (1 1) op-hook qidSymbol (<Qids> : ~> Qid)) ] .
    op bubble : QidList -> Bubble [ special (id-hook Bubble (1 -1 `( `)) op-hook qidListSymbol (__ : QidList QidList ~> QidList) op-hook qidSymbol (<Qids> : ~> Qid) id-hook Exclude (.)) ] .

    op q : -> NuITP-Command .
    op quit : -> NuITP-Command .
    op help : -> NuITP-Command .
    op help`general : -> NuITP-Command .
    op help`simplification  : -> NuITP-Command .
    op help`induction  : -> NuITP-Command .
    op help`internalize  : -> NuITP-Command .

    op clear`. : -> NuITP-Command .
    op clear`all`. : -> NuITP-Command .
    
    op load_ : Token -> NuITP-Command .
    op save_ : Token -> NuITP-Command .
    op snap_ : Token -> NuITP-Command .
    op tex_ : Token -> NuITP-Command .
    op html_ : Token -> NuITP-Command .
    
    op show`log`. : -> NuITP-Command .
    op show`session`log`. : -> NuITP-Command .
    op show`module`. : -> NuITP-Command .
    op show`local`module`. : -> NuITP-Command .
    op show`extended`module`. : -> NuITP-Command .
    op show`internal`module`. : -> NuITP-Command .
    op show`predicates`. : -> NuITP-Command .
    op show`internal`predicates`. : -> NuITP-Command .
    op show`internal`. : -> NuITP-Command .
    op show`frontier`. : -> NuITP-Command .
    op show`goals`. : -> NuITP-Command .
    op show`goal_. : Token -> NuITP-Command .
    op show`stats`. : -> NuITP-Command .
    op show`gensets`. : -> NuITP-Command .
    op show`gensets`for_. : Token -> NuITP-Command .
    op show`genset_. : Token -> NuITP-Command .
    op show`strats`. : -> NuITP-Command .

    op set`module_. : Token -> NuITP-Command .
    op set`goal_. : Bubble -> NuITP-Command .
    op set`verbose`on`. : -> NuITP-Command .
    op set`verbose`off`. : -> NuITP-Command .
    op set`local`internalize`on`. : -> NuITP-Command .
    op set`local`internalize`off`. : -> NuITP-Command .
    op set`default`genset_. : Token -> NuITP-Command .
    op set`default`strat_. : Token -> NuITP-Command .

    op apply_to_. : Bubble Token -> NuITP-Command .                                      --- Others
    op apply_to_with_. : Bubble Token Bubble -> NuITP-Command .                          --- EQ, LE
    op apply_to_with_sub_. : Bubble Token Bubble Bubble -> NuITP-Command .               --- EQ, SP
    op apply_to_with`reversed_. : Bubble Token Token -> NuITP-Command .                  --- EQ
    op apply_to_with`reversed_sub_. : Bubble Token Token Bubble -> NuITP-Command .       --- EQ
    op apply_to_on_. : Bubble Token Bubble -> NuITP-Command .                            --- NI, VA
    op apply_to_on_with_. : Bubble Token Bubble Bubble -> NuITP-Command .                --- GSI, CAS

    op simplify_. : Token -> NuITP-Command .
    op simplify_using_. : Token Token -> NuITP-Command .

    op genset_for_is_. : Token Token Bubble -> NuITP-Command .
    op strat_is_. : Token Bubble -> NuITP-Command .
    
    op internalize_. : Token -> NuITP-Command .
    op internalize`. : -> NuITP-Command .
    op internalize`all`. : -> NuITP-Command .
    op force`internalize`. : -> NuITP-Command .
    op force`internalize`all`. : -> NuITP-Command .

    op internalize`as`assoc`. : -> NuITP-Command .
    op internalize`as`comm`. : -> NuITP-Command .
    op force`internalize`as`assoc`. : -> NuITP-Command .
    op force`internalize`as`comm`. : -> NuITP-Command .

    op check`rpo`. : -> NuITP-Command .
    op undo_. : Token -> NuITP-Command .

    op assert`. : -> NuITP-Command .
    op assert_. : Token -> NuITP-Command .
endfm

mod NuITP is
    pr FILE .
    pr STD-STREAM .
    pr TIME .
    pr NuITP-STATS .
    pr NuITP-REPORT-TEX .
    pr NuITP-REPORT-HTML .
    pr NuITP-PARSE .
    pr NuITP-INTERNALIZATION .
    pr NuITP-STRATEGY-UTILS .
    pr NuITP-ERROR .

    sorts IOMode IOModeList .
    subsort IOMode < IOModeList .

    op nil : -> IOModeList [ ctor ] .
    op __ : IOModeList IOModeList -> IOModeList [ assoc id: nil ] .
    
    op NuITP : -> Cid [ ctor ] .
    op console : -> Oid [ ctor ] .

    op verbose:_ : Bool -> Attribute [ ctor prec 20 gather (&) ] .
    op local:_ : Bool -> Attribute [ ctor prec 20 gather (&) ] .
    op wild:_ : Bool -> Attribute [ ctor prec 20 gather (&) ] .
    op log:_ : Log -> Attribute [ ctor prec 20 gather (&) ] .
    op session:_ : String -> Attribute [ ctor prec 20 gather (&) ] .
    
    op modname:_ : Qid -> Attribute [ ctor prec 20 gather (&) ] .
    op internal:_ : Internal -> Attribute [ ctor prec 20 gather (&) ] .
    op strats:_ : SimpStratList -> Attribute [ ctor prec 20 gather (&) ] .
    op gensets:_ : GenSetCollectionSet -> Attribute [ ctor prec 20 gather (&) ] .
    op goals:_ : GoalSet -> Attribute [ ctor prec 20 gather (&) ] .
    
    op io:_ : IOModeList -> Attribute [ ctor prec 20 gather (&) ] .
    op closing : -> IOMode [ ctor ] .
    op try : QidList String -> IOMode [ ctor ] .
    op try : Qid String Oid -> IOMode [ ctor ] .
    op load-script : String Oid String Bool -> IOMode [ ctor ] .
    op load-script : String Oid Nat Bool -> IOMode [ ctor ] .
    op load-snap : String Oid -> IOMode [ ctor ] .
    op load-snap : String Oid String -> IOMode [ ctor ] .
    op save-script : -> IOMode [ ctor ] .
    op save-script : Oid -> IOMode [ ctor ] .
    op save-snap : -> IOMode [ ctor ] .
    op save-snap : Oid -> IOMode [ ctor ] .
    op save-tex : -> IOMode [ ctor ] .
    op save-tex : Oid -> IOMode [ ctor ] .
    op save-html : -> IOMode [ ctor ] .
    op save-html : Oid -> IOMode [ ctor ] .
    
    op parse : String Term -> Msg [ ctor ] .

    vars M M' SKO-MODULE INTMOD : Module .
    vars ATS ATS' : AttributeSet .
    vars Q Q' MODNAME RULE RID CMD LABEL : Qid .
    vars GID QL QL' STRAT TRYMODE : QidList .
    var IO : IOMode .
    vars IOL IOL' : IOModeList .
    var NQL : NeQidList .
    var ERROR : Error .
    vars STR SESSION FILENAME : String .
    vars T T1 T2 CLA TGID GOAL GAMMA DELTA EQUALITY LEMMA DISJ SUB NAWEX TERM VAR GENSET STATE ARG ARG1 ARG2 : Term .
    vars TL TL' GEN ARGS : TermList .
    vars GOALS GOALS' GOALS'' : GoalSet .
    var NTL RULES? : NeTermList .
    vars N VC N1 N2 TIME TIME' : Nat .
    vars NZ NZ1 NZ2 : NzNat .
    var LINE : Line .
    var LOG : Log .
    var TY : Type .
    var SS : SortSet .
    vars B FRO SFRO VERBOSE WILD INTER INTER' LOCAL : Bool .
    vars SKO HPS SAVED-GENSET INTHPS INTLOCAL : TermSet .
    vars FH FH' OID OID' : Oid .
    var CONF : Configuration .
    vars SB SB' : Substitution .
    var GENSETS : GenSetCollectionSet .
    vars PARSED-VAR PARSED-GOAL PARSED-EQUALITY PARSED-LEMMA PARSED-DISJ PARSED-CONJ PARSED-TERM : [Term] .
    var SVAR : Variable .
    var PARSED-VARS : [TermList] .
    var PARSED-GENSET : [TermSet] .
    var PARSED-GENSETS : [GenSetList] .
    var PARSED-SUB : [Substitution] .
    var SSL : SimpStratList .
    var STA : Strategy .

    op init-configuration : -> Configuration .
    eq init-configuration = < console : NuITP | 
            io: nil, 
            verbose: true,
            wild: false,
            local: false,
            log: nil,
            session: "",
            modname: 'noModule,
            internal: upModule('BOOL,false) | mt | mt,
            strats: [ "NuITP" : NuITPDefaultStrategy ],
            gensets: mt, 
            goals: mt
        > .
    
    op init : -> Configuration .
    eq init = <> init-configuration write(stdout, console, NuITP-BANNER) .

    --- quit
    eq < OID : NuITP | ATS > parse(STR, 'q.NuITP-Command) = (none).Configuration write(stdout, OID, printCommand(ATS, STR) + WHITE + "  Bye." + BW + "\n\n") .
    eq < OID : NuITP | ATS > parse(STR, 'quit.NuITP-Command) = (none).Configuration write(stdout, OID, printCommand(ATS, STR) + WHITE + "  Bye." + BW + "\n\n") .

    --- user interaction
    rl < OID : NuITP | ATS, io: closing > wrote(OID, stdout) closedFile(OID, FH) => < OID : NuITP | ATS, io: nil > getLine(stdin, OID, "NuITP> ") .
    rl < OID : NuITP | ATS, io: nil > wrote(OID, stdout) => < OID : NuITP | ATS, io: nil > getLine(stdin, OID, "NuITP> ") .
    rl < OID : NuITP | ATS, io: nil > gotLine(OID, stdin, STR) => < OID : NuITP | ATS, io: nil > parse(trim(STR), disambiguate(getTerm(metaParse(upModule('NuITP-SYNTAX,false), none, tokenize(trim(STR)), 'NuITP-Command)))) .
    
    --- script interaction
    eq < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, false) > wrote(OID, stdout) gotTimeSinceEpoch(OID, OID', TIME') = < OID : NuITP | ATS, io: IOL closing > closeFile(FH, OID) write(stdout, OID, YELLOW + "  End running script " + FILENAME + " after " + toStringTime((TIME' + - TIME)) + ".\n\n" + BW) .
    eq < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, false) > gotTimeSinceEpoch(OID, OID', TIME') = < OID : NuITP | ATS, io: IOL closing > closeFile(FH, OID) write(stdout, OID, YELLOW + "  End running script " + FILENAME + " after " + toStringTime((TIME' + - TIME)) + ".\n\n" + BW) [ owise ] .
    rl < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) > wrote(OID, stdout) => < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) > getLine(FH, OID) .
    
    rl < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, STR, true) > wrote(OID, stdout) gotTimeSinceEpoch(OID, OID', TIME) =>
        if (STR == "") or-else startsWith(trim(STR), "eof")
        then < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, false) > getTimeSinceEpoch(timeManager, OID)
        else < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) >
            if (trim(STR) == "") or-else startsWith(trim(STR), "#")
            then getLine(FH, OID)
            else parse(trim(STR), disambiguate(getTerm(metaParse(upModule('NuITP-SYNTAX,false), none, tokenize(trim(STR)), 'NuITP-Command))))
            fi
        fi .
    rl < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) > gotLine(OID, FH, STR) =>
        if (STR == "") or-else startsWith(trim(STR), "eof")
        then < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, false)> getTimeSinceEpoch(timeManager, OID)
        else < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) >
            if (trim(STR) == "") or-else startsWith(trim(STR), "#")
            then getLine(FH, OID)
            else parse(trim(STR), disambiguate(getTerm(metaParse(upModule('NuITP-SYNTAX,false), none, tokenize(trim(STR)), 'NuITP-Command))))
            fi
        fi .
    
    rl < OID : NuITP | ATS, io: IOL load-snap(FILENAME, FH, STR) > wrote(OID, stdout) =>
        if (STR == "") or-else startsWith(trim(STR), "eof")
        then < OID : NuITP | ATS, io: IOL closing > closeFile(FH, OID)
        else 
            if (trim(STR) == "") or-else startsWith(trim(STR), "#")
            then < OID : NuITP | ATS, io: IOL load-snap(FILENAME, FH) > getLine(FH, OID)
            else
                if (downTerm(disambiguate(getTerm(metaParse(upModule('NuITP, false), none, tokenize(STR), 'Configuration))), (none).Configuration) == none)
                then < OID : NuITP | ATS, io: IOL closing > write(stdout, OID, RED + "\n  NuITP snapshot error." + BW + "\n\n")
                else (downTerm(disambiguate(getTerm(metaParse(upModule('NuITP, false), none, tokenize(STR), 'Configuration))), (none).Configuration) write(stdout, OID, CYAN + "  NuITP snapshot successfully loaded." + BW + "\n\n"))
                fi 
                closeFile(FH, OID)
            fi
        fi .
    rl < OID : NuITP | ATS, io: IOL load-snap(FILENAME, FH) > gotLine(OID, FH, STR) =>
        if (STR == "") or-else startsWith(trim(STR), "eof")
        then < OID : NuITP | ATS, io: IOL closing > closeFile(FH, OID)
        else 
            if (trim(STR) == "") or-else startsWith(trim(STR), "#")
            then < OID : NuITP | ATS, io: IOL load-snap(FILENAME, FH) > getLine(FH, OID)
            else
                if (downTerm(disambiguate(getTerm(metaParse(upModule('NuITP, false), none, tokenize(STR), 'Configuration))), (none).Configuration) == none)
                then < OID : NuITP | ATS, io: IOL closing > write(stdout, OID, RED + "\n  NuITP snapshot error." + BW + "\n\n")
                else (downTerm(disambiguate(getTerm(metaParse(upModule('NuITP, false), none, tokenize(STR), 'Configuration))), (none).Configuration) write(stdout, OID, CYAN + "  NuITP snapshot successfully loaded." + BW + "\n\n"))
                fi 
                closeFile(FH, OID)
            fi
        fi .

    op disambiguate : Term -> Term .
    eq disambiguate(getTerm(ambiguity({'apply_to_on_.[TL],'NuITP-Command}, {'apply_to_on_with_.[TL'],'NuITP-Command}))) = 'apply_to_on_with_.[TL'] .
    eq disambiguate(getTerm(ambiguity({'apply_to_with_.[TL],'NuITP-Command}, {'apply_to_with_sub_.[TL'],'NuITP-Command}))) = 'apply_to_with_sub_.[TL'] .
    eq disambiguate(getTerm(ambiguity({'apply_to_on_.[TL],'NuITP-Command}, {'apply_to_on_with_.[TL'],'NuITP-Command}))) = 'apply_to_on_with_.[TL'] .
    eq disambiguate(getTerm(ambiguity({'internalize`all`..NuITP-Command,'NuITP-Command}, {'internalize_.['token[''all.Qid]],'NuITP-Command}))) = 'internalize`all`..NuITP-Command .
    eq disambiguate(getTerm(ambiguity({'apply_to_with`reversed_.[TL], 'NuITP-Command}, {'apply_to_with_.[TL'], 'NuITP-Command}))) = 'apply_to_with`reversed_.[TL] .
    eq disambiguate(getTerm(ambiguity({'apply_to_with_.[TL], 'NuITP-Command}, {'apply_to_with`reversed_.[TL'], 'NuITP-Command}))) = 'apply_to_with`reversed_.[TL'] .
    eq disambiguate(getTerm(ambiguity({'apply_to_with_.[TL], 'NuITP-Command}, {'apply_to_with`reversed_sub_.[TL'], 'NuITP-Command}))) = 'apply_to_with`reversed_sub_.[TL'] .
    eq disambiguate(T:[Term]) = T:[Term] [ owise ] .

   --- parsing errors
    eq < OID : NuITP | ATS, io: nil > parse(STR, getTerm(noParse(N))) = < OID : NuITP | ATS, io: nil > write(stdout, OID, "\n" + RED + "  Error parsing command." + BW + "\n\n") .
    eq < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) > parse(STR, getTerm(noParse(N))) = < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, false) > write(stdout, OID, printCommand(ATS, STR) + RED + "  Error parsing command." + BW + "\n\n") getTimeSinceEpoch(timeManager, OID) .
    rl < OID : NuITP | ATS, io: IO closing > closedFile(OID, FH) => < OID : NuITP | ATS, io: IO > .
    
    --- load (both)
    rl < OID : NuITP | ATS, io: IOL > parse(STR, 'load_['token[T]]) => < OID : NuITP | ATS, io: IOL try('script, trim(string(downTerm(T,'noFileName.Qid)))) > openFile(fileManager, OID, trim(string(downTerm(T,'noFileName.Qid))), "r") .
    rl < OID : NuITP | ATS, io: IOL try(TRYMODE, FILENAME) > openedFile(OID, fileManager, FH) => < OID : NuITP | ATS, io: IOL try(TRYMODE, FILENAME, FH) > getLine(FH, OID) .
    rl < OID : NuITP | ATS, io: IOL try(TRYMODE, FILENAME, FH) > gotLine(OID, FH, STR) => 
        if (find(STR, "NuITP snapshot", 0) =/= notFound)
        then < OID : NuITP | ATS, io: IOL load-snap(FILENAME, FH, STR) > write(stdout, OID, (if (IOL == nil) then "\n" else "" fi) + YELLOW + "  Loading NuITP snapshot...\n\n" + BW)
        else < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, STR, true) > write(stdout, OID, if (IOL == nil) then "\n" else "" fi + YELLOW + "  Begin running script " + FILENAME + ".\n\n" + BW) getTimeSinceEpoch(timeManager, OID)
        fi .
    
    --- save script
    rl < OID : NuITP | ATS, io: IOL > parse(STR, 'save_['token[T]]) => < OID : NuITP | ATS, io: IOL save-script > openFile(fileManager, OID, getFileName(string(downTerm(T,'noFileName.Qid)), "nuitp"), "w") .
    rl < OID : NuITP | ATS, io: IOL save-script, log: LOG > openedFile(OID, fileManager, FH) => < OID : NuITP | ATS, io: IOL save-script(FH), log: LOG > write(FH, OID, "# NuITP proof script (" + NuITP-VERSION + ")\n\n" + toStringMin(LOG)) .
    rl < OID : NuITP | ATS, io: IOL save-script(FH) > wrote(OID, FH) => < OID : NuITP | ATS, io: IOL closing > write(stdout, OID, CYAN + "\n  Proof script successfully saved.\n\n" + BW) closeFile(FH, OID) .

    --- save snapshot
    rl < OID : NuITP | ATS, io: IOL > parse(STR, 'snap_['token[T]]) => < OID : NuITP | ATS, io: IOL save-snap > openFile(fileManager, OID, getFileName(string(downTerm(T,'noFileName.Qid)), "snap"), "w") .
    rl < OID : NuITP | ATS, io: IOL save-snap > openedFile(OID, fileManager, FH) => < OID : NuITP | ATS, io: IOL save-snap(FH) > write(FH, OID, "# NuITP snapshot (" + NuITP-VERSION + ")\n\n" + metaPrintToString(upModule('NuITP, false), none, upTerm(< OID : NuITP | ATS, io: closing >), with-parens, none)) .
    rl < OID : NuITP | ATS, io: IOL save-snap(FH) > wrote(OID, FH) => < OID : NuITP | ATS, io: IOL closing > write(stdout, OID, CYAN + "\n  NuITP snapshot successfully saved.\n\n" + BW) closeFile(FH, OID) .

    --- save report (tex)
    rl < OID : NuITP | ATS, io: IOL, goals: GOALS > parse(STR, 'tex_['token[T]]) =>
        if (getGoal(GOALS, '0) :: Goal)
        then < OID : NuITP | ATS, io: IOL save-tex, goals: GOALS > openFile(fileManager, OID, getFileName(string(downTerm(T,'noFileName.Qid)), "tex"), "w")
        else < OID : NuITP | ATS, io: IOL, goals: GOALS > write(stdout, OID, printCommand(io: IOL, STR) + RED + "  No session started.\n\n" + BW)
        fi .
    rl < OID : NuITP | ATS, io: IOL save-tex, modname: MODNAME, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS > openedFile(OID, fileManager, FH) => < OID : NuITP | ATS, io: IOL save-tex(FH), modname: MODNAME, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS > write(FH, OID, getTeXReport(MODNAME, INTMOD, LOG, GENSETS, GOALS) + "\n") .
    rl < OID : NuITP | ATS, io: IOL save-tex(FH) > wrote(OID, FH) => < OID : NuITP | ATS, io: IOL closing > write(stdout, OID, (if (IOL == nil) then "\n" else "" fi) + CYAN + "  LaTeX report successfully generated." + BW + "\n\n") closeFile(FH, OID) .

    --- save report (html)
    rl < OID : NuITP | ATS, io: IOL, goals: GOALS > parse(STR, 'html_['token[T]]) =>
        if (getGoal(GOALS, '0) :: Goal)
        then < OID : NuITP | ATS, io: IOL save-html, goals: GOALS > openFile(fileManager, OID, getFileName(string(downTerm(T,'noFileName.Qid)), "html"), "w")
        else < OID : NuITP | ATS, io: IOL, goals: GOALS > write(stdout, OID, printCommand(io: IOL, STR) + RED + "  No session started." + BW + "\n\n")
        fi .
    rl < OID : NuITP | ATS, io: IOL save-html, modname: MODNAME, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS > openedFile(OID, fileManager, FH) => < OID : NuITP | ATS, io: IOL save-html(FH), modname: MODNAME, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS > write(FH, OID, getHTMLReport(MODNAME, INTMOD, LOG, GENSETS, GOALS) + "\n") .
    rl < OID : NuITP | ATS, io: IOL save-html(FH) > wrote(OID, FH) => < OID : NuITP | ATS, io: IOL closing > write(stdout, OID, (if (IOL == nil) then "\n" else "" fi) + CYAN + "  HTML report successfully generated." + BW + "\n\n") closeFile(FH, OID) .

    --- I/O error handler
    op isTrying : IOMode -> Bool .
    eq isTrying(try(TRYMODE, FILENAME)) = true .
    eq isTrying(try(TRYMODE, FILENAME, FH)) = true .
    eq isTrying(IO) = false [ owise ] .
    
    crl < OID : NuITP | ATS, io: IOL IO > fileError(OID, FH, STR) =>
        if (STR == "File operations disabled.") 
        then < OID : NuITP | ATS, io: IOL > write(stdout, OID, "\n" + RED + "  " + STR + " Use the -allow-files or -trust flags when starting Maude to enable them." + BW + "\n\n")
        else < OID : NuITP | ATS, io: IOL > write(stdout, OID, "\n" + RED + "  " + STR + BW + "\n\n") 
        fi 
        if not(isTrying(IO)) .

    rl < OID : NuITP | ATS, io: IOL try(TRYMODE, FILENAME) > fileError(OID, FH, STR) =>
        if (STR == "No such file or directory") and-then (TRYMODE =/= nil)
        then 
            if (TRYMODE == 'script)
            then < OID : NuITP | ATS, io: IOL try('snap, FILENAME) > openFile(fileManager, OID, getFileName(FILENAME, "nuitp"), "r")
            else 
                if (TRYMODE == 'snap)
                then < OID : NuITP | ATS, io: IOL try(nil, FILENAME) > openFile(fileManager, OID, getFileName(FILENAME, "snap"), "r") 
                else < OID : NuITP | ATS, io: IOL > write(stdout, OID, "\n" + RED + "  " + STR + BW + "\n\n")
                fi
            fi
        else < OID : NuITP | ATS, io: IOL > write(stdout, OID, "\n" + RED + "  " + STR + BW + "\n\n")
        fi .
    
    --- Help
    eq < OID : NuITP | ATS > parse(STR, 'help.NuITP-Command) = < OID : NuITP | ATS > write(stdout, OID, help-message) .
    eq < OID : NuITP | ATS > parse(STR, 'help`general.NuITP-Command) = < OID : NuITP | ATS > write(stdout, OID, "\n" + help-general + "\n") .
    eq < OID : NuITP | ATS > parse(STR, 'help`simplification.NuITP-Command) = < OID : NuITP | ATS > write(stdout, OID, "\n" + help-simplification + "\n") .
    eq < OID : NuITP | ATS > parse(STR, 'help`induction.NuITP-Command) = < OID : NuITP | ATS > write(stdout, OID, "\n" + help-induction + "\n") .
    eq < OID : NuITP | ATS > parse(STR, 'help`internalize.NuITP-Command) = < OID : NuITP | ATS > write(stdout, OID, "\n" + help-internalize + "\n") .

    op help-message : -> String .
    eq help-message = "\n" + help-general + "\n" + help-simplification + "\n" + help-induction + "\n" + help-internalize + "\n" .

    op help-general : -> String .
    eq help-general = GREEN + "  General commands:" + BW + "\n\n"
        + "    " + CYAN + "q" + BW + " or " + CYAN + "quit" + BW + ": quits NuITP.\n"
        + "    " + CYAN + "help" + BW + ": shows all the help sections.\n"
        + "    " + CYAN + "help general" + BW + ": shows the general commands help section.\n"
        + "    " + CYAN + "help simplification" + BW + ": shows the simplification commands help section.\n"
        + "    " + CYAN + "help induction" + BW + ": shows the induction commands help section.\n"
        + "    " + CYAN + "help internalize" + BW + ": shows the internalization commands help section.\n"
        + "\n"
        + "    " + CYAN + "set verbose on ." + BW + ": shows outputs in detail (" + GREEN + "default" + BW + ").\n"
        + "    " + CYAN + "set verbose off ." + BW + ": shows outputs abbreviated.\n"
        + "    " + CYAN + "set local internalize on ." + BW + ": enables automated local internalization of goals.\n"
        + "    " + CYAN + "set local internalize off ." + BW + ": disables automated local internalization of goals (" + GREEN + "default" + BW + ").\n"
        + "\n"
        + "    " + CYAN + "show log ." + BW + ": shows the current proof log.\n"
        + "    " + CYAN + "show session log ." + BW + ": shows the entire NuITP session log.\n"
        + "    " + CYAN + "show module ." + BW + ": shows the active module.\n"
        + "    " + CYAN + "show local module ." + BW + ": shows the active module including locally internalized executable lemmas.\n"
        + "    " + CYAN + "show extended module ." + BW + ": shows the active module extended with equality predicates.\n"
        + "    " + CYAN + "show internal module ." + BW + ": shows the active module including all internalized executable lemmas.\n"
        + "    " + CYAN + "show goal " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": shows the specified goal.\n"
        + "    " + CYAN + "show goals ." + BW + ": shows all goals.\n"
        + "    " + CYAN + "show frontier ." + BW + ": shows the goals in the frontier.\n"
        + "    " + CYAN + "show gensets ." + BW + ": shows all the defined generator sets.\n"
        + "    " + CYAN + "show gensets for " + WHITE + "<sort>" + CYAN + " ." + BW + ": shows the defined generator sets for the specified sort.\n"
        + "    " + CYAN + "show genset " + WHITE + "<genset_id>" + CYAN + " ." + BW + ": shows the specified generator set.\n"
        + "    " + CYAN + "show strats ." + BW + ": shows all the defined simplification strategies.\n"
        + "\n"
        + "    " + CYAN + "set module " + WHITE + "<module_name>" + CYAN + " ." + BW + ": sets the specified module as active module.\n"
        + "    " + CYAN + "set goal " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": sets the specified goal as active goal.\n"
        + "    " + CYAN + "genset " + WHITE + "<generator_id>" + CYAN + " for " + WHITE + "<sort>" + CYAN + " is " + WHITE + "<generator_set>" + CYAN + " ." + BW + ": adds a generator set or the specified sort.\n"
        + "    " + CYAN + "strat " + WHITE + "<strategy_id>" + CYAN + " is " + WHITE + "<strategy>" + CYAN + " ." + BW + ": adds the specified simplification strategy to NuITP.\n"
        + "    " + CYAN + "set default genset " + WHITE + "<generator_id>" + BW + ": sets the specified generator set as default for its sort.\n"
        + "    " + CYAN + "set default strat " + WHITE + "<strategy_id>" + BW + ": sets the specified strategy as default.\n"
        + "\n"
        + "    " + CYAN + "undo " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": undoes any previous rule application to the goal.\n"
        + "    " + CYAN + "clear ." + BW + ": clears the current proof tree, including rule applications and locally internalized lemmas.\n"
        + "    " + CYAN + "clear all ." + BW + ": resets the entire NuITP session.\n"
        + "\n"
        + "    " + CYAN + "load " + WHITE + "<file_name>" + BW + ": loads and runs the previously saved NuITP file (either a snapshot of a NuITP session or a proof script).\n"
        + "    " + CYAN + "save " + WHITE + "<file_name>" + BW + ": saves the current proof log into a script file.\n"
        + "    " + CYAN + "snap " + WHITE + "<file_name>" + BW + ": saves a snapshot of the current NuITP session to a given file .\n"
        + "    " + CYAN + "tex " + WHITE + "<file_name>" + BW + ": creates a LaTeX file with a summary of the current proof.\n" 
        + "    " + CYAN + "html " + WHITE + "<file_name>" + BW + ": creates a HTML5 file with a summary of the current proof.\n" 
        .

    op RULEOPS : -> String .
    eq RULEOPS = BW + "[" + CYAN + "!" + BW + "|" + CYAN + "*" + BW + "|" + CYAN + "{" + WHITE + "<strat>" + CYAN + "}" + BW + "]" + CYAN .

    op help-simplification : -> String .
    eq help-simplification = GREEN + "  Simplification commands:" + BW + "\n\n"
        + "    " + CYAN + "apply eps" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('eps) + "\n"
        + "    " + CYAN + "apply cvul" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('cvul) + "\n"
        + "    " + CYAN + "apply cvufr" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('cvufr) + "\n"
        + "    " + CYAN + "apply subl" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('subl) + "\n"
        + "    " + CYAN + "apply subr" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('subr) + "\n"
        + "    " + CYAN + "apply ns" + RULEOPS + " to " + WHITE + "<goal_id>" + BW + " [" + CYAN + "on " + WHITE + "<subterm>" + BW + "]" + CYAN + " ." + BW + ": " + getRuleMsg('ns) + "\n"
        + "    " + CYAN + "apply cs" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('cs) + "\n"
        + "    " + CYAN + "apply icc" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('icc) + "\n"
        + "    " + CYAN + "apply varsat" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('varsat) + "\n"
        + "    " + CYAN + "apply gnd" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('gnd) + "\n"
        + "    " + CYAN + "apply ufree" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('ufree) + "\n"
        + "    " + CYAN + "apply rst" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": " + getRuleMsg('rst) + "\n"
        + "    " + CYAN + "apply eq" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " with " + WHITE + "<oriented_equality>" + CYAN + " ." + BW + ": " + getRuleMsg('eq) + "\n"
        + "    " + CYAN + "apply eq" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " with " + WHITE + "<oriented_equality>" + CYAN + " sub " + WHITE + "<substitution>" + CYAN + " ." + BW + ": " + getRuleMsg('eq) + "\n"
        .
    
    op help-induction : -> String .
    eq help-induction = GREEN + "  Induction commands:" + BW + "\n\n"
        + "    " + CYAN + "apply gsi" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<variable>" + CYAN + " ." + BW + ": " + getRuleMsg('gsi) + "\n"
        + "    " + CYAN + "apply gsi" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<variable>" + CYAN + " with " + WHITE + "<generator_set_id>" + CYAN + " ." + BW + ": " + getRuleMsg('gsi) + "\n"
        + "    " + CYAN + "apply gsi" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<variable>" + CYAN + " with " + WHITE + "<explicit_generator_set>" + CYAN + " ." + BW + ": " + getRuleMsg('gsi) + "\n"
        + "    " + CYAN + "apply ni" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<subterm>" + CYAN + " ." + BW + ": " + getRuleMsg('ni) + "\n"
        + "    " + CYAN + "apply le" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " with " + WHITE + "<lemma>" + CYAN + " ." + BW + ": " + getRuleMsg('le) + "\n"
        + "    " + CYAN + "apply sp" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " with " + WHITE + "<disjunction>" + CYAN + " sub " + WHITE + "<substitution>" + CYAN + " ." + BW + ": " + getRuleMsg('sp) + "\n"
        + "    " + CYAN + "apply cas" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<variable>" + CYAN + " ." + BW + ": " + getRuleMsg('cas) + "\n"
        + "    " + CYAN + "apply cas" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<variable>" + CYAN + " with " + WHITE + "<generator_set_id>" + CYAN + " ." + BW + ": " + getRuleMsg('cas) + "\n"
        + "    " + CYAN + "apply cas" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<variable>" + CYAN + " with " + WHITE + "<explicit_generator_set>" + CYAN + " ." + BW + ": " + getRuleMsg('cas) + "\n"
        + "    " + CYAN + "apply va" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " on " + WHITE + "<subterm>" + CYAN + " ." + BW + ": " + getRuleMsg('va) + "\n"
        + "    " + CYAN + "apply cut" + RULEOPS + " to " + WHITE + "<goal_id>" + CYAN + " with " + WHITE + "<implication>" + CYAN + " ." + BW + ": " + getRuleMsg('cut) + "\n"
        .
    
    op help-internalize : -> String .
    eq help-internalize = GREEN + "  Internalization commands:" + BW + "\n\n"
        + "    " + CYAN + "internalize ." + BW + ": internalizes the initial goal of the current (proved) proof as a lemma.\n"
        + "    " + CYAN + "internalize all ." + BW + ": internalizes all the goals of the current (proved) proof as lemmas except for those with Skolem constants.\n"
        + "    " + CYAN + "internalize as assoc ." + BW + ": internalizes the initial goal of the current (proved) proof as the associativity axiom.\n"
        + "    " + CYAN + "internalize as comm ." + BW + ": internalizes the initial goal of the current (proved) proof as the commutativity axiom.\n"
        + "    " + CYAN + "internalize " + WHITE + "<goal_id>" + CYAN + " ." + BW + ": internalizes the specified goal in the current proof as a lemma. The goal needs to be proved (i.e., all its subgoals are proved).\n"
        .
        
    --- error handling
    op printErr : Configuration Error String Bool -> Configuration .
    eq printErr(< OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, true) >, ERROR, STR, true) = < OID : NuITP | ATS, io: IOL load-script(FILENAME, FH, TIME, false) > write(stdout, OID, (BW + "NuITP> " + YELLOW + STR + "\n\n") + RED + "  " + getMsg(ERROR) + BW + "\n\n") getTimeSinceEpoch(timeManager, OID) .
    eq printErr(< OID : NuITP | ATS, io: IOL IO >, ERROR, STR, false) = < OID : NuITP | ATS, io: IOL IO > write(stdout, OID, (BW + "NuITP> " + YELLOW + STR + "\n\n") + RED + "  " + getMsg(ERROR) + BW + "\n\n") .
    eq printErr(< OID : NuITP | ATS >, ERROR, STR, B) = < OID : NuITP | ATS > write(stdout, OID, "\n" + RED + "  " + getMsg(ERROR) + BW + "\n\n") [ owise ] .

    op printMsg : Oid Oid AttributeSet String  -> Configuration .
    eq printMsg(OID, OID', (ATS, io: nil), STR) = write(OID, OID', "\n" + CYAN + "  " + STR + BW + "\n\n") .
    eq printMsg(OID, OID', ATS, STR) = write(OID, OID', CYAN + "  " + STR + BW + "\n\n") [ owise ] .

    op printCommand : AttributeSet String -> String .
    eq printCommand((ATS, io: nil), STR) = "\n" .
    eq printCommand(ATS, STR) = BW + "NuITP> " + YELLOW + STR + "\n\n" [ owise ] .
    
    --- set module MODNAME .
    eq < OID : NuITP | ATS, wild: WILD, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, session: SESSION, log: LOG, gensets: GENSETS, goals: GOALS > parse(STR, 'set`module_.['token[T]]) =
        if upModule(downTerm(T, 'noModule.Qid),false) :: Module
        then
            < OID : NuITP | ATS, wild: false, modname: downTerm(T,'noModule.Qid), internal: extModule(downTerm(T,'noModule.Qid)) | mt | mt, session: SESSION + toString(LOG, true), log: [ nil : "set module " + string(downTerm(T,'noModule.Qid)) + " .\n" ], gensets: mt, goals: mt >
            printMsg(stdout, OID, ATS, "Module " + string(downTerm(T, 'noModule.Qid)) + " is now active.")
        else
            printErr(< OID : NuITP | ATS, wild: WILD, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, session: SESSION, log: LOG, gensets: GENSETS, goals: GOALS >, error(1, string(downTerm(T, 'noModule.Qid))), STR, true)
        fi .

    --- set goal GOAL .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'set`goal_.['bubble[TL]]) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, true) .
    eq < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, session: SESSION, log: LOG, goals: GOALS > parse(STR, 'set`goal_.['bubble[TL]]) =
        if parseClause(INTMOD, downTerm(TL, 'noTerm.QidList)) :: Term
        then
            < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | mt, session: SESSION + toString(LOG, true), log: [ nil : STR + "\n" ], goals: { '0, 'init, false, true, true, 1 + size(getVars(parseClause(INTMOD, downTerm(TL, 'noTerm.QidList)))), mt, INTHPS, normalizeVars(parseClause(INTMOD, downTerm(TL, 'noTerm.QidList))) } >
            write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Initial goal set." + BW + "\n\n" + toString(INTMOD, { '0, 'init, false, true, true, 1 + size(getVars(parseClause(INTMOD, downTerm(TL, 'noTerm.QidList)))), mt, INTHPS, normalizeVars(parseClause(INTMOD, downTerm(TL, 'noTerm.QidList))) }, VERBOSE))
        else
            printErr(< OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, session: SESSION, log: LOG, goals: GOALS >, error(21), STR, true)
        fi [ owise ] .

    --- check rpo .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'check`rpo`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, true) .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'check`rpo`..NuITP-Command) =
        if (checkRPOSignature(getOps(INTMOD)) == none)
        then
            if (checkRPOEquations(INTMOD) :: EquationSet)
            then
                if (checkRPOEquations(INTMOD) == none)
                then
                    < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >
                    printMsg(stdout, OID, ATS, "RPO order defined in module " + string(MODNAME) + " appears to be consistent with the equations.")
                else
                    printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >, error(4, string(MODNAME), toString(INTMOD, checkRPOEquations(INTMOD))), STR, true)
                fi
            else
                printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >, error(0), STR, true) --- Unexpected error classifying equations
            fi
        else
            printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >, error(3, toString(INTMOD, checkRPOSignature(getOps(INTMOD)))), STR, true)
        fi [ owise ] .

    --- set verbose on .
    eq < OID : NuITP | ATS, verbose: VERBOSE > parse(STR, 'set`verbose`on`..NuITP-Command) = < OID : NuITP | ATS, verbose: true > write(stdout, OID, printCommand(ATS, STR)) .

    --- set verbose off .
    eq < OID : NuITP | ATS, verbose: VERBOSE > parse(STR, 'set`verbose`off`..NuITP-Command) = < OID : NuITP | ATS, verbose: false > write(stdout, OID, printCommand(ATS, STR)) .

    --- clear .
    eq < OID : NuITP | ATS, verbose: VERBOSE, log: LINE LOG, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS > parse(STR, 'clear`..NuITP-Command)
       =
       < OID : NuITP | ATS, verbose: VERBOSE, log: LINE, internal: INTMOD | INTHPS | mt, goals: undoGoal(GOALS, '0) >
       write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Local session cleard." + "\n\n" + RED + "  Unproven goals:\n\n" + BW + toString(INTMOD, undoGoal(GOALS, '0), VERBOSE) + RED + "  Total unproven goals: 1\n\n" + BW) .
    
    eq < OID : NuITP | ATS, verbose: VERBOSE, log: nil, internal: INTMOD | INTHPS | INTLOCAL, goals: mt > parse(STR, 'clear`..NuITP-Command) =
        printErr(< OID : NuITP | ATS, verbose: VERBOSE, log: nil, internal: INTMOD | INTHPS | INTLOCAL, goals: mt >, error(5), STR, false) .

    --- clear all .
    op setInitParams : Configuration IOModeList -> Configuration .
    eq setInitParams(< OID : NuITP | ATS, io: IOL >, IOL') = < OID : NuITP | ATS, io: IOL' > .
    
    eq < OID : NuITP | ATS, io: IOL > parse(STR, 'clear`all`..NuITP-Command) = setInitParams(init-configuration, IOL) printMsg(stdout, OID, ATS, "Session cache cleared.") .

    --- show log .
    eq < OID : NuITP | ATS, log: nil > parse(STR, 'show`log`..NuITP-Command) = < OID : NuITP | ATS, log: nil > printMsg(stdout, OID, ATS, "Log is empty.") .
    eq < OID : NuITP | ATS, log: LOG > parse(STR, 'show`log`..NuITP-Command) = 
        < OID : NuITP | ATS, log: LOG > 
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  NuITP log for current goal:" + BW + "\n\n" + toString(LOG, true) + "\n") 
        [ owise ] .

    --- show session log .
    eq < OID : NuITP | ATS, session: "", log: nil > parse(STR, 'show`session`log`..NuITP-Command) = < OID : NuITP | ATS, log: nil > printMsg(stdout, OID, ATS, "Session log is empty.") .
    eq < OID : NuITP | ATS, session: SESSION, log: LOG > parse(STR, 'show`session`log`..NuITP-Command) = 
        < OID : NuITP | ATS, session: SESSION, log: LOG > 
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  NuITP log for current session:" + BW + "\n\n" + SESSION + toString(LOG, true) + "\n") 
        [ owise ] .

    --- show module .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`module`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, modname: MODNAME > parse(STR, 'show`module`..NuITP-Command) = < OID : NuITP | ATS, modname: MODNAME > write(stdout, OID, printCommand(ATS, STR) + BW + toString(upModule(MODNAME, false)) + "\n\n") [ owise ] .

    --- show local module .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`local`module`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'show`local`module`..NuITP-Command) = 
        < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > 
        write(stdout, OID, printCommand(ATS, STR) + BW + toString'(getLocalModule(INTMOD, INTLOCAL)) + "\n\n") 
        [ owise ] .

    --- show extended module .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`extended`module`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'show`extended`module`..NuITP-Command) = 
        < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > 
        write(stdout, OID, printCommand(ATS, STR) + BW + toString'(e=xu(extModule(MODNAME), mt)) + "\n\n") 
        [ owise ] .

    --- show internal module .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`internal`module`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'show`internal`module`..NuITP-Command) = 
        < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL > 
        write(stdout, OID, printCommand(ATS, STR) + BW + toString'(INTMOD) + "\n\n") 
        [ owise ] .

    --- show predicates .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`predicates`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'show`predicates`..NuITP-Command) = 
        < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Equality predicates for module " + string(MODNAME) + " (without unity axiom):\n\n" + BW + if (getEqPreds(e=xu(extModule(MODNAME), mt)) == none) then "  No equations." else toString(e=xu(extModule(MODNAME), mt), getEqPreds(e=xu(extModule(MODNAME), mt))) fi + "\n") 
        [ owise ] .

    --- show internal predicates .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`internal`predicates`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'show`internal`predicates`..NuITP-Command) = 
        < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Equality predicates for internalized module " + string(MODNAME) + " (without unity axiom):\n\n" + BW + if (getEqPreds(e=xu(INTMOD, mt)) == none) then "  No equations." else toString(e=xu(INTMOD, mt), getEqPreds(e=xu(INTMOD, mt))) fi + "\n") 
        [ owise ] .

    --- show internal .
    eq < OID : NuITP | ATS, modname: 'noModule > parse(STR, 'show`internal`..NuITP-Command) = printErr(< OID : NuITP | ATS, modname: 'noModule >, error(2), STR, false) .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'show`internal`..NuITP-Command) =
        < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL >
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Internalized equations:\n\n" + BW + 
        if (getInternalEqs(INTMOD) == none) then "  No equations internalized.\n" else toString(INTMOD, getInternalEqs(INTMOD)) fi + 
        CYAN + "\n  Internalized hypotheses:\n\n" + BW + 
        if (INTHPS == mt) then "  No hypotheses internalized." else toString(INTMOD, INTHPS, "  ") fi + 
        CYAN + "\n\n  Externalized conditional equations:\n\n" + BW + 
        if (toClauses(INTMOD) == mt) then "  No conditional equations externalized." else toString(INTMOD, toClauses(INTMOD), "  ") fi + 
        CYAN + "\n\n  Locally internalized goals:\n\n" + BW + 
        if (INTLOCAL == mt) then "  No local goals internalized." else toString(INTMOD, INTLOCAL, "  ") fi + 
        "\n\n")
        [ owise ] .

    --- show frontier .
    eq < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS > parse(STR, 'show`frontier`..NuITP-Command) = < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >
        if (getFrontier(GOALS) == mt)
        then 
            if (GOALS == mt)
            then printMsg(stdout, OID, ATS, "No initinal goal set.")
            else write(stdout, OID, printCommand(ATS, STR) + GREEN + "  All goals have been proved.\n\n  qed\n\n" + BW)
            fi
        else
            if getProofState(GOALS) == unsat
            then printMsg(stdout, OID, ATS, "Initial goal has been disproved. Frontier is closed.")
            else write(stdout, OID, printCommand(ATS, STR) + RED + "  Unproven goals:\n\n" + BW + toString(INTMOD, getFrontier(GOALS), VERBOSE) + RED + "  Total unproven goals: " + string(size(getFrontier(GOALS)), 10) + "\n\n" + BW)
            fi
        fi .

    --- show goals .
    eq < OID : NuITP | ATS, goals: mt > parse(STR, 'show`goals`..NuITP-Command) = printErr(< OID : NuITP | ATS, goals: mt >, error(40), STR, false) .
    eq < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS > parse(STR, 'show`goals`..NuITP-Command) =
        < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >
        write(stdout, OID, printCommand(ATS, STR) + toString(INTMOD, GOALS, VERBOSE))
        [ owise ] .

    --- show goal GID .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS > parse(STR, 'show`goal_.['token[TGID]]) =
        if getGoal(GOALS, getGID(TGID)) :: Goal
        then
            < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >
            write(stdout, OID, printCommand(ATS, STR) + toString(INTMOD,getGoal(GOALS, getGID(TGID))))
        else
            printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(41), STR, false)
        fi .

    --- show stats .
    eq < OID : NuITP | ATS, goals: mt > parse(STR, 'show`stats`..NuITP-Command) = printErr(< OID : NuITP | ATS, goals: mt >, error(40), STR, false) .
    eq < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS > parse(STR, 'show`stats`..NuITP-Command) =
        < OID : NuITP | ATS, verbose: VERBOSE, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >
        write(stdout, OID, printCommand(ATS, STR) + getStats(GOALS))
        [ owise ] .

    --- show gensets .
    eq < OID : NuITP | ATS, gensets: mt > parse(STR, 'show`gensets`..NuITP-Command) = printErr(< OID : NuITP | ATS, gensets: mt >, error(111), STR, false) .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS > parse(STR, 'show`gensets`..NuITP-Command) =
        < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS >
        write(stdout, OID, printCommand(ATS, STR) + toString(INTMOD, GENSETS, 'all))
        [ owise ] .

    --- show gensets for TYPE .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS > parse(STR, 'show`gensets`for_.['token[ARG1]]) =
        if (downTerm(ARG1, 'nil.QidList) inS getSorts(INTMOD))
        then
            if (getGenSets(GENSETS, downTerm(ARG1, 'nil.QidList)) == mt)
            then
                printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS >, error(111, string(downTerm(ARG1, 'nil.QidList))), STR, false)
            else
                < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS >
                write(stdout, OID, printCommand(ATS, STR) + toString(INTMOD, getGenSets(GENSETS, downTerm(ARG1, 'nil.QidList)), 'all))
            fi
        else
            printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS >, error(106, string(downTerm(ARG1, 'nil.QidList)), string(MODNAME)), STR, false)
        fi .

    --- show genset ID .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS > parse(STR, 'show`genset_.['token[ARG]]) =
        if (getGenSet(GENSETS, string(downTerm(ARG, 'nil.QidList))) == mt)
        then
            printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS >, error(112, string(downTerm(ARG, 'nil.QidList))), STR, false)
        else
            < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS >
            write(stdout, OID, printCommand(ATS, STR) + toString(INTMOD, getGenSet(GENSETS, string(downTerm(ARG, 'nil.QidList))), 'one))
        fi .

    --- set local internalize on .
    eq < OID : NuITP | ATS, log: LOG, local: LOCAL > parse(STR, 'set`local`internalize`on`..NuITP-Command) = < OID : NuITP | ATS, log: (LOG [ nil : STR + "\n" ]), local: true > write(stdout, OID, printCommand(ATS, STR)) .

    --- set local internalize off .
    eq < OID : NuITP | ATS, log: LOG, local: LOCAL > parse(STR, 'set`local`internalize`off`..NuITP-Command) = < OID : NuITP | ATS, log: (LOG [ nil : STR + "\n" ]), local: false > write(stdout, OID, printCommand(ATS, STR)) .

    --- internalize GID .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'internalize_.['token[TGID]]) =
        if getGoal(GOALS, getGID(TGID)) :: Goal
        then
            if (getSkolemAsVars(getCLA(getGoal(GOALS, getGID(TGID))), getSKO(getGoal(GOALS, getGID(TGID)))) == mt)
            then
                if areProven(getChildren(GOALS, getGID(TGID)) getGoal(GOALS, getGID(TGID)))
                then
                    < OID : NuITP | ATS, log: (LOG [ getGID(TGID) : STR + "\n" ]), internal: internalize(INTMOD, INTHPS, INTLOCAL, getGoal(GOALS, getGID(TGID))), goals: updateInternal(internalize(INTMOD, INTHPS, INTLOCAL, getGoal(GOALS, getGID(TGID))), GOALS) >
                    printMsg(stdout, OID, ATS, "Goal " + join(getGID(TGID)) + " has been internalized.")
                else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(94), STR, true)
                fi
            else 
                printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(95), STR, true)
            fi
        else
            printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(41), STR, true)
        fi .

    --- internalize .
    eq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'internalize`..NuITP-Command) =
        if (getProofState(GOALS) == sat)
        then
            < OID : NuITP | ATS, modname: MODNAME, internal: internalize(INTMOD, INTHPS, INTLOCAL, getGoal(GOALS, '0)), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
            printMsg(stdout, OID, ATS, "Proven goal has been internalized.")
        else printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(90), STR, true)
        fi .

    --- internalize all .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'internalize`all`..NuITP-Command) =
        if (getProofState(GOALS) == sat)
        then
            < OID : NuITP | ATS, internal: internalize(INTMOD, INTHPS, INTLOCAL, GOALS), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
            printMsg(stdout, OID, ATS, "All intermediate goals with no skolem constants have been internalized.")
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(90), STR, true)
        fi .

    --- internalize as assoc .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'internalize`as`assoc`..NuITP-Command) =
        if (getProofState(GOALS) == sat)
        then
            if checkAxiom(INTMOD, getCLA(getGoal(GOALS, '0)), assoc)
            then
                if (internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), assoc) :: Internal)
                then
                    if checkExec(internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), assoc))
                    then
                        < OID : NuITP | ATS, internal: internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), assoc), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
                        printMsg(stdout, OID, ATS, "Proven goal has been internalized as assoc axiom.")
                    else --- Non-executable
                        printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(92), STR, true)
                    fi
                else --- Unexpected error
                    printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(93), STR, true)
                fi
            else --- Not the axiom
                printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(91), STR, true)
            fi
        else --- Not proved
            printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(90), STR, true)
        fi .

    --- internalize as comm .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'internalize`as`comm`..NuITP-Command) =
        if (getProofState(GOALS) == sat)
        then
            if checkAxiom(INTMOD, getCLA(getGoal(GOALS, '0)), comm)
            then
                if (internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), comm) :: Internal)
                then
                    if checkExec(internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), comm))
                    then
                        < OID : NuITP | ATS, internal: internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), comm), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
                        printMsg(stdout, OID, ATS, "Proven goal has been internalized as comm axiom.")
                    else --- Non-executable
                        printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(92), STR, true)
                    fi
                else --- Unexpected error
                    printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(93), STR, true)
                fi
            else --- Not the axiom
                printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(91), STR, true)
            fi
        else --- Not proved
            printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(90), STR, true)
        fi .

    --- force internalize .
    eq < OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'force`internalize`..NuITP-Command) =
        < OID : NuITP | ATS, wild: true, internal: internalize(INTMOD, INTHPS, INTLOCAL, getGoal(GOALS, '0)), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
        printMsg(stdout, OID, ATS, "Unproven goal has been internalized.") .

    --- force internalize all .
    eq < OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'force`internalize`all`..NuITP-Command) =
        < OID : NuITP | ATS, wild: true, internal: internalize(INTMOD, INTHPS, INTLOCAL, GOALS), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
        printMsg(stdout, OID, ATS, "All intermediate (unproven) goals with no skolem constants have been internalized.") .

    --- force internalize as assoc .
    eq < OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'force`internalize`as`assoc`..NuITP-Command) =
        if checkAxiom(INTMOD, getCLA(getGoal(GOALS, '0)), assoc)
        then
            if (internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), assoc) :: Internal)
            then
                if checkExec(internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), assoc))
                then
                    < OID : NuITP | ATS, wild: true, internal: internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), assoc), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
                    printMsg(stdout, OID, ATS, "Unproven goal has been internalized as comm axiom.")
                else --- Non-executable
                    printErr(< OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(92), STR, true)
                fi
            else --- Unexpected error
                printErr(< OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(93), STR, true)
            fi
        else --- Not the axiom
            printErr(< OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(91), STR, true)
        fi .

    --- force internalize as comm .
    eq < OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS > parse(STR, 'force`internalize`as`comm`..NuITP-Command) =
        if checkAxiom(INTMOD, getCLA(getGoal(GOALS, '0)), comm)
        then
            if (internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), comm) :: Internal)
            then
                if checkExec(internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), comm))
                then
                    < OID : NuITP | ATS, wild: true, internal: internalize(INTMOD, INTHPS, INTLOCAL, getCLA(getGoal(GOALS, '0)), comm), log: (LOG [ nil : STR + "\n" ]), goals: GOALS >
                    printMsg(stdout, OID, ATS, "Unproven goal has been internalized as assoc axiom.")
                else --- Non-executable
                    printErr(< OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(92), STR, true)
                fi
            else --- Unexpected error
                printErr(< OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(93), STR, true)
            fi
        else --- Not the axiom
            printErr(< OID : NuITP | ATS, wild: WILD, internal: INTMOD | INTHPS | INTLOCAL, log: LOG, goals: GOALS >, error(91), STR, true)
        fi .

    --- undo GID .
    eq < OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS > parse(STR, 'undo_.['token[TGID]]) =
        if getGoal(GOALS, getGID(TGID)) :: Goal
        then
            if isProved(getGoal(GOALS, getGID(TGID)))
            then
                printErr(< OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(60, join(getGID(TGID))), STR, false)
            else
                if isDisproved(getGoal(GOALS, getGID(TGID)))
                then
                    printErr(< OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(61, join(getGID(TGID))), STR, false)
                else
                    if (getChildren(GOALS, getGID(TGID)) == mt)
                    then
                        printErr(< OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(62, join(getGID(TGID))), STR, false)
                    else
                        < OID : NuITP | ATS, verbose: VERBOSE, log: (LOG [ getGID(TGID) : "undo " + join(getGID(TGID)) + " .\n" ]), internal: INTMOD | INTHPS | INTLOCAL, goals: undoGoal(GOALS, getGID(TGID)) >
                        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Goal " + join(getGID(TGID)) + " undone. All its children have been deleted." + "\n\n" + RED + "  Unproven goals:\n\n" + BW + toString(INTMOD, getFrontier(undoGoal(GOALS, getGID(TGID))), VERBOSE) + RED + "  Total unproven goals: " + string(size(getFrontier(undoGoal(GOALS, getGID(TGID)))), 10) + "\n\n" + BW)
                    fi
                fi
            fi
        else
            printErr(< OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(41), STR, false)
        fi .

    --- strat NAME is STRATEGY .
    ceq < OID : NuITP | ATS, strats: SSL, log: LOG > parse(STR, 'strat_is_.['token[ARG],'bubble[ARG1]]) =
        if (string(downTerm(ARG, 'nil.QidList))) == "NuITP"
        then
            printErr(< OID : NuITP | ATS, strats: SSL, log: LOG >, error(133), STR, true)
        else
            if checkStrategy(STA)
            then 
                < OID : NuITP | ATS, strats: addStrategy(SSL, string(downTerm(ARG, 'nil.QidList)), STA), log: (LOG [ nil : STR + "\n" ]) > 
                write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Simplification strategy " + string(downTerm(ARG, 'nil.QidList)) + " added successfully.\n\n" + BW)
            else 
                printErr(< OID : NuITP | ATS, strats: SSL, log: LOG >, error(131), STR, true)
            fi
        fi
        if QL := downTerm(ARG1, 'nil.QidList)
        /\ STA := metaParseStrategy(upModule('NuITP-SIMPLIFICATION-STRATEGIES, false), none, QL) .
    eq < OID : NuITP | ATS > parse(STR, 'strat_is_.['token[ARG],'bubble[ARG1]]) = printErr(< OID : NuITP | ATS >, error(130), STR, true) [ owise ] .
        
    --- set default strat STRAT_ID .
    eq < OID : NuITP | ATS, strats: SSL, log: LOG > parse(STR, 'set`default`strat_.['token[ARG]]) =
        if (getStrat(SSL, string(downTerm(ARG, 'nil.QidList))) == empty)
        then
            printErr(< OID : NuITP | ATS, strats: SSL, log: LOG >, error(134, string(downTerm(ARG, 'nil.QidList))), STR, true)
        else
            < OID : NuITP | ATS, strats: setDefaultStrat(SSL, string(downTerm(ARG, 'nil.QidList))), log: (LOG [ nil : STR + "\n" ]) >
            write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Simplification strategy " + string(downTerm(ARG, 'nil.QidList)) + " is now default.\n\n" + BW)
        fi .

    --- show strats .
    eq < OID : NuITP | ATS, strats: nil > parse(STR, 'show`strats`..NuITP-Command) = printErr(< OID : NuITP | ATS, strats: nil >, error(132), STR, false) .
    eq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, strats: SSL > parse(STR, 'show`strats`..NuITP-Command) =
        < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, strats: SSL >
        write(stdout, OID, printCommand(ATS, STR) + toString(SSL))
        [ owise ] .

    --- genset NAME for TYPE is TERMSET .
    ceq < OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL > parse(STR, 'genset_for_is_.['token[ARG],'token[ARG1],'bubble[ARG2]]) =
        printErr(< OID : NuITP | ATS, modname: MODNAME, internal: INTMOD | INTHPS | INTLOCAL >, error(106, string(TY), string(MODNAME)), STR, true)
        if TY := downTerm(ARG1, 'nil.QidList)
        /\ not(TY inS getSorts(INTMOD)) .

    ceq < OID : NuITP | ATS, gensets: GENSETS > parse(STR, 'genset_for_is_.['token[ARG],'token[ARG1],'bubble[ARG2]]) =
        printErr(< OID : NuITP | ATS, gensets: GENSETS >, error(107, string(Q)), STR, true)
        if Q := downTerm(ARG, 'nil.QidList)
        /\ TY := downTerm(ARG1, 'nil.QidList)
        /\ not(checkGenSetId(GENSETS, TY, string(Q))) .

    ceq < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, log: LOG > parse(STR, 'genset_for_is_.['token[ARG],'token[ARG1],'bubble[ARG2]]) =
        if (PARSED-GENSET :: TermSet) and-then (PARSED-GENSET =/= mt)
        then
            < OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: addGenSet(GENSETS, string(Q), TY, PARSED-GENSET), log: (LOG [ nil : STR + "\n" ]) >
            write(stdout, OID, printCommand(ATS, STR) + toString(INTMOD, getGenSet(addGenSet(GENSETS, string(Q), TY, PARSED-GENSET), string(Q)), 'new))
        else
            printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, log: LOG >, error(106, string(TY)), STR, true)
        fi
        if Q := downTerm(ARG, 'nil.QidList)
        /\ TY := downTerm(ARG1, 'nil.QidList)
        /\ (TY ; SS) := getSorts(INTMOD)
        /\ PARSED-GENSET := parseGenSet(INTMOD, TY, downTerm(ARG2,'nil.QidList)) [ owise ] .

    --- set default genset GENSET_ID .
    eq < OID : NuITP | ATS, gensets: GENSETS, log: LOG > parse(STR, 'set`default`genset_.['token[ARG]]) =
        if (getGenSet(GENSETS, string(downTerm(ARG, 'nil.QidList))) == mt)
        then
            printErr(< OID : NuITP | ATS, gensets: GENSETS, log: LOG >, error(112, string(downTerm(ARG, 'nil.QidList))), STR, true)
        else
            < OID : NuITP | ATS, gensets: setDefault(GENSETS, string(downTerm(ARG, 'nil.QidList))), log: (LOG [ nil : STR + "\n" ]) >
            write(stdout, OID, printCommand(ATS, STR) + CYAN + "  Generator set " + string(downTerm(ARG, 'nil.QidList)) + " is now default.\n\n" + BW)
        fi .

    op getRuleMsg : QidList -> String .
    --- Simplification Rules
    eq getRuleMsg('eps) = "Equality Predicate Simplification (EPS)" .
    eq getRuleMsg('cvul) = "Constructor Variant Unification Left (CVUL)" .
    eq getRuleMsg('cvufr) = "Constructor Variant Unification Failure Right (CVUFR)" .
    eq getRuleMsg('subl) = "Substitution Left (SUBL)" .
    eq getRuleMsg('subr) = "Substitution Right (SUBR)" .
    eq getRuleMsg('ns) = "Narrowing Simplification (NS)" .
    eq getRuleMsg('ins) = "Narrowing Simplification (NS)" .
    eq getRuleMsg('cs) = "Clause Subsumption (CS)" .
    eq getRuleMsg('icc) = "Inductive Congruence Closure (ICC)" .
    eq getRuleMsg('varsat) = "Variant Satisfiability (VARSAT)" .
    eq getRuleMsg('gnd) = "Grounding (GND)" .
    eq getRuleMsg('ufree) = "Unity Free (UFREE)" .
    eq getRuleMsg('rst) = "Restart (RST)" .
    eq getRuleMsg('eq) = "Equality (EQ)" .

    --- Inductive Rules
    eq getRuleMsg('gsi) = "Generator Set Induction (GSI)" .
    eq getRuleMsg('gsi+) = "Generator Set Induction (GSI)" .
    eq getRuleMsg('ni) = "Narrowing Induction (NI)" .
    eq getRuleMsg('le) = "Lemma Enrichment (LE)" .
    eq getRuleMsg('sp) = "Split (SP)" .
    eq getRuleMsg('cas) = "Case (CAS)" .
    eq getRuleMsg('cas1) = "Case (CAS)" .
    eq getRuleMsg('cas+) = "Case (CAS)" .
    eq getRuleMsg('va) = "Variable Abstraction (VA)" .
    eq getRuleMsg('cut) = "Cut (CUT)" .

    eq getRuleMsg('!) = " with Equality Predicate Simplification" .
    eq getRuleMsg('try-eps) = " with Equality Predicate Simplification" .
    eq getRuleMsg('NuITP) = " with NuITP Default Simplification Strategy" .
    eq getRuleMsg(Q) = " with " + string(Q) + " Simplification Strategy" [ owise ] .
    
    eq getRuleMsg(Q NQL) = getRuleMsg(Q) + getRuleMsg(NQL) .

    sort QidList? .
    subsort QidList < QidList? .

    op checkRules : Qid Qid -> Bool .
    ceq checkRules('apply_to_., RULE) = true 
        if (RULE == 'eps) or-else (RULE == 'cvul) or-else (RULE == 'cvufr) or-else (RULE == 'subl) or-else (RULE == 'subr) or-else (RULE == 'ns) or-else 
           (RULE == 'cs) or-else (RULE == 'icc) or-else (RULE == 'varsat) or-else (RULE == 'gnd) or-else (RULE == 'ufree) or-else (RULE == 'rst) or-else 
           (RULE == 'gsi) or-else (RULE == 'cas) .
    ceq checkRules('apply_to_with_., RULE) = true 
        if (RULE == 'eq) or-else (RULE == 'gsi) or-else (RULE == 'cas) or-else (RULE == 'le) or-else (RULE == 'sp) or-else (RULE == 'cut) .
    ceq checkRules('apply_to_on_., RULE) = true 
        if (RULE == 'ns) or-else (RULE == 'gsi) or-else (RULE == 'cas) or-else (RULE == 'ni) or-else (RULE == 'va) .
    ceq checkRules('apply_to_on_with_., RULE) = true 
        if (RULE == 'gsi) or-else (RULE == 'cas) .
    eq checkRules('apply_to_with`reversed_., 'eq) = true .
    ceq checkRules('apply_to_with_sub_., RULE) = true 
        if (RULE == 'eq) or-else (RULE == 'sp) .
    eq checkRules('apply_to_with`reversed_sub_., 'eq) = true .
    
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_.['bubble[RULES?],'token[GOAL]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, (if (RULE == 'gsi) then 'gsi+ else if (RULE == 'cas) then 'cas+ else RULE fi fi) STRAT, 'apply_to_., GOAL, empty)
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_., RULE) .
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_with_.['bubble[RULES?],'token[GOAL],'bubble[ARG]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, RULE STRAT, 'apply_to_with_., GOAL, ARG)
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_with_., RULE) .
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_with`reversed_.['bubble[RULES?],'token[GOAL],'token[ARG]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, RULE STRAT, 'apply_to_with`reversed_., GOAL, ARG)
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_with`reversed_., RULE) .
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_with_sub_.['bubble[RULES?],'token[GOAL],'bubble[ARG1],'bubble[ARG2]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, RULE STRAT, 'apply_to_with_sub_., GOAL, (ARG1,ARG2))
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_with_sub_., RULE) .
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_with`reversed_sub_.['bubble[RULES?],'token[GOAL],'token[ARG1],'bubble[ARG2]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, RULE STRAT, 'apply_to_with`reversed_sub_., GOAL, (ARG1,ARG2))
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_with`reversed_sub_., RULE) .
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_on_.['bubble[RULES?],'token[GOAL],'bubble[ARG]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, RULE STRAT, 'apply_to_on_., GOAL, ARG)
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_on_., RULE) .
    ceq < OID : NuITP | ATS, strats: SSL > parse(STR, 'apply_to_on_with_.['bubble[RULES?],'token[GOAL],'bubble[ARG1],'bubble[ARG2]]) = checkGoal(< OID : NuITP | ATS, strats: SSL >, STR, RULE STRAT, 'apply_to_on_with_., GOAL, (ARG1,ARG2))
        if RULE STRAT := unfoldStrat(downQidTermList(RULES?), SSL)
        /\ checkRules('apply_to_on_with_., RULE) .

    eq < OID : NuITP | ATS > parse(STR, 'apply_to_.[NTL]) = < OID : NuITP | ATS > parse(STR, getTerm(noParse(1))) [ owise ] .
    eq < OID : NuITP | ATS > parse(STR, 'apply_to_with_.[NTL]) = < OID : NuITP | ATS > parse(STR, getTerm(noParse(1))) [ owise ] .
    eq < OID : NuITP | ATS > parse(STR, 'apply_to_with_sub_.[NTL]) = < OID : NuITP | ATS > parse(STR, getTerm(noParse(1))) [ owise ].
    eq < OID : NuITP | ATS > parse(STR, 'apply_to_on_.[NTL]) = < OID : NuITP | ATS > parse(STR, getTerm(noParse(1))) [ owise ] .
    eq < OID : NuITP | ATS > parse(STR, 'apply_to_on_with_.[NTL]) = < OID : NuITP | ATS > parse(STR, getTerm(noParse(1))) [ owise ] .

    eq < OID : NuITP | ATS > parse(STR, 'simplify_.['token[GOAL]]) = checkGoal(< OID : NuITP | ATS >, STR, nil, 'simplify_using_., GOAL, empty) .
    eq < OID : NuITP | ATS > parse(STR, 'simplify_using_.['token[GOAL],'token[STRAT]]) = checkGoal(< OID : NuITP | ATS >, STR, STRAT, 'simplify_using_., GOAL, empty) .
    
    eq < OID : NuITP | ATS > parse(STR, 'assert`..NuITP-Command) = assertGoal(< OID : NuITP | ATS >, STR, 'assert`..NuITP-Command, ''0.Qid) .
    eq < OID : NuITP | ATS > parse(STR, 'assert_.['token[GOAL]]) = assertGoal(< OID : NuITP | ATS >, STR, 'assert_., GOAL) .

    op assertGoal : Configuration String Qid Term -> Configuration .
    eq assertGoal(< OID : NuITP | ATS, goals: GOALS >, STR, 'assert`..NuITP-Command, GOAL) = 
        if (getGoal(GOALS, getGID(GOAL)) == mt)
        then printErr(< OID : NuITP | ATS, goals: GOALS >, error(70, join(getGID(GOAL))), STR, true)
        else 
            if areProven(getChildren(GOALS, getGID(GOAL)) getGoal(GOALS, getGID(GOAL)))
            then 
                < OID : NuITP | ATS, goals: GOALS >
                write(stdout, OID, printCommand(ATS, STR) + GREEN + "  Assertion checked successfully." + BW + "\n\n")
            else printErr(< OID : NuITP | ATS, goals: GOALS >, error(71), STR, true)
            fi
        fi .
    eq assertGoal(< OID : NuITP | ATS, goals: GOALS >, STR, 'assert_., GOAL) = 
        if (getGoal(GOALS, getGID(GOAL)) == mt)
        then printErr(< OID : NuITP | ATS, goals: GOALS >, error(70, join(getGID(GOAL))), STR, true)
        else 
            if areProven(getChildren(GOALS, getGID(GOAL)) getGoal(GOALS, getGID(GOAL)))
            then 
                < OID : NuITP | ATS, goals: GOALS >
                write(stdout, OID, printCommand(ATS, STR) + GREEN + "  Assertion checked successfully." + BW + "\n\n")
            else printErr(< OID : NuITP | ATS, goals: GOALS >, error(72, join(getGID(GOAL))), STR, true)
            fi
        fi .
    
    op checkGoal : Configuration String QidList Qid Term TermList -> Configuration .
    eq checkGoal(< OID : NuITP | ATS, goals: GOALS >, STR, STRAT, CMD, GOAL, ARGS) =
        if (getGoal(GOALS, getGID(GOAL)) == mt)
        then printErr(< OID : NuITP | ATS, goals: GOALS >, error(41, join(getGID(GOAL))), STR, true)
        else checkFrontier(< OID : NuITP | ATS, goals: GOALS >, STR, STRAT, CMD, getGID(GOAL), ARGS)
        fi .

    op checkFrontier : Configuration String QidList Qid QidList TermList -> Configuration .
    eq checkFrontier(< OID : NuITP | ATS, goals: GOALS >, STR, STRAT, CMD, GID, ARGS) =
        if (getProofState(GOALS) == sat)
        then printErr(< OID : NuITP | ATS, goals: GOALS >, error(80), STR, true)
        else
            if (getProofState(GOALS) == unsat)
            then printErr(< OID : NuITP | ATS, goals: GOALS >, error(81), STR, true)
            else
                if isFrontier(getGoal(GOALS, GID))
                then checkArgs(< OID : NuITP | ATS, goals: GOALS >, STR, STRAT, CMD, GID, ARGS)
                else printErr(< OID : NuITP | ATS, goals: GOALS >, error(82, join(GID)), STR, true)
                fi
            fi
        fi .

    op checkArgs : Configuration String QidList Qid QidList TermList -> Configuration .
    eq checkArgs(CONF, STR, STRAT, 'apply_to_., GID, empty) = checkApply(CONF, STR, STRAT, GID, none) .
    eq checkArgs(CONF, STR, STRAT, 'simplify_using_., GID, empty) = checkSimplify(CONF, STR, STRAT, GID, none) .

    --- Equality (EQ) for Hypotheses
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_., GID, EQUALITY) =
        if PARSED-EQUALITY :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-EQUALITY) ; 'ARG2:Substitution <- 'none.Substitution))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(100), STR, true)
        fi
        if (RULE == 'eq) 
        /\ not(EQUALITY :: Qid)
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-EQUALITY := parseEquality(SKO-MODULE, downTerm(EQUALITY, 'nil.QidList)) .

    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_sub_., GID, (EQUALITY,SUB)) =
        if PARSED-EQUALITY :: Term
        then
            if PARSED-SUB :: Substitution
            then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-EQUALITY) ; 'ARG2:Substitution <- upTerm(PARSED-SUB)))
            else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(101), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(100), STR, true)
        fi
        if (RULE == 'eq) 
        /\ not(EQUALITY :: Qid)
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-EQUALITY := parseEquality(SKO-MODULE, downTerm(EQUALITY, 'nil.QidList))
        /\ PARSED-SUB := parseSubstitution(SKO-MODULE, downTerm(SUB, 'nil.QidList)) .
    
    --- Equality (EQ) for Equations
    --- Default orientation
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_., GID, LABEL) =
        if PARSED-EQUALITY :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Qid <- LABEL ; 'ARG2:Substitution <- 'none.Substitution ; 'ARG3:Bool <- 'false.Bool))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(115), STR, true)
        fi
        if (RULE == 'eq)
        /\ LABEL :: Qid
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-EQUALITY := toOrientedClauses(getEquation(INTMOD, downTerm(LABEL, 'nil.QidList))) .

    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_sub_., GID, (LABEL, SUB)) =
        if PARSED-EQUALITY :: Term
        then
            if PARSED-SUB :: Substitution
            then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Qid <- LABEL ; 'ARG2:Substitution <- upTerm(PARSED-SUB) ; 'ARG3:Bool <- 'false.Bool))
            else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(101), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(115), STR, true)
        fi
        if (RULE == 'eq) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-EQUALITY := toOrientedClauses(getEquation(INTMOD, downTerm(LABEL, 'nil.QidList)))
        /\ PARSED-SUB := parseSubstitution(SKO-MODULE, downTerm(SUB, 'nil.QidList)) .
    --- Reversed orientation
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with`reversed_., GID, LABEL) =
        if PARSED-EQUALITY :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Qid <- LABEL ; 'ARG2:Substitution <- 'none.Substitution ; 'ARG3:Bool <- 'true.Bool))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(115), STR, true)
        fi
        if (RULE == 'eq) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-EQUALITY := toOrientedClauses(getEquation(INTMOD, downTerm(LABEL, 'nil.QidList))) .

    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with`reversed_sub_., GID, (LABEL, SUB)) =
        if PARSED-EQUALITY :: Term
        then
            if PARSED-SUB :: Substitution
            then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Qid <- LABEL ; 'ARG2:Substitution <- upTerm(PARSED-SUB) ; 'ARG3:Bool <- 'true.Bool))
            else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(101), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(115), STR, true)
        fi
        if (RULE == 'eq) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-EQUALITY := toOrientedClauses(getEquation(INTMOD, downTerm(LABEL, 'nil.QidList)))
        /\ PARSED-SUB := parseSubstitution(SKO-MODULE, downTerm(SUB, 'nil.QidList)) .

    --- Generator Set Induction (GSI) & Case (CAS)
    --- 1..n variables with default Generator Sets.
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, STR, (RULE STRAT), 'apply_to_on_., GID, VAR) =
        if (PARSED-VARS :: TermList)
        then
            if ((RULE == 'gsi) and-then (PARSED-VARS in getCLA(getGoal(GOALS, GID)))) or-else ((RULE == 'cas) and-then (PARSED-VARS in unfreeze(getCLA(getGoal(GOALS, GID)))))
            then
                if hasGeneratorSet?(PARSED-VARS, GENSETS)
                then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:TermList <- upTerm(freeze(PARSED-VARS, getSKO(getGoal(GOALS, GID))))))
                else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, error(106), STR, true)
                fi
            else
                printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, error(109), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, error(108), STR, true)
        fi
        if (RULE == 'gsi) or-else (RULE == 'cas) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-VARS := parseVariables(SKO-MODULE, downTerm(VAR, 'nil.QidList), if (RULE == 'cas) then getVars(unfreeze(getCLA(getGoal(GOALS, GID)))) else getVars(getCLA(getGoal(GOALS, GID))) fi) .

    --- 1..n variables with explicit Generator Sets (previously saved, except for the single variable case).
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, STR, (RULE STRAT), 'apply_to_on_with_., GID, (VAR,GENSET)) =
        if (PARSED-VARS :: TermList)
        then
            if ((RULE == 'gsi) and-then (PARSED-VARS in getCLA(getGoal(GOALS, GID)))) or-else ((RULE == 'cas) and-then (PARSED-VARS in unfreeze(getCLA(getGoal(GOALS, GID)))))
            then 
                if (PARSED-GENSETS :: GenSetList) and-then (PARSED-GENSETS =/= nil)
                then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:TermList <- upTerm(freeze(PARSED-VARS, getSKO(getGoal(GOALS, GID)))) ; 'ARG2:GenSetList <- upTerm(PARSED-GENSETS)))
                else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, error(106), STR, true)
                fi
            else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, error(109), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >, error(108), STR, true)
        fi
        if (RULE == 'gsi) or-else (RULE == 'cas) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-VARS := parseVariables(SKO-MODULE, downTerm(VAR, 'nil.QidList), if (RULE == 'cas) then getVars(unfreeze(getCLA(getGoal(GOALS, GID)))) else getVars(getCLA(getGoal(GOALS, GID))) fi)
        /\ PARSED-GENSETS := parseGenSets(SKO-MODULE, GENSETS, PARSED-VARS, downTerm(GENSET,'nil.QidList)) .
    
    --- Narrowing Induction (NI)
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_on_., GID, NAWEX) =
        if PARSED-TERM :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, ((if (RULE == 'ns) then 'ins else RULE fi) STRAT), GID, ('ARG1:Term <- upTerm(PARSED-TERM)))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(104), STR, true)
        fi
        if (RULE == 'ns) or-else (RULE == 'ni)
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-TERM := parseTerm(SKO-MODULE, downTerm(NAWEX, 'nil.QidList)) .
    
    --- Lemma Enrichment (LE)
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_., GID, LEMMA) =
        if PARSED-LEMMA :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-LEMMA)))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(102), STR, true)
        fi
        if (RULE == 'le) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-LEMMA := parseClause(SKO-MODULE, downTerm(LEMMA, 'nil.QidList)) .
    
    --- Split (SP)
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_., GID, DISJ) =
        if PARSED-DISJ :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-DISJ) ; 'ARG2:Substitution <- 'none.Substitution))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(103), STR, true)
        fi
        if (RULE == 'sp) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-DISJ := parseDisjunction(SKO-MODULE, downTerm(DISJ, 'nil.QidList)) .
        
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_sub_., GID, (DISJ,SUB)) =
        if PARSED-DISJ :: Term
        then
            if PARSED-SUB :: Substitution
            then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-DISJ) ; 'ARG2:Substitution <- upTerm(PARSED-SUB)))
            else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(101), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(103), STR, true)
        fi
        if (RULE == 'sp) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-DISJ := parseDisjunction(SKO-MODULE, downTerm(DISJ, 'nil.QidList))
        /\ PARSED-SUB := parseSubstitution(SKO-MODULE, downTerm(SUB, 'nil.QidList)) .
    
    --- Variable Abstraction (VA)
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_on_., GID, TERM) =
        if PARSED-TERM :: Term
        then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-TERM)))
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(105), STR, true)
        fi
        if (RULE == 'va) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-TERM := parseTerm(SKO-MODULE, downTerm(TERM, 'nil.QidList)) .

    --- Cut (CUT)
    ceq checkArgs(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), 'apply_to_with_., GID, TERM) =
        if PARSED-CONJ :: Term
        then 
            if (getVars(PARSED-CONJ) in getVars(getCLA(getGoal(GOALS, GID))))
            then checkApply(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, STR, (RULE STRAT), GID, ('ARG1:Term <- upTerm(PARSED-CONJ)))
            else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(114), STR, true)
            fi
        else printErr(< OID : NuITP | ATS, internal: INTMOD | INTHPS | INTLOCAL, goals: GOALS >, error(113), STR, true)
        fi
        if (RULE == 'cut) 
        /\ SKO-MODULE := addOps(INTMOD, toOps(getSKO(getGoal(GOALS, GID))))
        /\ PARSED-CONJ := parseConjunction(SKO-MODULE, downTerm(TERM, 'nil.QidList)) .
    
    
    op checkApply : Configuration String QidList QidList Substitution -> Configuration .
    ceq checkApply(< OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, strats: SSL, goals: GOALS >, STR, STRAT, GID, SB) =
        < OID : NuITP | ATS', goals: GOALS'' >
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  " + getRuleMsg(STRAT) + " applied to goal " + join(GID) + "." + BW + "\n\n" +
            toStringApply(INTMOD, getFrontier(GOALS''), getChildren(GOALS'', GID), getFrontierChildren(GOALS'', GID), getNewLocallyProved(getProved(GOALS { (GID '. '1), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS'), getProved(GOALS'')), VERBOSE))
        if { (GID '. '1), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS' := applyRule(getLocalModule(INTMOD, INTLOCAL), STRAT, SB, GENSETS, SSL, toClauses(INTMOD) ;; INTLOCAL, getGoal(GOALS,GID))
        /\ < OID : NuITP | ATS', goals: GOALS'' > := checkLocalInt(< OID : NuITP | ATS, verbose: VERBOSE, log: (LOG [ GID : STR + "\n" ]), internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, strats: SSL, goals: (closeGoal(GOALS, GID) { (GID '. '1), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS') >) .
    eq checkApply(< OID : NuITP | ATS >, STR, RULE, GID, SB) = printErr(< OID : NuITP | ATS >, error(200, getRuleMsg(RULE), join(GID)), STR, true)  [ owise ] .
    eq checkApply(< OID : NuITP | ATS >, STR, RULE Q STRAT, GID, SB) = printErr(< OID : NuITP | ATS >, error(200, getRuleMsg(RULE Q STRAT), join(GID)), STR, true)  [ owise ] .

    op checkSimplify : Configuration String QidList QidList Substitution -> Configuration .
    ceq checkSimplify(< OID : NuITP | ATS, verbose: VERBOSE, log: LOG, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, strats: SSL, goals: GOALS >, STR, STRAT, GID, SB) =
        < OID : NuITP | ATS', goals: GOALS'' >
        write(stdout, OID, printCommand(ATS, STR) + CYAN + "  " + "Simplification Strategy " + if (STRAT == nil) then getDefaultStratId(SSL) else string(downTerm(STRAT, nil)) fi + " applied to goal " + join(GID) + "." + BW + "\n\n" +
            toStringApply(INTMOD, getFrontier(GOALS''), getChildren(GOALS'', GID), getFrontierChildren(GOALS'', GID), getNewLocallyProved(getProved(GOALS { (GID '. '1), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS'), getProved(GOALS'')), VERBOSE))
        if ((STRAT == nil) or-else getStrat(SSL, string(downTerm(STRAT, nil))) =/= empty)
        /\ { (GID '. '1), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS' := applyStrat(getLocalModule(INTMOD, INTLOCAL), downTerm(STRAT, nil), GENSETS, SSL, toClauses(INTMOD) ;; INTLOCAL, getGoal(GOALS,GID)) 
        /\ < OID : NuITP | ATS', goals: GOALS'' > := checkLocalInt(< OID : NuITP | ATS, verbose: VERBOSE, log: (LOG [ GID : STR + "\n" ]), internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, strats: SSL, goals: (closeGoal(GOALS, GID) { (GID '. '1), RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS') >) .
    eq checkSimplify(< OID : NuITP | ATS, strats: SSL >, STR, STRAT, GID, SB) = 
        if getStrat(SSL, string(downTerm(STRAT, nil))) == empty
        then printErr(< OID : NuITP | ATS, strats: SSL >, error(134, if (STRAT == nil) then getDefaultStratId(SSL) else string(downTerm(STRAT, nil)) fi), STR, true)  
        else printErr(< OID : NuITP | ATS, strats: SSL >, error(201, if (STRAT == nil) then getDefaultStratId(SSL) else string(downTerm(STRAT, nil)) fi, join(GID)), STR, true)  
        fi [ owise ] .
    eq checkSimplify(< OID : NuITP | ATS, strats: SSL >, STR, RULE Q STRAT, GID, SB) = 
        if getStrat(SSL, string(downTerm(STRAT, nil))) == empty
        then printErr(< OID : NuITP | ATS, strats: SSL >, error(134, string(downTerm(STRAT, nil))), STR, true)  
        else printErr(< OID : NuITP | ATS, strats: SSL >, error(201, printTokens(downTerm(RULE Q STRAT, nil)), join(GID)), STR, true)  
        fi [ owise ] .

    op checkLocalInt : Configuration -> Configuration .
    eq checkLocalInt(< OID : NuITP | ATS, local: false >) = < OID : NuITP | ATS, local: false > .
    eq checkLocalInt(< OID : NuITP | ATS, local: true, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, goals: GOALS >) = 
        checkUpdateInternal(< OID : NuITP | ATS, local: true, internal: internalizeLocal(INTMOD, INTHPS, INTLOCAL, getClauses(getLocalInt(GOALS))), gensets: GENSETS,
        goals: updateInternal(internalizeLocal(INTMOD, INTHPS, INTLOCAL, getClauses(getLocalInt(GOALS))), getGoals(getLocalInt(GOALS))) >) .
    
    op checkUpdateInternal : Configuration -> Configuration .
    ceq checkUpdateInternal(< OID : NuITP | ATS, verbose: VERBOSE, local: LOCAL, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, strats: SSL, goals: GOALS >) =
        (< OID : NuITP | ATS, verbose: VERBOSE, local: LOCAL, internal: INTMOD | INTHPS | INTLOCAL, gensets: GENSETS, strats: SSL, goals: GOALS' >)
        if GOALS' := applyStrat(getLocalModule(INTMOD, INTLOCAL), 'default-update-internal, GENSETS, SSL, toClauses(INTMOD) ;; INTLOCAL, GOALS) .
    eq checkUpdateInternal(CONF) = CONF [ owise ] .

    op getNewLocallyProved : GoalSet GoalSet -> GoalSet .
    eq getNewLocallyProved(({ GID, RID, INTER, FRO, SFRO, VC, SKO, HPS, CLA } GOALS), ({ GID, RID, INTER', FRO, SFRO, VC, SKO, HPS, CLA } GOALS')) = getNewLocallyProved(GOALS, GOALS') .
    eq getNewLocallyProved(mt, GOALS') = GOALS' [ owise ] .
endm

mod NuITP-EXT is
    pr NuITP .

    var M INTMOD : Module .
    var NTL : NeTermList .
    var TL : TermList .
    vars T GAMMA DELTA : Term .
    var INTHPS INTLOCAL : TermSet .
    var LEMMAS : NeTermSet .
    var PS : ProofState .
    var GOAL : Goal .
    var GOALS : GoalSet .

    op metaNuITPCheck : Module Term -> [ProofState] .
    ceq metaNuITPCheck(M, '_->_[GAMMA,DELTA]) = getProofState(GOAL GOALS)
        if (GOAL GOALS) := applyStrat(extModule(M), 'NuITP, mt, [ "NuITP" : NuITPDefaultStrategy ], mt, { '0, 'init, false, true, true, 1 + size(getVars('_->_[GAMMA,DELTA])), mt, mt, normalizeVars('_->_[GAMMA,DELTA]) }) .
    ceq metaNuITPCheck(M, T) = getProofState(GOAL GOALS)
        if (GOAL GOALS) := applyStrat(extModule(M), 'NuITP, mt, [ "NuITP" : NuITPDefaultStrategy ], mt, { '0, 'init, false, true, true, 1 + size(getVars(T)), mt, mt, normalizeVars('_->_['true.NuITP-Bool,T]) }) [ owise ] .
        
    op metaNuITPCheck : Module Term TermSet -> [ProofState] .
    ceq metaNuITPCheck(M, '_->_[GAMMA,DELTA], mt) = getProofState(GOAL GOALS)
        if (GOAL GOALS) := applyStrat(extModule(M), 'NuITP, mt, [ "NuITP" : NuITPDefaultStrategy ], mt, { '0, 'init, false, true, true, 1 + size(getVars('_->_[GAMMA,DELTA])), mt, mt, normalizeVars('_->_[GAMMA,DELTA]) }) .
    ceq metaNuITPCheck(M, T, mt) = getProofState(GOAL GOALS)
        if (GOAL GOALS) := applyStrat(extModule(M), 'NuITP, mt, [ "NuITP" : NuITPDefaultStrategy ], mt, { '0, 'init, false, true, true, 1 + size(getVars(T)), mt, mt, normalizeVars('_->_['true.NuITP-Bool,T]) }) [ owise ] .
    
    ceq metaNuITPCheck(M, '_->_[GAMMA,DELTA], LEMMAS) = getProofState(GOAL GOALS)
        if (INTMOD | INTHPS | INTLOCAL) := internalize(extModule(M), mt, mt, normalizeVarsInternal(LEMMAS, "H", 0))
        /\ (GOAL GOALS) := applyStrat(INTMOD, 'NuITP, mt, [ "NuITP" : NuITPDefaultStrategy ], mt, { '0, 'init, false, true, true, 1 + size(getVars('_->_[GAMMA,DELTA])), mt, hsimp(INTMOD, mt, INTHPS), normalizeVars('_->_[GAMMA,DELTA]) }) .
    ceq metaNuITPCheck(M, T, LEMMAS) = getProofState(GOAL GOALS)
        if (INTMOD | INTHPS | INTLOCAL) := internalize(extModule(M), mt, mt, normalizeVarsInternal(LEMMAS, "H", 0))
        /\ (GOAL GOALS) := applyStrat(INTMOD, 'NuITP, mt, [ "NuITP" : NuITPDefaultStrategy ], mt, { '0, 'init, false, true, true, 1 + size(getVars(T)), mt, hsimp(INTMOD, mt, INTHPS), normalizeVars('_->_['true.NuITP-Bool,T]) }) [ owise ] .
endm

set show command off . 

---erew in NuITP : init .

eof
